! function (t) {
    var e = {};

    function n(i) {
        if (e[i]) return e[i].exports;
        var r = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
    }
    n.m = t, n.c = e, n.d = function (t, e, i) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        })
    }, n.r = function (t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, n.t = function (t, e) {
        if (1 & e && (t = n(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var i = Object.create(null);
        if (n.r(i), Object.defineProperty(i, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var r in t) n.d(i, r, function (e) {
                return t[e]
            }.bind(null, r));
        return i
    }, n.n = function (t) {
        var e = t && t.__esModule ? function () {
            return t.default
        } : function () {
            return t
        };
        return n.d(e, "a", e), e
    }, n.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, n.p = "", n(n.s = 9)
}([function (t, e, n) {
    var i, r, o, a;
    "undefined" != typeof window && window, o = {
            id: "ev-emitter/ev-emitter",
            exports: {},
            loaded: !1
        }, i = "function" == typeof (r = function () {
            function t() {}
            var e = t.prototype;
            return e.on = function (t, e) {
                if (t && e) {
                    var n = this._events = this._events || {},
                        i = n[t] = n[t] || [];
                    return -1 == i.indexOf(e) && i.push(e), this
                }
            }, e.once = function (t, e) {
                if (t && e) {
                    this.on(t, e);
                    var n = this._onceEvents = this._onceEvents || {};
                    return (n[t] = n[t] || {})[e] = !0, this
                }
            }, e.off = function (t, e) {
                var n = this._events && this._events[t];
                if (n && n.length) {
                    var i = n.indexOf(e);
                    return -1 != i && n.splice(i, 1), this
                }
            }, e.emitEvent = function (t, e) {
                var n = this._events && this._events[t];
                if (n && n.length) {
                    var i = 0,
                        r = n[i];
                    e = e || [];
                    for (var o = this._onceEvents && this._onceEvents[t]; r;) {
                        var a = o && o[r];
                        a && (this.off(t, r), delete o[r]), r.apply(this, e), r = n[i += a ? 0 : 1]
                    }
                    return this
                }
            }, t
        }) ? r.call(o.exports, n, o.exports, o) : r, o.loaded = !0, void 0 !== i || (i = o.exports),
        function (n, r) {
            "use strict";
            void 0 === (a = function (t) {
                return function (t, e) {
                    function n(t, e) {
                        for (var n in e) t[n] = e[n];
                        return t
                    }

                    function i(t, e, r) {
                        return this instanceof i ? ("string" == typeof t && (t = document.querySelectorAll(t)), this.elements = function (t) {
                            var e = [];
                            if (Array.isArray(t)) e = t;
                            else if ("number" == typeof t.length)
                                for (var n = 0; n < t.length; n++) e.push(t[n]);
                            else e.push(t);
                            return e
                        }(t), this.options = n({}, this.options), "function" == typeof e ? r = e : n(this.options, e), r && this.on("always", r), this.getImages(), a && (this.jqDeferred = new a.Deferred), void setTimeout(function () {
                            this.check()
                        }.bind(this))) : new i(t, e, r)
                    }

                    function r(t) {
                        this.img = t
                    }

                    function o(t, e) {
                        this.url = t, this.element = e, this.img = new Image
                    }
                    var a = t.jQuery,
                        s = t.console;
                    i.prototype = Object.create(e.prototype), i.prototype.options = {}, i.prototype.getImages = function () {
                        this.images = [], this.elements.forEach(this.addElementImages, this)
                    }, i.prototype.addElementImages = function (t) {
                        "IMG" == t.nodeName && this.addImage(t), !0 === this.options.background && this.addElementBackgroundImages(t);
                        var e = t.nodeType;
                        if (e && l[e]) {
                            for (var n = t.querySelectorAll("img"), i = 0; i < n.length; i++) {
                                var r = n[i];
                                this.addImage(r)
                            }
                            if ("string" == typeof this.options.background) {
                                var o = t.querySelectorAll(this.options.background);
                                for (i = 0; i < o.length; i++) {
                                    var a = o[i];
                                    this.addElementBackgroundImages(a)
                                }
                            }
                        }
                    };
                    var l = {
                        1: !0,
                        9: !0,
                        11: !0
                    };
                    return i.prototype.addElementBackgroundImages = function (t) {
                        var e = getComputedStyle(t);
                        if (e)
                            for (var n = /url\((['"])?(.*?)\1\)/gi, i = n.exec(e.backgroundImage); null !== i;) {
                                var r = i && i[2];
                                r && this.addBackground(r, t), i = n.exec(e.backgroundImage)
                            }
                    }, i.prototype.addImage = function (t) {
                        var e = new r(t);
                        this.images.push(e)
                    }, i.prototype.addBackground = function (t, e) {
                        var n = new o(t, e);
                        this.images.push(n)
                    }, i.prototype.check = function () {
                        function t(t, n, i) {
                            setTimeout((function () {
                                e.progress(t, n, i)
                            }))
                        }
                        var e = this;
                        return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach((function (e) {
                            e.once("progress", t), e.check()
                        })) : void this.complete()
                    }, i.prototype.progress = function (t, e, n) {
                        this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded, this.emitEvent("progress", [this, t, e]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, t), this.progressedCount == this.images.length && this.complete(), this.options.debug && s && s.log("progress: " + n, t, e)
                    }, i.prototype.complete = function () {
                        var t = this.hasAnyBroken ? "fail" : "done";
                        if (this.isComplete = !0, this.emitEvent(t, [this]), this.emitEvent("always", [this]), this.jqDeferred) {
                            var e = this.hasAnyBroken ? "reject" : "resolve";
                            this.jqDeferred[e](this)
                        }
                    }, r.prototype = Object.create(e.prototype), r.prototype.check = function () {
                        return this.getIsImageComplete() ? void this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), void(this.proxyImage.src = this.img.src))
                    }, r.prototype.getIsImageComplete = function () {
                        return this.img.complete && void 0 !== this.img.naturalWidth
                    }, r.prototype.confirm = function (t, e) {
                        this.isLoaded = t, this.emitEvent("progress", [this, this.img, e])
                    }, r.prototype.handleEvent = function (t) {
                        var e = "on" + t.type;
                        this[e] && this[e](t)
                    }, r.prototype.onload = function () {
                        this.confirm(!0, "onload"), this.unbindEvents()
                    }, r.prototype.onerror = function () {
                        this.confirm(!1, "onerror"), this.unbindEvents()
                    }, r.prototype.unbindEvents = function () {
                        this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
                    }, o.prototype = Object.create(r.prototype), o.prototype.check = function () {
                        this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents())
                    }, o.prototype.unbindEvents = function () {
                        this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
                    }, o.prototype.confirm = function (t, e) {
                        this.isLoaded = t, this.emitEvent("progress", [this, this.element, e])
                    }, i.makeJQueryPlugin = function (e) {
                        (e = e || t.jQuery) && ((a = e).fn.imagesLoaded = function (t, e) {
                            return new i(this, t, e).jqDeferred.promise(a(this))
                        })
                    }, i.makeJQueryPlugin(), i
                }(n, t)
            }.apply(e, [i])) || (t.exports = a)
        }(window)
}, function (t, e, n) {
    "use strict";
    (function (t) {
        function n(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function r(t, e, n) {
            return e && i(t.prototype, e), n && i(t, n), t
        }

        function o(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function a(t, e) {
            var n = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                e && (i = i.filter((function (e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), n.push.apply(n, i)
            }
            return n
        }

        function s(t) {
            for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2 ? a(Object(n), !0).forEach((function (e) {
                    o(t, e, n[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : a(Object(n)).forEach((function (e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                }))
            }
            return t
        }

        function l(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && h(t, e)
        }

        function c(t) {
            return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }

        function h(t, e) {
            return (h = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function u(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function d(t, e) {
            return !e || "object" != typeof e && "function" != typeof e ? u(t) : e
        }

        function p(t) {
            var e = function () {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function () {
                var n, i = c(t);
                if (e) {
                    var r = c(this).constructor;
                    n = Reflect.construct(i, arguments, r)
                } else n = i.apply(this, arguments);
                return d(this, n)
            }
        }

        function f(t, e, n) {
            return (f = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
                var i = function (t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = c(t)););
                    return t
                }(t, e);
                if (i) {
                    var r = Object.getOwnPropertyDescriptor(i, e);
                    return r.get ? r.get.call(n) : r.value
                }
            })(t, e, n || t)
        }

        function m(t, e) {
            return function (t) {
                if (Array.isArray(t)) return t
            }(t) || function (t, e) {
                if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                var n = [],
                    i = !0,
                    r = !1,
                    o = void 0;
                try {
                    for (var a, s = t[Symbol.iterator](); !(i = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); i = !0);
                } catch (t) {
                    r = !0, o = t
                } finally {
                    try {
                        i || null == s.return || s.return()
                    } finally {
                        if (r) throw o
                    }
                }
                return n
            }(t, e) || g(t, e) || function () {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function v(t) {
            return function (t) {
                if (Array.isArray(t)) return y(t)
            }(t) || function (t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || g(t) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function g(t, e) {
            if (t) {
                if ("string" == typeof t) return y(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? y(t, e) : void 0
            }
        }

        function y(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
            return i
        }
        var _ = {
                el: document,
                name: "scroll",
                offset: [0, 0],
                repeat: !1,
                smooth: !1,
                direction: "vertical",
                gestureDirection: "vertical",
                reloadOnContextChange: !1,
                lerp: .1,
                class: "is-inview",
                scrollbarContainer: !1,
                scrollbarClass: "c-scrollbar",
                scrollingClass: "has-scroll-scrolling",
                draggingClass: "has-scroll-dragging",
                smoothClass: "has-scroll-smooth",
                initClass: "has-scroll-init",
                getSpeed: !1,
                getDirection: !1,
                scrollFromAnywhere: !1,
                multiplier: 1,
                firefoxMultiplier: 50,
                touchMultiplier: 2,
                resetNativeScroll: !0,
                tablet: {
                    smooth: !1,
                    direction: "vertical",
                    gestureDirection: "vertical",
                    breakpoint: 1024
                },
                smartphone: {
                    smooth: !1,
                    direction: "vertical",
                    gestureDirection: "vertical"
                }
            },
            x = function () {
                function t() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    n(this, t), Object.assign(this, _, e), this.smartphone = _.smartphone, e.smartphone && Object.assign(this.smartphone, e.smartphone), this.tablet = _.tablet, e.tablet && Object.assign(this.tablet, e.tablet), this.namespace = "locomotive", this.html = document.documentElement, this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.windowMiddle = {
                        x: this.windowWidth / 2,
                        y: this.windowHeight / 2
                    }, this.els = {}, this.currentElements = {}, this.listeners = {}, this.hasScrollTicking = !1, this.hasCallEventSet = !1, this.checkScroll = this.checkScroll.bind(this), this.checkResize = this.checkResize.bind(this), this.checkEvent = this.checkEvent.bind(this), this.instance = {
                        scroll: {
                            x: 0,
                            y: 0
                        },
                        limit: {
                            x: this.html.offsetHeight,
                            y: this.html.offsetHeight
                        },
                        currentElements: this.currentElements
                    }, this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", this.isMobile && (this.direction = this[this.context].direction), "horizontal" === this.direction ? this.directionAxis = "x" : this.directionAxis = "y", this.getDirection && (this.instance.direction = null), this.getDirection && (this.instance.speed = 0), this.html.classList.add(this.initClass), window.addEventListener("resize", this.checkResize, !1)
                }
                return r(t, [{
                    key: "init",
                    value: function () {
                        this.initEvents()
                    }
                }, {
                    key: "checkScroll",
                    value: function () {
                        this.dispatchScroll()
                    }
                }, {
                    key: "checkResize",
                    value: function () {
                        var t = this;
                        this.resizeTick || (this.resizeTick = !0, requestAnimationFrame((function () {
                            t.resize(), t.resizeTick = !1
                        })))
                    }
                }, {
                    key: "resize",
                    value: function () {}
                }, {
                    key: "checkContext",
                    value: function () {
                        if (this.reloadOnContextChange) {
                            this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint, this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
                            var t = this.context;
                            if (this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", t != this.context)("desktop" == t ? this.smooth : this[t].smooth) != ("desktop" == this.context ? this.smooth : this[this.context].smooth) && window.location.reload()
                        }
                    }
                }, {
                    key: "initEvents",
                    value: function () {
                        var t = this;
                        this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]")), this.setScrollTo = this.setScrollTo.bind(this), this.scrollToEls.forEach((function (e) {
                            e.addEventListener("click", t.setScrollTo, !1)
                        }))
                    }
                }, {
                    key: "setScrollTo",
                    value: function (t) {
                        t.preventDefault(), this.scrollTo(t.currentTarget.getAttribute("data-".concat(this.name, "-href")) || t.currentTarget.getAttribute("href"), {
                            offset: t.currentTarget.getAttribute("data-".concat(this.name, "-offset"))
                        })
                    }
                }, {
                    key: "addElements",
                    value: function () {}
                }, {
                    key: "detectElements",
                    value: function (t) {
                        var e = this,
                            n = this.instance.scroll.y,
                            i = n + this.windowHeight,
                            r = this.instance.scroll.x,
                            o = r + this.windowWidth;
                        Object.entries(this.els).forEach((function (a) {
                            var s = m(a, 2),
                                l = s[0],
                                c = s[1];
                            if (!c || c.inView && !t || ("horizontal" === e.direction ? o >= c.left && r < c.right && e.setInView(c, l) : i >= c.top && n < c.bottom && e.setInView(c, l)), c && c.inView)
                                if ("horizontal" === e.direction) {
                                    var h = c.right - c.left;
                                    c.progress = (e.instance.scroll.x - (c.left - e.windowWidth)) / (h + e.windowWidth), (o < c.left || r > c.right) && e.setOutOfView(c, l)
                                } else {
                                    var u = c.bottom - c.top;
                                    c.progress = (e.instance.scroll.y - (c.top - e.windowHeight)) / (u + e.windowHeight), (i < c.top || n > c.bottom) && e.setOutOfView(c, l)
                                }
                        })), this.hasScrollTicking = !1
                    }
                }, {
                    key: "setInView",
                    value: function (t, e) {
                        this.els[e].inView = !0, t.el.classList.add(t.class), this.currentElements[e] = t, t.call && this.hasCallEventSet && (this.dispatchCall(t, "enter"), t.repeat || (this.els[e].call = !1))
                    }
                }, {
                    key: "setOutOfView",
                    value: function (t, e) {
                        var n = this;
                        this.els[e].inView = !1, Object.keys(this.currentElements).forEach((function (t) {
                            t === e && delete n.currentElements[t]
                        })), t.call && this.hasCallEventSet && this.dispatchCall(t, "exit"), t.repeat && t.el.classList.remove(t.class)
                    }
                }, {
                    key: "dispatchCall",
                    value: function (t, e) {
                        this.callWay = e, this.callValue = t.call.split(",").map((function (t) {
                            return t.trim()
                        })), this.callObj = t, 1 == this.callValue.length && (this.callValue = this.callValue[0]);
                        var n = new Event(this.namespace + "call");
                        this.el.dispatchEvent(n)
                    }
                }, {
                    key: "dispatchScroll",
                    value: function () {
                        var t = new Event(this.namespace + "scroll");
                        this.el.dispatchEvent(t)
                    }
                }, {
                    key: "setEvents",
                    value: function (t, e) {
                        this.listeners[t] || (this.listeners[t] = []);
                        var n = this.listeners[t];
                        n.push(e), 1 === n.length && this.el.addEventListener(this.namespace + t, this.checkEvent, !1), "call" === t && (this.hasCallEventSet = !0, this.detectElements(!0))
                    }
                }, {
                    key: "unsetEvents",
                    value: function (t, e) {
                        if (this.listeners[t]) {
                            var n = this.listeners[t],
                                i = n.indexOf(e);
                            i < 0 || (n.splice(i, 1), 0 === n.index && this.el.removeEventListener(this.namespace + t, this.checkEvent, !1))
                        }
                    }
                }, {
                    key: "checkEvent",
                    value: function (t) {
                        var e = this,
                            n = t.type.replace(this.namespace, ""),
                            i = this.listeners[n];
                        i && 0 !== i.length && i.forEach((function (t) {
                            switch (n) {
                                case "scroll":
                                    return t(e.instance);
                                case "call":
                                    return t(e.callValue, e.callWay, e.callObj);
                                default:
                                    return t()
                            }
                        }))
                    }
                }, {
                    key: "startScroll",
                    value: function () {}
                }, {
                    key: "stopScroll",
                    value: function () {}
                }, {
                    key: "setScroll",
                    value: function (t, e) {
                        this.instance.scroll = {
                            x: 0,
                            y: 0
                        }
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        var t = this;
                        window.removeEventListener("resize", this.checkResize, !1), Object.keys(this.listeners).forEach((function (e) {
                            t.el.removeEventListener(t.namespace + e, t.checkEvent, !1)
                        })), this.listeners = {}, this.scrollToEls.forEach((function (e) {
                            e.removeEventListener("click", t.setScrollTo, !1)
                        })), this.html.classList.remove(this.initClass)
                    }
                }]), t
            }(),
            b = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {};

        function w(t, e) {
            return t(e = {
                exports: {}
            }, e.exports), e.exports
        }
        var M = w((function (t, e) {
                t.exports = {
                    polyfill: function () {
                        var t = window,
                            e = document;
                        if (!("scrollBehavior" in e.documentElement.style) || !0 === t.__forceSmoothScrollPolyfill__) {
                            var n, i = t.HTMLElement || t.Element,
                                r = {
                                    scroll: t.scroll || t.scrollTo,
                                    scrollBy: t.scrollBy,
                                    elementScroll: i.prototype.scroll || s,
                                    scrollIntoView: i.prototype.scrollIntoView
                                },
                                o = t.performance && t.performance.now ? t.performance.now.bind(t.performance) : Date.now,
                                a = (n = t.navigator.userAgent, new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(n) ? 1 : 0);
                            t.scroll = t.scrollTo = function () {
                                void 0 !== arguments[0] && (!0 !== l(arguments[0]) ? f.call(t, e.body, void 0 !== arguments[0].left ? ~~arguments[0].left : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : t.scrollY || t.pageYOffset) : r.scroll.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : t.scrollY || t.pageYOffset))
                            }, t.scrollBy = function () {
                                void 0 !== arguments[0] && (l(arguments[0]) ? r.scrollBy.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : f.call(t, e.body, ~~arguments[0].left + (t.scrollX || t.pageXOffset), ~~arguments[0].top + (t.scrollY || t.pageYOffset)))
                            }, i.prototype.scroll = i.prototype.scrollTo = function () {
                                if (void 0 !== arguments[0])
                                    if (!0 !== l(arguments[0])) {
                                        var t = arguments[0].left,
                                            e = arguments[0].top;
                                        f.call(this, this, void 0 === t ? this.scrollLeft : ~~t, void 0 === e ? this.scrollTop : ~~e)
                                    } else {
                                        if ("number" == typeof arguments[0] && void 0 === arguments[1]) throw new SyntaxError("Value could not be converted");
                                        r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : "object" != typeof arguments[0] ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop)
                                    }
                            }, i.prototype.scrollBy = function () {
                                void 0 !== arguments[0] && (!0 !== l(arguments[0]) ? this.scroll({
                                    left: ~~arguments[0].left + this.scrollLeft,
                                    top: ~~arguments[0].top + this.scrollTop,
                                    behavior: arguments[0].behavior
                                }) : r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop))
                            }, i.prototype.scrollIntoView = function () {
                                if (!0 !== l(arguments[0])) {
                                    var n = d(this),
                                        i = n.getBoundingClientRect(),
                                        o = this.getBoundingClientRect();
                                    n !== e.body ? (f.call(this, n, n.scrollLeft + o.left - i.left, n.scrollTop + o.top - i.top), "fixed" !== t.getComputedStyle(n).position && t.scrollBy({
                                        left: i.left,
                                        top: i.top,
                                        behavior: "smooth"
                                    })) : t.scrollBy({
                                        left: o.left,
                                        top: o.top,
                                        behavior: "smooth"
                                    })
                                } else r.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0])
                            }
                        }

                        function s(t, e) {
                            this.scrollLeft = t, this.scrollTop = e
                        }

                        function l(t) {
                            if (null === t || "object" != typeof t || void 0 === t.behavior || "auto" === t.behavior || "instant" === t.behavior) return !0;
                            if ("object" == typeof t && "smooth" === t.behavior) return !1;
                            throw new TypeError("behavior member of ScrollOptions " + t.behavior + " is not a valid value for enumeration ScrollBehavior.")
                        }

                        function c(t, e) {
                            return "Y" === e ? t.clientHeight + a < t.scrollHeight : "X" === e ? t.clientWidth + a < t.scrollWidth : void 0
                        }

                        function h(e, n) {
                            var i = t.getComputedStyle(e, null)["overflow" + n];
                            return "auto" === i || "scroll" === i
                        }

                        function u(t) {
                            var e = c(t, "Y") && h(t, "Y"),
                                n = c(t, "X") && h(t, "X");
                            return e || n
                        }

                        function d(t) {
                            for (; t !== e.body && !1 === u(t);) t = t.parentNode || t.host;
                            return t
                        }

                        function p(e) {
                            var n, i, r, a, s = (o() - e.startTime) / 468;
                            a = s = s > 1 ? 1 : s, n = .5 * (1 - Math.cos(Math.PI * a)), i = e.startX + (e.x - e.startX) * n, r = e.startY + (e.y - e.startY) * n, e.method.call(e.scrollable, i, r), i === e.x && r === e.y || t.requestAnimationFrame(p.bind(t, e))
                        }

                        function f(n, i, a) {
                            var l, c, h, u, d = o();
                            n === e.body ? (l = t, c = t.scrollX || t.pageXOffset, h = t.scrollY || t.pageYOffset, u = r.scroll) : (l = n, c = n.scrollLeft, h = n.scrollTop, u = s), p({
                                scrollable: l,
                                method: u,
                                startTime: d,
                                startX: c,
                                startY: h,
                                x: i,
                                y: a
                            })
                        }
                    }
                }
            })),
            S = (M.polyfill, function (t) {
                l(i, t);
                var e = p(i);

                function i() {
                    var t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return n(this, i), (t = e.call(this, r)).resetNativeScroll && (history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0)), window.addEventListener("scroll", t.checkScroll, !1), void 0 === window.smoothscrollPolyfill && (window.smoothscrollPolyfill = M, window.smoothscrollPolyfill.polyfill()), t
                }
                return r(i, [{
                    key: "init",
                    value: function () {
                        this.instance.scroll.y = window.pageYOffset, this.addElements(), this.detectElements(), f(c(i.prototype), "init", this).call(this)
                    }
                }, {
                    key: "checkScroll",
                    value: function () {
                        var t = this;
                        f(c(i.prototype), "checkScroll", this).call(this), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.instance.scroll.y = window.pageYOffset, Object.entries(this.els).length && (this.hasScrollTicking || (requestAnimationFrame((function () {
                            t.detectElements()
                        })), this.hasScrollTicking = !0))
                    }
                }, {
                    key: "addDirection",
                    value: function () {
                        window.pageYOffset > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : window.pageYOffset < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up")
                    }
                }, {
                    key: "addSpeed",
                    value: function () {
                        window.pageYOffset != this.instance.scroll.y ? this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
                    }
                }, {
                    key: "resize",
                    value: function () {
                        Object.entries(this.els).length && (this.windowHeight = window.innerHeight, this.updateElements())
                    }
                }, {
                    key: "addElements",
                    value: function () {
                        var t = this;
                        this.els = {}, this.el.querySelectorAll("[data-" + this.name + "]").forEach((function (e, n) {
                            e.getBoundingClientRect();
                            var i, r, o, a = e.dataset[t.name + "Class"] || t.class,
                                s = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : n,
                                l = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset,
                                c = e.dataset[t.name + "Repeat"],
                                h = e.dataset[t.name + "Call"],
                                u = e.dataset[t.name + "Target"],
                                d = (o = void 0 !== u ? document.querySelector("".concat(u)) : e).getBoundingClientRect();
                            i = d.top + t.instance.scroll.y, r = d.left + t.instance.scroll.x;
                            var p = i + o.offsetHeight,
                                f = r + o.offsetWidth;
                            "#header" === u && console.log(i, p), c = "false" != c && (null != c || t.repeat);
                            var m = t.getRelativeOffset(l),
                                v = {
                                    el: e,
                                    targetEl: o,
                                    id: s,
                                    class: a,
                                    top: i += m[0],
                                    bottom: p -= m[1],
                                    left: r,
                                    right: f,
                                    offset: l,
                                    progress: 0,
                                    repeat: c,
                                    inView: !1,
                                    call: h
                                };
                            t.els[s] = v, e.classList.contains(a) && t.setInView(t.els[s], s)
                        }))
                    }
                }, {
                    key: "updateElements",
                    value: function () {
                        var t = this;
                        Object.entries(this.els).forEach((function (e) {
                            var n = m(e, 2),
                                i = n[0],
                                r = n[1],
                                o = r.targetEl.getBoundingClientRect().top + t.instance.scroll.y,
                                a = o + r.targetEl.offsetHeight,
                                s = t.getRelativeOffset(r.offset);
                            t.els[i].top = o + s[0], t.els[i].bottom = a - s[1]
                        })), this.hasScrollTicking = !1
                    }
                }, {
                    key: "getRelativeOffset",
                    value: function (t) {
                        var e = [0, 0];
                        if (t)
                            for (var n = 0; n < t.length; n++) "string" == typeof t[n] ? t[n].includes("%") ? e[n] = parseInt(t[n].replace("%", "") * this.windowHeight / 100) : e[n] = parseInt(t[n]) : e[n] = t[n];
                        return e
                    }
                }, {
                    key: "scrollTo",
                    value: function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                            n = parseInt(e.offset) || 0,
                            i = !!e.callback && e.callback;
                        if ("string" == typeof t) {
                            if ("top" === t) t = this.html;
                            else if ("bottom" === t) t = this.html.offsetHeight - window.innerHeight;
                            else if (!(t = document.querySelector(t))) return
                        } else if ("number" == typeof t) t = parseInt(t);
                        else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid");
                        if (n = "number" != typeof t ? t.getBoundingClientRect().top + n + this.instance.scroll.y : t + n, i) {
                            n = n.toFixed();
                            var r = function t() {
                                window.pageYOffset.toFixed() === n && (window.removeEventListener("scroll", t), i())
                            };
                            window.addEventListener("scroll", r)
                        }
                        window.scrollTo({
                            top: n,
                            behavior: "smooth"
                        })
                    }
                }, {
                    key: "update",
                    value: function () {
                        this.addElements(), this.detectElements()
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        f(c(i.prototype), "destroy", this).call(this), window.removeEventListener("scroll", this.checkScroll, !1)
                    }
                }]), i
            }(x)),
            T = Object.getOwnPropertySymbols,
            E = Object.prototype.hasOwnProperty,
            A = Object.prototype.propertyIsEnumerable;

        function C(t) {
            if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(t)
        }
        var L = function () {
            try {
                if (!Object.assign) return !1;
                var t = new String("abc");
                if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
                for (var e = {}, n = 0; n < 10; n++) e["_" + String.fromCharCode(n)] = n;
                if ("0123456789" !== Object.getOwnPropertyNames(e).map((function (t) {
                        return e[t]
                    })).join("")) return !1;
                var i = {};
                return "abcdefghijklmnopqrst".split("").forEach((function (t) {
                    i[t] = t
                })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, i)).join("")
            } catch (t) {
                return !1
            }
        }() ? Object.assign : function (t, e) {
            for (var n, i, r = C(t), o = 1; o < arguments.length; o++) {
                for (var a in n = Object(arguments[o])) E.call(n, a) && (r[a] = n[a]);
                if (T) {
                    i = T(n);
                    for (var s = 0; s < i.length; s++) A.call(n, i[s]) && (r[i[s]] = n[i[s]])
                }
            }
            return r
        };

        function P() {}
        P.prototype = {
            on: function (t, e, n) {
                var i = this.e || (this.e = {});
                return (i[t] || (i[t] = [])).push({
                    fn: e,
                    ctx: n
                }), this
            },
            once: function (t, e, n) {
                var i = this;

                function r() {
                    i.off(t, r), e.apply(n, arguments)
                }
                return r._ = e, this.on(t, r, n)
            },
            emit: function (t) {
                for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++) n[i].fn.apply(n[i].ctx, e);
                return this
            },
            off: function (t, e) {
                var n = this.e || (this.e = {}),
                    i = n[t],
                    r = [];
                if (i && e)
                    for (var o = 0, a = i.length; o < a; o++) i[o].fn !== e && i[o].fn._ !== e && r.push(i[o]);
                return r.length ? n[t] = r : delete n[t], this
            }
        };
        var R = P,
            O = w((function (t, e) {
                (function () {
                    (null !== e ? e : this).Lethargy = function () {
                        function t(t, e, n, i) {
                            this.stability = null != t ? Math.abs(t) : 8, this.sensitivity = null != e ? 1 + Math.abs(e) : 100, this.tolerance = null != n ? 1 + Math.abs(n) : 1.1, this.delay = null != i ? i : 150, this.lastUpDeltas = function () {
                                var t, e, n;
                                for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                                return n
                            }.call(this), this.lastDownDeltas = function () {
                                var t, e, n;
                                for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                                return n
                            }.call(this), this.deltasTimestamp = function () {
                                var t, e, n;
                                for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                                return n
                            }.call(this)
                        }
                        return t.prototype.check = function (t) {
                            var e;
                            return null != (t = t.originalEvent || t).wheelDelta ? e = t.wheelDelta : null != t.deltaY ? e = -40 * t.deltaY : null == t.detail && 0 !== t.detail || (e = -40 * t.detail), this.deltasTimestamp.push(Date.now()), this.deltasTimestamp.shift(), e > 0 ? (this.lastUpDeltas.push(e), this.lastUpDeltas.shift(), this.isInertia(1)) : (this.lastDownDeltas.push(e), this.lastDownDeltas.shift(), this.isInertia(-1))
                        }, t.prototype.isInertia = function (t) {
                            var e, n, i, r, o, a, s;
                            return null === (e = -1 === t ? this.lastDownDeltas : this.lastUpDeltas)[0] ? t : !(this.deltasTimestamp[2 * this.stability - 2] + this.delay > Date.now() && e[0] === e[2 * this.stability - 1]) && (i = e.slice(0, this.stability), n = e.slice(this.stability, 2 * this.stability), s = i.reduce((function (t, e) {
                                return t + e
                            })), o = n.reduce((function (t, e) {
                                return t + e
                            })), a = s / i.length, r = o / n.length, Math.abs(a) < Math.abs(r * this.tolerance) && this.sensitivity < Math.abs(r) && t)
                        }, t.prototype.showLastUpDeltas = function () {
                            return this.lastUpDeltas
                        }, t.prototype.showLastDownDeltas = function () {
                            return this.lastDownDeltas
                        }, t
                    }()
                }).call(b)
            })),
            D = {
                hasWheelEvent: "onwheel" in document,
                hasMouseWheelEvent: "onmousewheel" in document,
                hasTouch: "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
                hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                hasPointer: !!window.navigator.msPointerEnabled,
                hasKeyDown: "onkeydown" in document,
                isFirefox: navigator.userAgent.indexOf("Firefox") > -1
            },
            I = Object.prototype.toString,
            N = Object.prototype.hasOwnProperty;

        function k(t, e) {
            return function () {
                return t.apply(e, arguments)
            }
        }
        var z = O.Lethargy,
            B = "virtualscroll",
            F = W,
            U = 37,
            H = 38,
            G = 39,
            V = 40,
            j = 32;

        function W(t) {
            ! function (t) {
                if (!t) return console.warn("bindAll requires at least one argument.");
                var e = Array.prototype.slice.call(arguments, 1);
                if (0 === e.length)
                    for (var n in t) N.call(t, n) && "function" == typeof t[n] && "[object Function]" == I.call(t[n]) && e.push(n);
                for (var i = 0; i < e.length; i++) {
                    var r = e[i];
                    t[r] = k(t[r], t)
                }
            }(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown"), this.el = window, t && t.el && (this.el = t.el, delete t.el), this.options = L({
                mouseMultiplier: 1,
                touchMultiplier: 2,
                firefoxMultiplier: 15,
                keyStep: 120,
                preventTouch: !1,
                unpreventTouchClass: "vs-touchmove-allowed",
                limitInertia: !1,
                useKeyboard: !0,
                useTouch: !0
            }, t), this.options.limitInertia && (this._lethargy = new z), this._emitter = new R, this._event = {
                y: 0,
                x: 0,
                deltaX: 0,
                deltaY: 0
            }, this.touchStartX = null, this.touchStartY = null, this.bodyTouchAction = null, void 0 !== this.options.passive && (this.listenerOptions = {
                passive: this.options.passive
            })
        }

        function q(t, e, n) {
            return (1 - n) * t + n * e
        }

        function X(t) {
            var e = {};
            if (window.getComputedStyle) {
                var n = getComputedStyle(t),
                    i = n.transform || n.webkitTransform || n.mozTransform,
                    r = i.match(/^matrix3d\((.+)\)$/);
                return r ? (e.x = r ? parseFloat(r[1].split(", ")[12]) : 0, e.y = r ? parseFloat(r[1].split(", ")[13]) : 0) : (r = i.match(/^matrix\((.+)\)$/), e.x = r ? parseFloat(r[1].split(", ")[4]) : 0, e.y = r ? parseFloat(r[1].split(", ")[5]) : 0), e
            }
        }

        function Y(t) {
            for (var e = []; t && t !== document; t = t.parentNode) e.push(t);
            return e
        }
        W.prototype._notify = function (t) {
            var e = this._event;
            e.x += e.deltaX, e.y += e.deltaY, this._emitter.emit(B, {
                x: e.x,
                y: e.y,
                deltaX: e.deltaX,
                deltaY: e.deltaY,
                originalEvent: t
            })
        }, W.prototype._onWheel = function (t) {
            var e = this.options;
            if (!this._lethargy || !1 !== this._lethargy.check(t)) {
                var n = this._event;
                n.deltaX = t.wheelDeltaX || -1 * t.deltaX, n.deltaY = t.wheelDeltaY || -1 * t.deltaY, D.isFirefox && 1 == t.deltaMode && (n.deltaX *= e.firefoxMultiplier, n.deltaY *= e.firefoxMultiplier), n.deltaX *= e.mouseMultiplier, n.deltaY *= e.mouseMultiplier, this._notify(t)
            }
        }, W.prototype._onMouseWheel = function (t) {
            if (!this.options.limitInertia || !1 !== this._lethargy.check(t)) {
                var e = this._event;
                e.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0, e.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta, this._notify(t)
            }
        }, W.prototype._onTouchStart = function (t) {
            var e = t.targetTouches ? t.targetTouches[0] : t;
            this.touchStartX = e.pageX, this.touchStartY = e.pageY
        }, W.prototype._onTouchMove = function (t) {
            var e = this.options;
            e.preventTouch && !t.target.classList.contains(e.unpreventTouchClass) && t.preventDefault();
            var n = this._event,
                i = t.targetTouches ? t.targetTouches[0] : t;
            n.deltaX = (i.pageX - this.touchStartX) * e.touchMultiplier, n.deltaY = (i.pageY - this.touchStartY) * e.touchMultiplier, this.touchStartX = i.pageX, this.touchStartY = i.pageY, this._notify(t)
        }, W.prototype._onKeyDown = function (t) {
            var e = this._event;
            e.deltaX = e.deltaY = 0;
            var n = window.innerHeight - 40;
            switch (t.keyCode) {
                case U:
                case H:
                    e.deltaY = this.options.keyStep;
                    break;
                case G:
                case V:
                    e.deltaY = -this.options.keyStep;
                    break;
                case t.shiftKey:
                    e.deltaY = n;
                    break;
                case j:
                    e.deltaY = -n;
                    break;
                default:
                    return
            }
            this._notify(t)
        }, W.prototype._bind = function () {
            D.hasWheelEvent && this.el.addEventListener("wheel", this._onWheel, this.listenerOptions), D.hasMouseWheelEvent && this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions), D.hasTouch && this.options.useTouch && (this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions), this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions)), D.hasPointer && D.hasTouchWin && (this.bodyTouchAction = document.body.style.msTouchAction, document.body.style.msTouchAction = "none", this.el.addEventListener("MSPointerDown", this._onTouchStart, !0), this.el.addEventListener("MSPointerMove", this._onTouchMove, !0)), D.hasKeyDown && this.options.useKeyboard && document.addEventListener("keydown", this._onKeyDown)
        }, W.prototype._unbind = function () {
            D.hasWheelEvent && this.el.removeEventListener("wheel", this._onWheel), D.hasMouseWheelEvent && this.el.removeEventListener("mousewheel", this._onMouseWheel), D.hasTouch && (this.el.removeEventListener("touchstart", this._onTouchStart), this.el.removeEventListener("touchmove", this._onTouchMove)), D.hasPointer && D.hasTouchWin && (document.body.style.msTouchAction = this.bodyTouchAction, this.el.removeEventListener("MSPointerDown", this._onTouchStart, !0), this.el.removeEventListener("MSPointerMove", this._onTouchMove, !0)), D.hasKeyDown && this.options.useKeyboard && document.removeEventListener("keydown", this._onKeyDown)
        }, W.prototype.on = function (t, e) {
            this._emitter.on(B, t, e);
            var n = this._emitter.e;
            n && n[B] && 1 === n[B].length && this._bind()
        }, W.prototype.off = function (t, e) {
            this._emitter.off(B, t, e);
            var n = this._emitter.e;
            (!n[B] || n[B].length <= 0) && this._unbind()
        }, W.prototype.reset = function () {
            var t = this._event;
            t.x = 0, t.y = 0
        }, W.prototype.destroy = function () {
            this._emitter.off(), this._unbind()
        };
        var J = "function" == typeof Float32Array;

        function Z(t, e) {
            return 1 - 3 * e + 3 * t
        }

        function Q(t, e) {
            return 3 * e - 6 * t
        }

        function K(t) {
            return 3 * t
        }

        function $(t, e, n) {
            return ((Z(e, n) * t + Q(e, n)) * t + K(e)) * t
        }

        function tt(t, e, n) {
            return 3 * Z(e, n) * t * t + 2 * Q(e, n) * t + K(e)
        }

        function et(t) {
            return t
        }
        var nt = function (t, e, n, i) {
                if (!(0 <= t && t <= 1 && 0 <= n && n <= 1)) throw new Error("bezier x values must be in [0, 1] range");
                if (t === e && n === i) return et;
                for (var r = J ? new Float32Array(11) : new Array(11), o = 0; o < 11; ++o) r[o] = $(.1 * o, t, n);

                function a(e) {
                    for (var i = 0, o = 1; 10 !== o && r[o] <= e; ++o) i += .1;
                    --o;
                    var a = i + .1 * ((e - r[o]) / (r[o + 1] - r[o])),
                        s = tt(a, t, n);
                    return s >= .001 ? function (t, e, n, i) {
                        for (var r = 0; r < 4; ++r) {
                            var o = tt(e, n, i);
                            if (0 === o) return e;
                            e -= ($(e, n, i) - t) / o
                        }
                        return e
                    }(e, a, t, n) : 0 === s ? a : function (t, e, n, i, r) {
                        var o, a, s = 0;
                        do {
                            (o = $(a = e + (n - e) / 2, i, r) - t) > 0 ? n = a : e = a
                        } while (Math.abs(o) > 1e-7 && ++s < 10);
                        return a
                    }(e, i, i + .1, t, n)
                }
                return function (t) {
                    return 0 === t ? 0 : 1 === t ? 1 : $(a(t), e, i)
                }
            },
            it = 38,
            rt = 40,
            ot = 32,
            at = 9,
            st = 33,
            lt = 34,
            ct = 36,
            ht = 35,
            ut = function (t) {
                l(i, t);
                var e = p(i);

                function i() {
                    var t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return n(this, i), history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0), (t = e.call(this, r)).inertia && (t.lerp = .1 * t.inertia), t.isScrolling = !1, t.isDraggingScrollbar = !1, t.isTicking = !1, t.hasScrollTicking = !1, t.parallaxElements = {}, t.stop = !1, t.scrollbarContainer = r.scrollbarContainer, t.checkKey = t.checkKey.bind(u(t)), window.addEventListener("keydown", t.checkKey, !1), t
                }
                return r(i, [{
                    key: "init",
                    value: function () {
                        var t = this;
                        this.html.classList.add(this.smoothClass), this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction), this.instance = s({
                            delta: {
                                x: 0,
                                y: 0
                            }
                        }, this.instance), this.vs = new F({
                            el: this.scrollFromAnywhere ? document : this.el,
                            mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : .4,
                            firefoxMultiplier: this.firefoxMultiplier,
                            touchMultiplier: this.touchMultiplier,
                            useKeyboard: !1,
                            passive: !0
                        }), this.vs.on((function (e) {
                            t.stop || t.isDraggingScrollbar || requestAnimationFrame((function () {
                                t.updateDelta(e), t.isScrolling || t.startScrolling()
                            }))
                        })), this.setScrollLimit(), this.initScrollBar(), this.addSections(), this.addElements(), this.checkScroll(!0), this.transformElements(!0, !0), f(c(i.prototype), "init", this).call(this)
                    }
                }, {
                    key: "setScrollLimit",
                    value: function () {
                        if (this.instance.limit.y = this.el.offsetHeight - this.windowHeight, "horizontal" === this.direction) {
                            for (var t = 0, e = this.el.children, n = 0; n < e.length; n++) t += e[n].offsetWidth;
                            this.instance.limit.x = t - this.windowWidth
                        }
                    }
                }, {
                    key: "startScrolling",
                    value: function () {
                        this.startScrollTs = Date.now(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass)
                    }
                }, {
                    key: "stopScrolling",
                    value: function () {
                        cancelAnimationFrame(this.checkScrollRaf), this.scrollToRaf && (cancelAnimationFrame(this.scrollToRaf), this.scrollToRaf = null), this.isScrolling = !1, this.instance.scroll.y = Math.round(this.instance.scroll.y), this.html.classList.remove(this.scrollingClass)
                    }
                }, {
                    key: "checkKey",
                    value: function (t) {
                        var e = this;
                        if (this.stop) t.keyCode == at && requestAnimationFrame((function () {
                            e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0
                        }));
                        else {
                            switch (t.keyCode) {
                                case at:
                                    requestAnimationFrame((function () {
                                        e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0, e.scrollTo(document.activeElement, {
                                            offset: -window.innerHeight / 2
                                        })
                                    }));
                                    break;
                                case it:
                                    this.instance.delta[this.directionAxis] -= 240;
                                    break;
                                case rt:
                                    this.instance.delta[this.directionAxis] += 240;
                                    break;
                                case st:
                                    this.instance.delta[this.directionAxis] -= window.innerHeight;
                                    break;
                                case lt:
                                    this.instance.delta[this.directionAxis] += window.innerHeight;
                                    break;
                                case ct:
                                    this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
                                    break;
                                case ht:
                                    this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
                                    break;
                                case ot:
                                    document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement || (t.shiftKey ? this.instance.delta[this.directionAxis] -= window.innerHeight : this.instance.delta[this.directionAxis] += window.innerHeight);
                                    break;
                                default:
                                    return
                            }
                            this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]), this.stopScrolling(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass)
                        }
                    }
                }, {
                    key: "checkScroll",
                    value: function () {
                        var t = this,
                            e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        if (e || this.isScrolling || this.isDraggingScrollbar) {
                            this.hasScrollTicking || (this.checkScrollRaf = requestAnimationFrame((function () {
                                return t.checkScroll()
                            })), this.hasScrollTicking = !0), this.updateScroll();
                            var n = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]),
                                r = Date.now() - this.startScrollTs;
                            if (!this.animatingScroll && r > 100 && (n < .5 && 0 != this.instance.delta[this.directionAxis] || n < .5 && 0 == this.instance.delta[this.directionAxis]) && this.stopScrolling(), Object.entries(this.sections).forEach((function (e) {
                                    var n = m(e, 2),
                                        i = (n[0], n[1]);
                                    i.persistent || t.instance.scroll[t.directionAxis] > i.offset[t.directionAxis] && t.instance.scroll[t.directionAxis] < i.limit[t.directionAxis] ? ("horizontal" === t.direction ? t.transform(i.el, -t.instance.scroll[t.directionAxis], 0) : t.transform(i.el, 0, -t.instance.scroll[t.directionAxis]), i.inView || (i.inView = !0, i.el.style.opacity = 1, i.el.style.pointerEvents = "all", i.el.setAttribute("data-".concat(t.name, "-section-inview"), ""))) : (i.inView && (i.inView = !1, i.el.style.opacity = 0, i.el.style.pointerEvents = "none", i.el.removeAttribute("data-".concat(t.name, "-section-inview"))), t.transform(i.el, 0, 0))
                                })), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.detectElements(), this.transformElements(), this.hasScrollbar) {
                                var o = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
                                "horizontal" === this.direction ? this.transform(this.scrollbarThumb, o, 0) : this.transform(this.scrollbarThumb, 0, o)
                            }
                            f(c(i.prototype), "checkScroll", this).call(this), this.hasScrollTicking = !1
                        }
                    }
                }, {
                    key: "resize",
                    value: function () {
                        this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.checkContext(), this.windowMiddle = {
                            x: this.windowWidth / 2,
                            y: this.windowHeight / 2
                        }, this.update()
                    }
                }, {
                    key: "updateDelta",
                    value: function (t) {
                        var e, n = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
                        e = "both" === n ? t.deltaX + t.deltaY : "vertical" === n ? t.deltaY : "horizontal" === n ? t.deltaX : t.deltaY, this.instance.delta[this.directionAxis] -= e * this.multiplier, this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis])
                    }
                }, {
                    key: "updateScroll",
                    value: function (t) {
                        this.isScrolling || this.isDraggingScrollbar ? this.instance.scroll[this.directionAxis] = q(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp) : this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis] ? this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]) : this.instance.scroll.y < 0 ? this.setScroll(this.instance.scroll[this.directionAxis], 0) : this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis])
                    }
                }, {
                    key: "addDirection",
                    value: function () {
                        this.instance.delta.y > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : this.instance.delta.y < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up"), this.instance.delta.x > this.instance.scroll.x ? "right" !== this.instance.direction && (this.instance.direction = "right") : this.instance.delta.x < this.instance.scroll.x && "left" !== this.instance.direction && (this.instance.direction = "left")
                    }
                }, {
                    key: "addSpeed",
                    value: function () {
                        this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis] ? this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
                    }
                }, {
                    key: "initScrollBar",
                    value: function () {
                        if (this.scrollbar = document.createElement("span"), this.scrollbarThumb = document.createElement("span"), this.scrollbar.classList.add("".concat(this.scrollbarClass)), this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb")), this.scrollbar.append(this.scrollbarThumb), this.scrollbarContainer ? this.scrollbarContainer.append(this.scrollbar) : document.body.append(this.scrollbar), this.getScrollBar = this.getScrollBar.bind(this), this.releaseScrollBar = this.releaseScrollBar.bind(this), this.moveScrollBar = this.moveScrollBar.bind(this), this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar), window.addEventListener("mouseup", this.releaseScrollBar), window.addEventListener("mousemove", this.moveScrollBar), this.hasScrollbar = !1, "horizontal" == this.direction) {
                            if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return
                        } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
                        this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {
                            x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                            y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                        }
                    }
                }, {
                    key: "reinitScrollBar",
                    value: function () {
                        if (this.hasScrollbar = !1, "horizontal" == this.direction) {
                            if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return
                        } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
                        this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {
                            x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                            y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                        }
                    }
                }, {
                    key: "destroyScrollBar",
                    value: function () {
                        this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar), window.removeEventListener("mouseup", this.releaseScrollBar), window.removeEventListener("mousemove", this.moveScrollBar), this.scrollbar.remove()
                    }
                }, {
                    key: "getScrollBar",
                    value: function (t) {
                        this.isDraggingScrollbar = !0, this.checkScroll(), this.html.classList.remove(this.scrollingClass), this.html.classList.add(this.draggingClass)
                    }
                }, {
                    key: "releaseScrollBar",
                    value: function (t) {
                        this.isDraggingScrollbar = !1, this.html.classList.add(this.scrollingClass), this.html.classList.remove(this.draggingClass)
                    }
                }, {
                    key: "moveScrollBar",
                    value: function (t) {
                        var e = this;
                        this.isDraggingScrollbar && requestAnimationFrame((function () {
                            var n = 100 * (t.clientX - e.scrollbarBCR.left) / e.scrollbarWidth * e.instance.limit.x / 100,
                                i = 100 * (t.clientY - e.scrollbarBCR.top) / e.scrollbarHeight * e.instance.limit.y / 100;
                            i > 0 && i < e.instance.limit.y && (e.instance.delta.y = i), n > 0 && n < e.instance.limit.x && (e.instance.delta.x = n)
                        }))
                    }
                }, {
                    key: "addElements",
                    value: function () {
                        var t = this;
                        this.els = {}, this.parallaxElements = {}, this.el.querySelectorAll("[data-".concat(this.name, "]")).forEach((function (e, n) {
                            var i, r, o, a = Y(e),
                                s = Object.entries(t.sections).map((function (t) {
                                    var e = m(t, 2);
                                    e[0];
                                    return e[1]
                                })).find((function (t) {
                                    return a.includes(t.el)
                                })),
                                l = e.dataset[t.name + "Class"] || t.class,
                                c = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "el" + n,
                                h = e.dataset[t.name + "Repeat"],
                                u = e.dataset[t.name + "Call"],
                                d = e.dataset[t.name + "Position"],
                                p = e.dataset[t.name + "Delay"],
                                f = e.dataset[t.name + "Direction"],
                                v = "string" == typeof e.dataset[t.name + "Sticky"],
                                g = !!e.dataset[t.name + "Speed"] && parseFloat(e.dataset[t.name + "Speed"]) / 10,
                                y = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset,
                                _ = e.dataset[t.name + "Target"],
                                x = (o = void 0 !== _ ? document.querySelector("".concat(_)) : e).getBoundingClientRect();
                            null === s || s.inView ? (i = x.top + t.instance.scroll.y - X(o).y, r = x.left + t.instance.scroll.x - X(o).x) : (i = x.top - X(s.el).y - X(o).y, r = x.left - X(s.el).x - X(o).x);
                            var b = i + o.offsetHeight,
                                w = r + o.offsetWidth,
                                M = {
                                    x: (w - r) / 2 + r,
                                    y: (b - i) / 2 + i
                                };
                            if (v) {
                                var S = e.getBoundingClientRect(),
                                    T = S.top,
                                    E = S.left,
                                    A = {
                                        x: E - r,
                                        y: T - i
                                    };
                                i += window.innerHeight, r += window.innerWidth, b = T + o.offsetHeight - e.offsetHeight - A[t.directionAxis], M = {
                                    x: ((w = E + o.offsetWidth - e.offsetWidth - A[t.directionAxis]) - r) / 2 + r,
                                    y: (b - i) / 2 + i
                                }
                            }
                            h = "false" != h && (null != h || t.repeat);
                            var C = [0, 0];
                            if (y)
                                if ("horizontal" === t.direction) {
                                    for (var L = 0; L < y.length; L++) "string" == typeof y[L] ? y[L].includes("%") ? C[L] = parseInt(y[L].replace("%", "") * t.windowWidth / 100) : C[L] = parseInt(y[L]) : C[L] = y[L];
                                    r += C[0], w -= C[1]
                                } else {
                                    for (L = 0; L < y.length; L++) "string" == typeof y[L] ? y[L].includes("%") ? C[L] = parseInt(y[L].replace("%", "") * t.windowHeight / 100) : C[L] = parseInt(y[L]) : C[L] = y[L];
                                    i += C[0], b -= C[1]
                                } var P = {
                                el: e,
                                id: c,
                                class: l,
                                section: s,
                                top: i,
                                middle: M,
                                bottom: b,
                                left: r,
                                right: w,
                                offset: y,
                                progress: 0,
                                repeat: h,
                                inView: !1,
                                call: u,
                                speed: g,
                                delay: p,
                                position: d,
                                target: o,
                                direction: f,
                                sticky: v
                            };
                            t.els[c] = P, e.classList.contains(l) && t.setInView(t.els[c], c), (!1 !== g || v) && (t.parallaxElements[c] = P)
                        }))
                    }
                }, {
                    key: "addSections",
                    value: function () {
                        var t = this;
                        this.sections = {};
                        var e = this.el.querySelectorAll("[data-".concat(this.name, "-section]"));
                        0 === e.length && (e = [this.el]), e.forEach((function (e, n) {
                            var i = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "section" + n,
                                r = e.getBoundingClientRect(),
                                o = {
                                    x: r.left - 1.5 * window.innerWidth - X(e).x,
                                    y: r.top - 1.5 * window.innerHeight - X(e).y
                                },
                                a = {
                                    x: o.x + r.width + 2 * window.innerWidth,
                                    y: o.y + r.height + 2 * window.innerHeight
                                },
                                s = "string" == typeof e.dataset[t.name + "Persistent"];
                            e.setAttribute("data-scroll-section-id", i);
                            var l = {
                                el: e,
                                offset: o,
                                limit: a,
                                inView: !1,
                                persistent: s,
                                id: i
                            };
                            t.sections[i] = l
                        }))
                    }
                }, {
                    key: "transform",
                    value: function (t, e, n, i) {
                        var r;
                        if (i) {
                            var o = X(t),
                                a = q(o.x, e, i),
                                s = q(o.y, n, i);
                            r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(a, ",").concat(s, ",0,1)")
                        } else r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(e, ",").concat(n, ",0,1)");
                        t.style.webkitTransform = r, t.style.msTransform = r, t.style.transform = r
                    }
                }, {
                    key: "transformElements",
                    value: function (t) {
                        var e = this,
                            n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            i = this.instance.scroll.x + this.windowWidth,
                            r = this.instance.scroll.y + this.windowHeight,
                            o = {
                                x: this.instance.scroll.x + this.windowMiddle.x,
                                y: this.instance.scroll.y + this.windowMiddle.y
                            };
                        Object.entries(this.parallaxElements).forEach((function (a) {
                            var s = m(a, 2),
                                l = (s[0], s[1]),
                                c = !1;
                            if (t && (c = 0), l.inView || n) switch (l.position) {
                                case "top":
                                    c = e.instance.scroll[e.directionAxis] * -l.speed;
                                    break;
                                case "elementTop":
                                    c = (r - l.top) * -l.speed;
                                    break;
                                case "bottom":
                                    c = (e.instance.limit[e.directionAxis] - r + e.windowHeight) * l.speed;
                                    break;
                                case "left":
                                    c = e.instance.scroll[e.directionAxis] * -l.speed;
                                    break;
                                case "elementLeft":
                                    c = (i - l.left) * -l.speed;
                                    break;
                                case "right":
                                    c = (e.instance.limit[e.directionAxis] - i + e.windowHeight) * l.speed;
                                    break;
                                default:
                                    c = (o[e.directionAxis] - l.middle[e.directionAxis]) * -l.speed
                            }
                            l.sticky && (c = l.inView ? "horizontal" === e.direction ? e.instance.scroll.x - l.left + window.innerWidth : e.instance.scroll.y - l.top + window.innerHeight : "horizontal" === e.direction ? e.instance.scroll.x < l.left - window.innerWidth && e.instance.scroll.x < l.left - window.innerWidth / 2 ? 0 : e.instance.scroll.x > l.right && e.instance.scroll.x > l.right + 100 && l.right - l.left + window.innerWidth : e.instance.scroll.y < l.top - window.innerHeight && e.instance.scroll.y < l.top - window.innerHeight / 2 ? 0 : e.instance.scroll.y > l.bottom && e.instance.scroll.y > l.bottom + 100 && l.bottom - l.top + window.innerHeight), !1 !== c && ("horizontal" === l.direction || "horizontal" === e.direction && "vertical" !== l.direction ? e.transform(l.el, c, 0, !t && l.delay) : e.transform(l.el, 0, c, !t && l.delay))
                        }))
                    }
                }, {
                    key: "scrollTo",
                    value: function (t) {
                        var e = this,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                            i = parseInt(n.offset) || 0,
                            r = n.duration || 1e3,
                            o = n.easing || [.25, 0, .35, 1],
                            a = !!n.disableLerp,
                            s = !!n.callback && n.callback;
                        if (o = nt.apply(void 0, v(o)), "string" == typeof t) {
                            if ("top" === t) t = 0;
                            else if ("bottom" === t) t = this.instance.limit.y;
                            else if ("left" === t) t = 0;
                            else if ("right" === t) t = this.instance.limit.x;
                            else if (!(t = document.querySelector(t))) return
                        } else if ("number" == typeof t) t = parseInt(t);
                        else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid");
                        if ("number" != typeof t) {
                            var l = Y(t).includes(this.el);
                            if (!l) return;
                            var c = t.getBoundingClientRect(),
                                h = c.top,
                                u = c.left,
                                d = Y(t),
                                p = d.find((function (t) {
                                    return Object.entries(e.sections).map((function (t) {
                                        var e = m(t, 2);
                                        e[0];
                                        return e[1]
                                    })).find((function (e) {
                                        return e.el == t
                                    }))
                                })),
                                f = 0;
                            f = p ? X(p)[this.directionAxis] : -this.instance.scroll[this.directionAxis], i = "horizontal" === this.direction ? u + i - f : h + i - f
                        } else i = t + i;
                        var g = parseFloat(this.instance.delta[this.directionAxis]),
                            y = Math.max(0, Math.min(i, this.instance.limit[this.directionAxis])),
                            _ = y - g,
                            x = function (t) {
                                a ? "horizontal" === e.direction ? e.setScroll(g + _ * t, e.instance.delta.y) : e.setScroll(e.instance.delta.x, g + _ * t) : e.instance.delta[e.directionAxis] = g + _ * t
                            };
                        this.animatingScroll = !0, this.stopScrolling(), this.startScrolling();
                        var b = Date.now(),
                            w = function t() {
                                var n = (Date.now() - b) / r;
                                n > 1 ? (x(1), e.animatingScroll = !1, 0 == r && e.update(), s && s()) : (e.scrollToRaf = requestAnimationFrame(t), x(o(n)))
                            };
                        w()
                    }
                }, {
                    key: "update",
                    value: function () {
                        this.setScrollLimit(), this.addSections(), this.addElements(), this.detectElements(), this.updateScroll(), this.transformElements(!0), this.reinitScrollBar(), this.checkScroll(!0)
                    }
                }, {
                    key: "startScroll",
                    value: function () {
                        this.stop = !1
                    }
                }, {
                    key: "stopScroll",
                    value: function () {
                        this.stop = !0
                    }
                }, {
                    key: "setScroll",
                    value: function (t, e) {
                        this.instance = s(s({}, this.instance), {}, {
                            scroll: {
                                x: t,
                                y: e
                            },
                            delta: {
                                x: t,
                                y: e
                            },
                            speed: 0
                        })
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        f(c(i.prototype), "destroy", this).call(this), this.stopScrolling(), this.html.classList.remove(this.smoothClass), this.vs.destroy(), this.destroyScrollBar(), window.removeEventListener("keydown", this.checkKey, !1)
                    }
                }]), i
            }(x),
            dt = function () {
                function t() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    n(this, t), this.options = e, Object.assign(this, _, e), this.smartphone = _.smartphone, e.smartphone && Object.assign(this.smartphone, e.smartphone), this.tablet = _.tablet, e.tablet && Object.assign(this.tablet, e.tablet), this.smooth || "horizontal" != this.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible"), this.tablet.smooth || "horizontal" != this.tablet.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (tablet)"), this.smartphone.smooth || "horizontal" != this.smartphone.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (smartphone)"), this.init()
                }
                return r(t, [{
                    key: "init",
                    value: function () {
                        if (this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint, this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint, this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet ? this.scroll = new ut(this.options) : this.scroll = new S(this.options), this.scroll.init(), window.location.hash) {
                            var t = window.location.hash.slice(1, window.location.hash.length),
                                e = document.getElementById(t);
                            e && this.scroll.scrollTo(e)
                        }
                    }
                }, {
                    key: "update",
                    value: function () {
                        this.scroll.update()
                    }
                }, {
                    key: "start",
                    value: function () {
                        this.scroll.startScroll()
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this.scroll.stopScroll()
                    }
                }, {
                    key: "scrollTo",
                    value: function (t, e) {
                        this.scroll.scrollTo(t, e)
                    }
                }, {
                    key: "setScroll",
                    value: function (t, e) {
                        this.scroll.setScroll(t, e)
                    }
                }, {
                    key: "on",
                    value: function (t, e) {
                        this.scroll.setEvents(t, e)
                    }
                }, {
                    key: "off",
                    value: function (t, e) {
                        this.scroll.unsetEvents(t, e)
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        this.scroll.destroy()
                    }
                }]), t
            }();
        e.a = dt
    }).call(this, n(8))
}, function (t, e) {
    t.exports = "uniform vec4 resolution;\r\nuniform vec3 colorShadeA;\r\nuniform vec3 colorShadeB;\r\nuniform vec3 colorShadeC;\r\nuniform vec3 colorShadeD;\r\nuniform float time;\r\n// uniform sampler2D texture1;\r\nvarying vec2 vUv;\r\n\r\nconst int octaves = 1;\r\n\r\n//randomizza il seed per avere un risultato sempre diverso\r\nconst float seed2 = 53156.8473192;\r\nconst float seed = 23758.5453123;\r\n\r\n//random luce\r\nvec2 random2(vec2 st, float seed){\r\n    st = vec2( dot(st,vec2(127.1,311.7)),\r\n              dot(st,vec2(269.5,183.3)) );\r\n    return -1.0 + 2.0*fract(sin(st)*seed);\r\n}\r\n\r\n//creazione noise\r\nfloat noise(vec2 st, float seed) {\r\n    vec2 i = floor(st);\r\n    vec2 f = fract(st);\r\n\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\r\n    return mix( mix( dot( random2(i + vec2(0.0,0.0), seed ), f - vec2(0.0,0.0) ),\r\n                 dot( random2(i + vec2(1.0,0.0), seed ), f - vec2(1.0,0.0) ), u.x),\r\n                 mix( dot( random2(i + vec2(0.0,1.0), seed ), f - vec2(0.0,1.0) ),\r\n                 dot( random2(i + vec2(1.0,1.0), seed ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\nfloat fbm1(in vec2 _st, float seed) {\r\n    float v = 0.0;\r\n    float a = 0.5;\r\n    vec2 shift = vec2(100.0);\r\n    // Rotate to reduce axial bias\r\n    mat2 rot = mat2(cos(0.5), sin(0.5),\r\n                  -sin(0.5), cos(0.50));\r\n    for (int i = 0; i < octaves; ++i) {\r\n      v += a * noise(_st, seed);\r\n      _st = rot * _st * 2.0 + shift;\r\n      a *= 0.4;\r\n    }\r\n    return v + .4;\r\n}\r\n\r\nfloat pattern(vec2 uv, float seed, float t, inout vec2 q, inout vec2 r) {\r\n\r\n    q = vec2( fbm1( uv + vec2(0.0,0.0), seed ),\r\n                 fbm1( uv + vec2(5.2,1.3), seed ) );\r\n\r\n    r = vec2( fbm1( uv + 4.0*q + vec2(1.7 - t / 2.,9.2), seed ),\r\n                 fbm1( uv + 4.0*q + vec2(8.3 - t / 2.,2.8), seed ) );\r\n\r\n    float rtn = fbm1( uv + 4.0*r, seed );\r\n\r\n    return rtn;\r\n}\r\n\r\nfloat bumpMap(vec2 uv, inout vec2 q, inout vec2 r) {\r\n    mat2 rotation = mat2(\r\n        cos(time / 50.), -sin(time / 50.),\r\n        sin(time / 50.), cos(time / 50.)\r\n    );\r\n    uv -= .5;\r\n    uv *= rotation;\r\n    uv *= 5.;\r\n\r\n    float colour = pattern(uv, seed, time / 3., q, r);\r\n    colour = smoothstep(0., 1., colour);\r\n\r\n    return length(vec2(colour))*.8;\r\n}\r\n\r\nvec4 renderPass(vec2 uv, vec2 uvoffset) {\r\n    vec3 surfacePos = vec3(uv, 0);\r\n    vec3 ray = normalize(vec3(uv, 1.));\r\n    vec3 lightPos = vec3(0., 0., -3.);\r\n    vec3 normal = vec3(0., 0., -1);\r\n\r\n    vec2 sampleDistance = vec2(1. / resolution.y, 0.);\r\n\r\n    vec2 q = vec2(0.,0.);\r\n    vec2 r = vec2(0.,0.);\r\n\r\n    float fx = bumpMap(surfacePos.xy-sampleDistance.xy + uvoffset, q, r);\r\n    float fy = bumpMap(surfacePos.xy-sampleDistance.yx + uvoffset, q, r);\r\n    float f = bumpMap(surfacePos.xy + uvoffset, q, r);\r\n    fx = (fx-f)/sampleDistance.x;\r\n    fy = (fy-f)/sampleDistance.x;\r\n    normal = normalize( normal + vec3(fx, fy, 0) * 0.2 );\r\n\r\n    vec3 lightV = lightPos - surfacePos;\r\n    float lightDist = max(length(lightV), 0.001);\r\n    lightV /= lightDist;\r\n\r\n    //test colore gradient\r\n    //gradient 1\r\n    // vec3 a = vec3(0.5, 0.5, 0.5);\r\n    // vec3 b = vec3(0.5, 1.0, 0.5);\r\n    // vec3 c = vec3(2.0, 1.0, 0.0);\r\n    // vec3 d = vec3(0.50, 0.20, 0.25);\r\n\r\n    //gradient 2 azzurro, arancione e mattone\r\n    vec3 a = vec3(0.5, 0.5, 0.5);\r\n    vec3 b = vec3(0.5, 0.5, 0.5);\r\n    vec3 c = vec3(1.0, 1.0, 1.0);\r\n    vec3 d = vec3(0.00, 0.10, 0.20);\r\n\r\n    //gradient 3 viola new\r\n    // vec3 a = vec3(0.65, 0.55, 0.71);\r\n    // vec3 b = vec3(0.54, 0.72, 0.38);\r\n    // vec3 c = vec3(0.39, 0.85, 0.93);\r\n    // vec3 d = vec3(0.14, 0.16, 0.18);\r\n\r\n\r\n\r\n    //gradient 4 bello -- MAIN --\r\n    // vec3 a = vec3(0.4, 0.34, 0.91);\r\n    // vec3 b = vec3(0.49, 0.96, 0.13);\r\n    // vec3 c = vec3(0.55, 0.83, 0.21);\r\n    // vec3 d = vec3(0.45, 0.96, 0.48);\r\n\r\n    //gradient 5 bello\r\n    // vec3 a = vec3(0.38, 0.34, 0.62);\r\n    // vec3 b = vec3(0.71, 0.88, 0.14);\r\n    // vec3 c = vec3(0.61, 0.95, 0.33);\r\n    // vec3 d = vec3(0.45, 0.96, 0.12);\r\n\r\n    // vec3 animatedColor = a + b * cos( 2. * 3.1415926 * (c*f+d));\r\n    vec3 clr = vec3(0.0);\r\n\r\n    vec3 animatedColor = colorShadeA + colorShadeB * cos( 2. * 3.1415926 * (colorShadeC*f+colorShadeD));\r\n\r\n    vec3 animatedColor2 = a + b * cos( 2. * 3.1415926 * (c*f+d));\r\n\r\n    float pct = abs(sin(time/3.));\r\n    // Mix uses pct (a value from 0-1) to\r\n    // mix the two colors\r\n    clr = mix(animatedColor, animatedColor2, pct);\r\n\r\n    // vec3 lightColour = clr;\r\n    vec3 lightColour = animatedColor2;\r\n\r\n    // vec3 lightColour = vec3(r.r * f * 3., r.g * f * 3., r.g * f * 3.);\r\n    // vec3 lightColour = vec3(r.r * f * 1., r.g * f * 4., r.g * f * 3.);\r\n\r\n    // float falloff = 0.05;\r\n    float falloff = 0.;\r\n    float attenuation = 1./(1.0 + lightDist*lightDist*falloff);\r\n\r\n    float diffuse = max(dot(normal, lightV), 0.);\r\n    //was 22\r\n    float specular = pow(max(dot( reflect(-lightV, normal), -ray), 0.), 16.);\r\n\r\n    specular = specular/5.;\r\n\r\n    vec3 texCol = vec3(1.15, .15 + r.g * f * 2., q.r * f * 1.5);\r\n    // vec3 texCol = vec3(0.15, .15 + r.g * f * 2., q.r * f * 1.5);\r\n    // texCol = smoothstep(0.05, .75, pow(texCol*texCol, vec3(.55, .99, .85)));\r\n\r\n    //se metto -.75 diventa privo di colore solo con i riflessi\r\n    texCol = smoothstep(0.05, 0., pow(texCol*texCol, vec3(.85, .89, .25)));\r\n\r\n\r\n    // texCol = vec3(f * .5, f * .15, f * .2);\r\n\r\n    vec3 colour = (texCol * (diffuse*vec3(1, .97, .52)*1. + 0.2) + lightColour*specular * f * 20.)*attenuation;\r\n    // vec3 colour = (texCol * (diffuse*vec3(1, .97, .92)*2. + 0.5) + lightColour*specular * f * 2.)*attenuation;\r\n\r\n    return vec4(sqrt(colour), 1.);\r\n}\r\n\r\nvoid main() {\r\n    vec2 fragCoord = gl_FragCoord.xy / 2.;\r\n    // Screen coordinates.\r\n    vec2 vUv = (fragCoord - resolution.xy*.5)/resolution.y;\r\n    // vec2 vUV = (fragCoord - vec2(0.5))*resolution.zw + vec2(0.5);\r\n\r\n    vec4 render = renderPass(vUv, vec2(1.));\r\n\r\n    // vec4 final = texture2D(texture1, vUv);\r\n    // gl_FragColor = final;\r\n    // gl_FragColor = vec4(1.,1.,0.,1.);\r\n    gl_FragColor = render;\r\n}\r\n"
}, function (t, e) {
    t.exports = "uniform vec2 resolution;\r\nuniform float time;\r\nuniform sampler2D txHome;\r\n\r\nuniform vec3 clrShA;\r\nuniform vec3 clrShB;\r\nuniform vec3 clrShC;\r\nuniform vec3 clrShD;\r\nuniform float veerClr;\r\n\r\n// uniform float progress;\r\n//dichiaro 3 variabili\r\n// 1) Fade, per l'immagine che diventa fluido\r\nuniform float fading;\r\n// 2) DispChange, per il transparent liquid\r\nuniform float waterChange;\r\n// 3) ImgChange, per il cambio da immagine 1 a 2\r\nuniform float imgChange;\r\n//texture main after change\r\nuniform sampler2D txMain;\r\n\r\nvarying vec2 vUv;\r\n// varying vec3 vPosition;\r\n\r\nconst int octaves = 1;\r\n\r\n//randomizza il seed per avere un risultato sempre diverso\r\nconst float seed2 = 53156.8473192;\r\nconst float seed = 23758.5453123;\r\n\r\n//random luce\r\nvec2 random2(vec2 st, float seed){\r\n    st = vec2( dot(st,vec2(127.1,311.7)),\r\n              dot(st,vec2(269.5,183.3)) );\r\n    return -1.0 + 2.0*fract(sin(st)*seed);\r\n}\r\n\r\n//creazione noise\r\nfloat noise(vec2 st, float seed) {\r\n    vec2 i = floor(st);\r\n    vec2 f = fract(st);\r\n\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\r\n    return mix( mix( dot( random2(i + vec2(0.0,0.0), seed ), f - vec2(0.0,0.0) ),\r\n                 dot( random2(i + vec2(1.0,0.0), seed ), f - vec2(1.0,0.0) ), u.x),\r\n                 mix( dot( random2(i + vec2(0.0,1.0), seed ), f - vec2(0.0,1.0) ),\r\n                 dot( random2(i + vec2(1.0,1.0), seed ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\nfloat fbm1(in vec2 _st, float seed) {\r\n    float v = 0.0;\r\n    float a = 0.5;\r\n    vec2 shift = vec2(100.0);\r\n    // Rotate to reduce axial bias\r\n    mat2 rot = mat2(cos(0.5), sin(0.5),\r\n                  -sin(0.5), cos(0.50));\r\n    for (int i = 0; i < octaves; ++i) {\r\n      v += a * noise(_st, seed);\r\n      _st = rot * _st * 2.0 + shift;\r\n      a *= 0.4;\r\n    }\r\n    return v + .4;\r\n}\r\n\r\nfloat pattern(vec2 uv, float seed, float t, inout vec2 q, inout vec2 r) {\r\n\r\n    q = vec2( fbm1( uv + vec2(0.0,0.0), seed ),\r\n                 fbm1( uv + vec2(5.2,1.3), seed ) );\r\n\r\n    r = vec2( fbm1( uv + 4.0*q + vec2(1.7 - t / 2.,9.2), seed ),\r\n                 fbm1( uv + 4.0*q + vec2(8.3 - t / 2.,2.8), seed ) );\r\n\r\n    float rtn = fbm1( uv + 4.0*r, seed );\r\n\r\n    return rtn;\r\n}\r\n\r\nfloat bumpMap(vec2 uv, inout vec2 q, inout vec2 r) {\r\n    mat2 rotation = mat2(\r\n        cos(time / 50.), -sin(time / 50.),\r\n        sin(time / 50.), cos(time / 50.)\r\n    );\r\n    uv -= .5;\r\n    uv *= rotation;\r\n    uv *= 5.;\r\n\r\n    float colour = pattern(uv, seed, time / 3., q, r);\r\n    colour = smoothstep(0., 1., colour);\r\n\r\n    return length(vec2(colour))*.8;\r\n}\r\n\r\nvec4 renderPass(vec2 uv, vec2 uvoffset) {\r\n    vec3 surfacePos = vec3(uv, 0);\r\n    vec3 ray = normalize(vec3(uv, 1.));\r\n    vec3 lightPos = vec3(0., 0., -3.);\r\n    vec3 normal = vec3(0., 0., -1);\r\n\r\n    vec2 sampleDistance = vec2(1. / resolution.y, 0.);\r\n\r\n    vec2 q = vec2(0.,0.);\r\n    vec2 r = vec2(0.,0.);\r\n\r\n    float fx = bumpMap(surfacePos.xy-sampleDistance.xy + uvoffset, q, r);\r\n    float fy = bumpMap(surfacePos.xy-sampleDistance.yx + uvoffset, q, r);\r\n    float f = bumpMap(surfacePos.xy + uvoffset, q, r);\r\n    fx = (fx-f)/sampleDistance.x;\r\n    fy = (fy-f)/sampleDistance.x;\r\n    normal = normalize( normal + vec3(fx, fy, 0) * 0.2 );\r\n\r\n    vec3 lightV = lightPos - surfacePos;\r\n    float lightDist = max(length(lightV), 0.001);\r\n    lightV /= lightDist;\r\n\r\n    //test colore gradient\r\n    //gradient 1\r\n    // vec3 a = vec3(0.5, 0.5, 0.5);\r\n    // vec3 b = vec3(0.5, 1.0, 0.5);\r\n    // vec3 c = vec3(2.0, 1.0, 0.0);\r\n    // vec3 d = vec3(0.50, 0.20, 0.25);\r\n\r\n    //gradient 2 azzurro, arancione e mattone\r\n    vec3 a = vec3(0.5, 0.5, 0.5);\r\n    vec3 b = vec3(0.5, 0.5, 0.5);\r\n    vec3 c = vec3(1.0, 1.0, 1.0);\r\n    vec3 d = vec3(0.00, 0.10, 0.20);\r\n\r\n    //gradient 3 viola new\r\n    // vec3 a = vec3(0.65, 0.55, 0.71);\r\n    // vec3 b = vec3(0.54, 0.72, 0.38);\r\n    // vec3 c = vec3(0.39, 0.85, 0.93);\r\n    // vec3 d = vec3(0.14, 0.16, 0.18);\r\n\r\n\r\n    //gradient 4 bello -- MAIN --\r\n    // vec3 a = vec3(0.4, 0.34, 0.91);\r\n    // vec3 b = vec3(0.49, 0.96, 0.13);\r\n    // vec3 c = vec3(0.55, 0.83, 0.21);\r\n    // vec3 d = vec3(0.45, 0.96, 0.48);\r\n\r\n    //gradient 5 bello\r\n    // vec3 a = vec3(0.38, 0.34, 0.62);\r\n    // vec3 b = vec3(0.71, 0.88, 0.14);\r\n    // vec3 c = vec3(0.61, 0.95, 0.33);\r\n    // vec3 d = vec3(0.45, 0.96, 0.12);\r\n\r\n    vec3 animatedColor = a + b * cos( 2. * 3.1415926 * (c*f+d));\r\n    vec3 modifiedColor = clrShA + clrShB * cos( 2. * 3.1415926 * (clrShC * f + clrShD));\r\n\r\n    vec3 finalColor = mix(animatedColor, modifiedColor, veerClr);\r\n\r\n    vec3 lightColour = finalColor;\r\n\r\n    // vec3 lightColour = vec3(r.r * f * 3., r.g * f * 3., r.g * f * 3.);\r\n    // vec3 lightColour = vec3(r.r * f * 1., r.g * f * 4., r.g * f * 3.);\r\n\r\n    // float falloff = 0.05;\r\n    float falloff = 0.;\r\n    float attenuation = 1./(1.0 + lightDist*lightDist*falloff);\r\n\r\n    float diffuse = max(dot(normal, lightV), 0.);\r\n    //was 22\r\n    float specular = pow(max(dot( reflect(-lightV, normal), -ray), 0.), 16.);\r\n\r\n    specular = specular/5.;\r\n\r\n    vec3 texCol = vec3(1.15, .15 + r.g * f * 2., q.r * f * 1.5);\r\n    // vec3 texCol = vec3(0.15, .15 + r.g * f * 2., q.r * f * 1.5);\r\n    // texCol = smoothstep(0.05, .75, pow(texCol*texCol, vec3(.55, .99, .85)));\r\n\r\n    //se metto -.75 diventa privo di colore solo con i riflessi\r\n    texCol = smoothstep(0.05, 0., pow(texCol*texCol, vec3(.85, .89, .25)));\r\n\r\n\r\n    // texCol = vec3(f * .5, f * .15, f * .2);\r\n\r\n    vec3 colour = (texCol * (diffuse*vec3(1, .97, .52)*1. + 0.2) + lightColour*specular * f * 20.)*attenuation;\r\n    // vec3 colour = (texCol * (diffuse*vec3(1, .97, .92)*2. + 0.5) + lightColour*specular * f * 2.)*attenuation;\r\n\r\n    return vec4(sqrt(colour), 1.);\r\n}\r\n\r\n//mapping per il clamp\r\nfloat map(float value, float min1, float max1, float min2, float max2) {\r\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\r\n\r\nfloat circle(vec2 uv, vec2 disc_center, float disc_radius, float border_size) {\r\n  uv -= disc_center;\r\n  uv*=resolution;\r\n  float dist = sqrt(dot(uv, uv));\r\n  return smoothstep(disc_radius+border_size, disc_radius-border_size, dist);\r\n}\r\n\r\nvoid main() {\r\n    //set an old vUv for the images and after that set a new one for the full screen liquid\r\n    vec2 newUV = vUv;\r\n    vec2 fragCoord = gl_FragCoord.xy / 2.;\r\n    // Screen coordinates.\r\n    vec2 vUv = (fragCoord - resolution.xy*.5)/resolution.y;\r\n\r\n    vec4 bump = renderPass(vUv, vec2(0.5));\r\n\r\n    //fading per change da img a fluido\r\n    float noix = -0.3 * bump.z + fading;\r\n    //not moving on mouse over Water effect\r\n    float waterNoix = -0.3 * bump.z;\r\n    float water = smoothstep(0.09,(-.01 * waterChange), waterNoix);\r\n    float step2 = smoothstep(.4,.029, noix);\r\n\r\n    vec2 displaceUV = vec2(newUV.x,newUV.y);\r\n    //test per un bump con delle coordinate diverse\r\n    vec4 bumpDispl = renderPass(vUv, vec2(0.5));\r\n\r\n    displaceUV = mix(bumpDispl.xy, newUV.xy, water);\r\n\r\n    vec4 homeImg = texture2D(txHome, displaceUV);\r\n    vec4 mainImg = texture2D(txMain, displaceUV);\r\n    vec4 changeBetweenImgs = mix(homeImg, mainImg, imgChange);\r\n\r\n    vec4 final = mix(bump, changeBetweenImgs, step2);\r\n\r\n    gl_FragColor = final;\r\n    // gl_FragColor = vec4(water,water,water,1.);\r\n    // gl_FragColor = vec4(newUV.x,newUV.y,0.,1.);\r\n    // gl_FragColor.a = step;\r\n}\r\n"
}, function (t, e) {
    t.exports = "uniform vec2 resolution;\r\nuniform float time;\r\n\r\nuniform vec3 clrShA;\r\nuniform vec3 clrShB;\r\nuniform vec3 clrShC;\r\nuniform vec3 clrShD;\r\nuniform float veerClr;\r\n\r\n// 1) Fade, per il wht che diventa fluido\r\nuniform float fading;\r\n// 4) ImgChange, per il cambio da wht a img\r\nuniform float imgChange;\r\n//texture main after change\r\nuniform sampler2D txMain;\r\n\r\nvarying vec2 vUv;\r\n\r\n// varying vec3 vPosition;\r\n\r\nconst int octaves = 1;\r\n\r\n//randomizza il seed per avere un risultato sempre diverso\r\nconst float seed2 = 53156.8473192;\r\nconst float seed = 23758.5453123;\r\n\r\n//random luce\r\nvec2 random2(vec2 st, float seed){\r\n    st = vec2( dot(st,vec2(127.1,311.7)),\r\n              dot(st,vec2(269.5,183.3)) );\r\n    return -1.0 + 2.0*fract(sin(st)*seed);\r\n}\r\n\r\n//creazione noise\r\nfloat noise(vec2 st, float seed) {\r\n    vec2 i = floor(st);\r\n    vec2 f = fract(st);\r\n\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\r\n    return mix( mix( dot( random2(i + vec2(0.0,0.0), seed ), f - vec2(0.0,0.0) ),\r\n                 dot( random2(i + vec2(1.0,0.0), seed ), f - vec2(1.0,0.0) ), u.x),\r\n                 mix( dot( random2(i + vec2(0.0,1.0), seed ), f - vec2(0.0,1.0) ),\r\n                 dot( random2(i + vec2(1.0,1.0), seed ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\nfloat fbm1(in vec2 _st, float seed) {\r\n    float v = 0.0;\r\n    float a = 0.5;\r\n    vec2 shift = vec2(100.0);\r\n    // Rotate to reduce axial bias\r\n    mat2 rot = mat2(cos(0.5), sin(0.5),\r\n                  -sin(0.5), cos(0.50));\r\n    for (int i = 0; i < octaves; ++i) {\r\n      v += a * noise(_st, seed);\r\n      _st = rot * _st * 2.0 + shift;\r\n      a *= 0.4;\r\n    }\r\n    return v + .4;\r\n}\r\n\r\nfloat pattern(vec2 uv, float seed, float t, inout vec2 q, inout vec2 r) {\r\n\r\n    q = vec2( fbm1( uv + vec2(0.0,0.0), seed ),\r\n                 fbm1( uv + vec2(5.2,1.3), seed ) );\r\n\r\n    r = vec2( fbm1( uv + 4.0*q + vec2(1.7 - t / 2.,9.2), seed ),\r\n                 fbm1( uv + 4.0*q + vec2(8.3 - t / 2.,2.8), seed ) );\r\n\r\n    float rtn = fbm1( uv + 4.0*r, seed );\r\n\r\n    return rtn;\r\n}\r\n\r\nfloat bumpMap(vec2 uv, inout vec2 q, inout vec2 r) {\r\n    mat2 rotation = mat2(\r\n        cos(time / 50.), -sin(time / 50.),\r\n        sin(time / 50.), cos(time / 50.)\r\n    );\r\n    uv -= .5;\r\n    uv *= rotation;\r\n    uv *= 5.;\r\n\r\n    float colour = pattern(uv, seed, time / 3., q, r);\r\n    colour = smoothstep(0., 1., colour);\r\n\r\n    return length(vec2(colour))*.8;\r\n}\r\n\r\nvec4 renderPass(vec2 uv, vec2 uvoffset) {\r\n    vec3 surfacePos = vec3(uv, 0);\r\n    vec3 ray = normalize(vec3(uv, 1.));\r\n    vec3 lightPos = vec3(0., 0., -3.);\r\n    vec3 normal = vec3(0., 0., -1);\r\n\r\n    vec2 sampleDistance = vec2(1. / resolution.y, 0.);\r\n\r\n    vec2 q = vec2(0.,0.);\r\n    vec2 r = vec2(0.,0.);\r\n\r\n    float fx = bumpMap(surfacePos.xy-sampleDistance.xy + uvoffset, q, r);\r\n    float fy = bumpMap(surfacePos.xy-sampleDistance.yx + uvoffset, q, r);\r\n    float f = bumpMap(surfacePos.xy + uvoffset, q, r);\r\n    fx = (fx-f)/sampleDistance.x;\r\n    fy = (fy-f)/sampleDistance.x;\r\n    normal = normalize( normal + vec3(fx, fy, 0) * 0.2 );\r\n\r\n    vec3 lightV = lightPos - surfacePos;\r\n    float lightDist = max(length(lightV), 0.001);\r\n    lightV /= lightDist;\r\n\r\n    //test colore gradient\r\n    //gradient 1\r\n    // vec3 a = vec3(0.5, 0.5, 0.5);\r\n    // vec3 b = vec3(0.5, 1.0, 0.5);\r\n    // vec3 c = vec3(2.0, 1.0, 0.0);\r\n    // vec3 d = vec3(0.50, 0.20, 0.25);\r\n\r\n    //gradient 2 azzurro, arancione e mattone\r\n    vec3 a = vec3(0.5, 0.5, 0.5);\r\n    vec3 b = vec3(0.5, 0.5, 0.5);\r\n    vec3 c = vec3(1.0, 1.0, 1.0);\r\n    vec3 d = vec3(0.00, 0.10, 0.20);\r\n\r\n    //gradient 3 viola new\r\n    // vec3 a = vec3(0.65, 0.55, 0.71);\r\n    // vec3 b = vec3(0.54, 0.72, 0.38);\r\n    // vec3 c = vec3(0.39, 0.85, 0.93);\r\n    // vec3 d = vec3(0.14, 0.16, 0.18);\r\n\r\n\r\n    //gradient 4 bello -- MAIN --\r\n    // vec3 a = vec3(0.4, 0.34, 0.91);\r\n    // vec3 b = vec3(0.49, 0.96, 0.13);\r\n    // vec3 c = vec3(0.55, 0.83, 0.21);\r\n    // vec3 d = vec3(0.45, 0.96, 0.48);\r\n\r\n    //gradient 5 bello\r\n    // vec3 a = vec3(0.38, 0.34, 0.62);\r\n    // vec3 b = vec3(0.71, 0.88, 0.14);\r\n    // vec3 c = vec3(0.61, 0.95, 0.33);\r\n    // vec3 d = vec3(0.45, 0.96, 0.12);\r\n\r\n    vec3 animatedColor = a + b * cos( 2. * 3.1415926 * (c*f+d));\r\n    vec3 modifiedColor = clrShA + clrShB * cos( 2. * 3.1415926 * (clrShC * f + clrShD));\r\n\r\n    vec3 finalColor = mix(animatedColor, modifiedColor, veerClr);\r\n\r\n    vec3 lightColour = finalColor;\r\n\r\n    // vec3 lightColour = vec3(r.r * f * 3., r.g * f * 3., r.g * f * 3.);\r\n    // vec3 lightColour = vec3(r.r * f * 1., r.g * f * 4., r.g * f * 3.);\r\n\r\n    // float falloff = 0.05;\r\n    float falloff = 0.;\r\n    float attenuation = 1./(1.0 + lightDist*lightDist*falloff);\r\n\r\n    float diffuse = max(dot(normal, lightV), 0.);\r\n    //was 22\r\n    float specular = pow(max(dot( reflect(-lightV, normal), -ray), 0.), 16.);\r\n\r\n    specular = specular/5.;\r\n\r\n    vec3 texCol = vec3(1.15, .15 + r.g * f * 2., q.r * f * 1.5);\r\n    // vec3 texCol = vec3(0.15, .15 + r.g * f * 2., q.r * f * 1.5);\r\n    // texCol = smoothstep(0.05, .75, pow(texCol*texCol, vec3(.55, .99, .85)));\r\n\r\n    //se metto -.75 diventa privo di colore solo con i riflessi\r\n    texCol = smoothstep(0.05, 0., pow(texCol*texCol, vec3(.85, .89, .25)));\r\n\r\n\r\n    // texCol = vec3(f * .5, f * .15, f * .2);\r\n\r\n    vec3 colour = (texCol * (diffuse*vec3(1, .97, .52)*1. + 0.2) + lightColour*specular * f * 20.)*attenuation;\r\n    // vec3 colour = (texCol * (diffuse*vec3(1, .97, .92)*2. + 0.5) + lightColour*specular * f * 2.)*attenuation;\r\n\r\n    return vec4(sqrt(colour), 1.);\r\n}\r\n\r\n//mapping per il clamp\r\nfloat map(float value, float min1, float max1, float min2, float max2) {\r\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\r\n\r\nfloat circle(vec2 uv, vec2 disc_center, float disc_radius, float border_size) {\r\n  uv -= disc_center;\r\n  uv*=resolution;\r\n  float dist = sqrt(dot(uv, uv));\r\n  return smoothstep(disc_radius+border_size, disc_radius-border_size, dist);\r\n}\r\n\r\nvoid main() {\r\n    //set an old vUv for the images and after that set a new one for the full screen liquid\r\n    vec2 newUV = vUv;\r\n    vec2 fragCoord = gl_FragCoord.xy / 2.;\r\n    // Screen coordinates.\r\n    vec2 vUv = (fragCoord - resolution.xy*.5)/resolution.y;\r\n\r\n    vec4 bump = renderPass(vUv, vec2(0.5));\r\n\r\n    vec4 whtBg = vec4(1.,1.,1.,1.);\r\n    vec4 mainImg = texture2D(txMain, newUV);\r\n    vec4 changeBetweenImgs = mix(whtBg, mainImg, imgChange);\r\n\r\n    vec4 final = mix(changeBetweenImgs, bump, fading);\r\n\r\n    gl_FragColor = final;\r\n}\r\n"
}, function (t, e) {
    t.exports = "uniform float time;\r\nuniform vec4 resolution;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\n\r\nuniform vec2 pixels;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n\r\n    vPosition = position;\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n"
}, function (t, e) {
    t.exports = "uniform float time;\r\nuniform vec2 resolution;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\n\r\nuniform vec2 pixels;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n\r\n    vPosition = position;\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n"
}, function (t, e) {
    t.exports = "uniform float time;\r\nuniform vec2 resolution;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\n\r\nuniform vec2 pixels;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n\r\n    vPosition = position;\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n"
}, function (t, e) {
    var n;
    n = function () {
        return this
    }();
    try {
        n = n || new Function("return this")()
    } catch (t) {
        "object" == typeof window && (n = window)
    }
    t.exports = n
}, function (t, e, n) {
    "use strict";
    n.r(e);
    n(10);
    var i = n(0),
        r = n.n(i);

    function o() {}
    o.prototype = {
        on: function (t, e, n) {
            var i = this.e || (this.e = {});
            return (i[t] || (i[t] = [])).push({
                fn: e,
                ctx: n
            }), this
        },
        once: function (t, e, n) {
            var i = this;

            function r() {
                i.off(t, r), e.apply(n, arguments)
            }
            return r._ = e, this.on(t, r, n)
        },
        emit: function (t) {
            for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++) n[i].fn.apply(n[i].ctx, e);
            return this
        },
        off: function (t, e) {
            var n = this.e || (this.e = {}),
                i = n[t],
                r = [];
            if (i && e)
                for (var o = 0, a = i.length; o < a; o++) i[o].fn !== e && i[o].fn._ !== e && r.push(i[o]);
            return r.length ? n[t] = r : delete n[t], this
        }
    };
    var a = o;
    a.TinyEmitter = o;
    var s = function (t) {
        this.wrap = document.querySelector("[data-router-wrapper]"), this.properties = t, this.Transition = t.transition ? new t.transition.class(this.wrap, t.transition.name) : null
    };
    s.prototype.setup = function () {
        this.onEnter && this.onEnter(), this.onEnterCompleted && this.onEnterCompleted()
    }, s.prototype.add = function () {
        this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML)
    }, s.prototype.update = function () {
        document.title = this.properties.page.title
    }, s.prototype.show = function (t) {
        var e = this;
        return new Promise((function (n) {
            try {
                function i(t) {
                    e.onEnterCompleted && e.onEnterCompleted(), n()
                }
                return e.update(), e.onEnter && e.onEnter(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.show(t)).then(i) : i())
            } catch (t) {
                return Promise.reject(t)
            }
        }))
    }, s.prototype.hide = function (t) {
        var e = this;
        return new Promise((function (n) {
            try {
                function i(t) {
                    e.onLeaveCompleted && e.onLeaveCompleted(), n()
                }
                return e.onLeave && e.onLeave(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.hide(t)).then(i) : i())
            } catch (t) {
                return Promise.reject(t)
            }
        }))
    };
    var l = new window.DOMParser,
        c = function (t, e) {
            this.renderers = t, this.transitions = e
        };
    c.prototype.getOrigin = function (t) {
        var e = t.match(/(https?:\/\/[\w\-.]+)/);
        return e ? e[1].replace(/https?:\/\//, "") : null
    }, c.prototype.getPathname = function (t) {
        var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
        return e ? e[1] : "/"
    }, c.prototype.getAnchor = function (t) {
        var e = t.match(/(#.*)$/);
        return e ? e[1] : null
    }, c.prototype.getParams = function (t) {
        var e = t.match(/\?([\w_\-.=&]+)/);
        if (!e) return null;
        for (var n = e[1].split("&"), i = {}, r = 0; r < n.length; r++) {
            var o = n[r].split("=");
            i[o[0]] = o[1]
        }
        return i
    }, c.prototype.getDOM = function (t) {
        return "string" == typeof t ? l.parseFromString(t, "text/html") : t
    }, c.prototype.getView = function (t) {
        return t.querySelector("[data-router-view]")
    }, c.prototype.getSlug = function (t) {
        return t.getAttribute("data-router-view")
    }, c.prototype.getRenderer = function (t) {
        if (!this.renderers) return Promise.resolve(s);
        if (t in this.renderers) {
            var e = this.renderers[t];
            return "function" != typeof e || s.isPrototypeOf(e) ? "function" == typeof e.then ? Promise.resolve(e).then((function (t) {
                return t.default
            })) : Promise.resolve(e) : Promise.resolve(e()).then((function (t) {
                return t.default
            }))
        }
        return Promise.resolve(s)
    }, c.prototype.getTransition = function (t) {
        return this.transitions ? t in this.transitions ? {
            class: this.transitions[t],
            name: t
        } : "default" in this.transitions ? {
            class: this.transitions.default,
            name: "default"
        } : null : null
    }, c.prototype.getProperties = function (t) {
        var e = this.getDOM(t),
            n = this.getView(e),
            i = this.getSlug(n);
        return {
            page: e,
            view: n,
            slug: i,
            renderer: this.getRenderer(i, this.renderers),
            transition: this.getTransition(i, this.transitions)
        }
    }, c.prototype.getLocation = function (t) {
        return {
            href: t,
            anchor: this.getAnchor(t),
            origin: this.getOrigin(t),
            params: this.getParams(t),
            pathname: this.getPathname(t)
        }
    };
    var h = function (t) {
            function e(e) {
                var n = this;
                void 0 === e && (e = {});
                var i = e.renderers,
                    r = e.transitions;
                t.call(this), this.Helpers = new c(i, r), this.Transitions = r, this.Contextual = !1, this.location = this.Helpers.getLocation(window.location.href), this.properties = this.Helpers.getProperties(document.cloneNode(!0)), this.popping = !1, this.running = !1, this.trigger = null, this.cache = new Map, this.cache.set(this.location.href, this.properties), this.properties.renderer.then((function (t) {
                    n.From = new t(n.properties), n.From.setup()
                })), this._navigate = this.navigate.bind(this), window.addEventListener("popstate", this.popState.bind(this)), this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), this.attach(this.links)
            }
            return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.attach = function (t) {
                for (var e = 0, n = t; e < n.length; e += 1) n[e].addEventListener("click", this._navigate)
            }, e.prototype.detach = function (t) {
                for (var e = 0, n = t; e < n.length; e += 1) n[e].removeEventListener("click", this._navigate)
            }, e.prototype.navigate = function (t) {
                if (!t.metaKey && !t.ctrlKey) {
                    t.preventDefault();
                    var e = !!t.currentTarget.hasAttribute("data-transition") && t.currentTarget.dataset.transition;
                    this.redirect(t.currentTarget.href, e, t.currentTarget)
                }
            }, e.prototype.redirect = function (t, e, n) {
                if (void 0 === e && (e = !1), void 0 === n && (n = "script"), this.trigger = n, !this.running && t !== this.location.href) {
                    var i = this.Helpers.getLocation(t);
                    this.Contextual = !1, e && (this.Contextual = this.Transitions.contextual[e].prototype, this.Contextual.name = e), i.origin !== this.location.origin || i.anchor && i.pathname === this.location.pathname ? window.location.href = t : (this.location = i, this.beforeFetch())
                }
            }, e.prototype.popState = function () {
                this.trigger = "popstate", this.Contextual = !1;
                var t = this.Helpers.getLocation(window.location.href);
                this.location.pathname !== t.pathname || !this.location.anchor && !t.anchor ? (this.popping = !0, this.location = t, this.beforeFetch()) : this.location = t
            }, e.prototype.pushState = function () {
                this.popping || window.history.pushState(this.location, "", this.location.href)
            }, e.prototype.fetch = function () {
                try {
                    var t = this;
                    return Promise.resolve(fetch(t.location.href, {
                        mode: "same-origin",
                        method: "GET",
                        headers: {
                            "X-Requested-With": "Highway"
                        },
                        credentials: "same-origin"
                    })).then((function (e) {
                        if (e.status >= 200 && e.status < 300) return e.text();
                        window.location.href = t.location.href
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e.prototype.beforeFetch = function () {
                try {
                    var t = this;

                    function e() {
                        t.afterFetch()
                    }
                    t.pushState(), t.running = !0, t.emit("NAVIGATE_OUT", {
                        from: {
                            page: t.From.properties.page,
                            view: t.From.properties.view
                        },
                        trigger: t.trigger,
                        location: t.location
                    });
                    var n = {
                            trigger: t.trigger,
                            contextual: t.Contextual
                        },
                        i = t.cache.has(t.location.href) ? Promise.resolve(t.From.hide(n)).then((function () {
                            t.properties = t.cache.get(t.location.href)
                        })) : Promise.resolve(Promise.all([t.fetch(), t.From.hide(n)])).then((function (e) {
                            t.properties = t.Helpers.getProperties(e[0]), t.cache.set(t.location.href, t.properties)
                        }));
                    return Promise.resolve(i && i.then ? i.then(e) : e())
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e.prototype.afterFetch = function () {
                try {
                    var t = this;
                    return Promise.resolve(t.properties.renderer).then((function (e) {
                        return t.To = new e(t.properties), t.To.add(), t.emit("NAVIGATE_IN", {
                            to: {
                                page: t.To.properties.page,
                                view: t.To.wrap.lastElementChild
                            },
                            trigger: t.trigger,
                            location: t.location
                        }), Promise.resolve(t.To.show({
                            trigger: t.trigger,
                            contextual: t.Contextual
                        })).then((function () {
                            t.popping = !1, t.running = !1, t.detach(t.links), t.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), t.attach(t.links), t.emit("NAVIGATE_END", {
                                to: {
                                    page: t.To.properties.page,
                                    view: t.To.wrap.lastElementChild
                                },
                                from: {
                                    page: t.From.properties.page,
                                    view: t.From.properties.view
                                },
                                trigger: t.trigger,
                                location: t.location
                            }), t.From = t.To, t.trigger = null
                        }))
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e
        }(a),
        u = function (t, e) {
            this.wrap = t, this.name = e
        };
    u.prototype.show = function (t) {
        var e = this,
            n = t.trigger,
            i = t.contextual,
            r = this.wrap.lastElementChild,
            o = this.wrap.firstElementChild;
        return new Promise((function (t) {
            i ? (r.setAttribute("data-transition-in", i.name), r.removeAttribute("data-transition-out", i.name), i.in && i.in({
                to: r,
                from: o,
                trigger: n,
                done: t
            })) : (r.setAttribute("data-transition-in", e.name), r.removeAttribute("data-transition-out", e.name), e.in && e.in({
                to: r,
                from: o,
                trigger: n,
                done: t
            }))
        }))
    }, u.prototype.hide = function (t) {
        var e = this,
            n = t.trigger,
            i = t.contextual,
            r = this.wrap.firstElementChild;
        return new Promise((function (t) {
            i ? (r.setAttribute("data-transition-out", i.name), r.removeAttribute("data-transition-in", i.name), i.out && i.out({
                from: r,
                trigger: n,
                done: t
            })) : (r.setAttribute("data-transition-out", e.name), r.removeAttribute("data-transition-in", e.name), e.out && e.out({
                from: r,
                trigger: n,
                done: t
            }))
        }))
    }, console.log("Highway v2.2.0");
    var d = {
            Core: h,
            Helpers: c,
            Renderer: s,
            Transition: u
        },
        p = n(1);
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }), void 0 === Math.sign && (Math.sign = function (t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t
    }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function (t) {
        if (null == t) throw new TypeError("Cannot convert undefined or null to object");
        for (var e = Object(t), n = 1; n < arguments.length; n++) {
            var i = arguments[n];
            if (null != i)
                for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
        }
        return e
    });

    function f() {}
    Object.assign(f.prototype, {
        addEventListener: function (t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function (t, e) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function (t, e) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[t];
                if (void 0 !== n) {
                    var i = n.indexOf(e); - 1 !== i && n.splice(i, 1)
                }
            }
        },
        dispatchEvent: function (t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    for (var n = e.slice(0), i = 0, r = n.length; i < r; i++) n[i].call(this, t)
                }
            }
        }
    });
    for (var m = [], v = 0; v < 256; v++) m[v] = (v < 16 ? "0" : "") + v.toString(16);
    var g, y = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function () {
            var t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                i = 4294967295 * Math.random() | 0;
            return (m[255 & t] + m[t >> 8 & 255] + m[t >> 16 & 255] + m[t >> 24 & 255] + "-" + m[255 & e] + m[e >> 8 & 255] + "-" + m[e >> 16 & 15 | 64] + m[e >> 24 & 255] + "-" + m[63 & n | 128] + m[n >> 8 & 255] + "-" + m[n >> 16 & 255] + m[n >> 24 & 255] + m[255 & i] + m[i >> 8 & 255] + m[i >> 16 & 255] + m[i >> 24 & 255]).toUpperCase()
        },
        clamp: function (t, e, n) {
            return Math.max(e, Math.min(n, t))
        },
        euclideanModulo: function (t, e) {
            return (t % e + e) % e
        },
        mapLinear: function (t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        },
        lerp: function (t, e, n) {
            return (1 - n) * t + n * e
        },
        smoothstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function (t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function (t) {
            return t * (.5 - Math.random())
        },
        degToRad: function (t) {
            return t * y.DEG2RAD
        },
        radToDeg: function (t) {
            return t * y.RAD2DEG
        },
        isPowerOfTwo: function (t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        ceilPowerOfTwo: function (t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        },
        floorPowerOfTwo: function (t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        },
        setQuaternionFromProperEuler: function (t, e, n, i, r) {
            var o = Math.cos,
                a = Math.sin,
                s = o(n / 2),
                l = a(n / 2),
                c = o((e + i) / 2),
                h = a((e + i) / 2),
                u = o((e - i) / 2),
                d = a((e - i) / 2),
                p = o((i - e) / 2),
                f = a((i - e) / 2);
            switch (r) {
                case "XYX":
                    t.set(s * h, l * u, l * d, s * c);
                    break;
                case "YZY":
                    t.set(l * d, s * h, l * u, s * c);
                    break;
                case "ZXZ":
                    t.set(l * u, l * d, s * h, s * c);
                    break;
                case "XZX":
                    t.set(s * h, l * f, l * p, s * c);
                    break;
                case "YXY":
                    t.set(l * p, s * h, l * f, s * c);
                    break;
                case "ZYZ":
                    t.set(l * f, l * p, s * h, s * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        }
    };

    function _(t, e) {
        this.x = t || 0, this.y = e || 0
    }

    function x() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.defineProperties(_.prototype, {
        width: {
            get: function () {
                return this.x
            },
            set: function (t) {
                this.x = t
            }
        },
        height: {
            get: function () {
                return this.y
            },
            set: function (t) {
                this.y = t
            }
        }
    }), Object.assign(_.prototype, {
        isVector2: !0,
        set: function (t, e) {
            return this.x = t, this.y = e, this
        },
        setScalar: function (t) {
            return this.x = t, this.y = t, this
        },
        setX: function (t) {
            return this.x = t, this
        },
        setY: function (t) {
            return this.y = t, this
        },
        setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y)
        },
        copy: function (t) {
            return this.x = t.x, this.y = t.y, this
        },
        add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addScalar: function (t) {
            return this.x += t, this.y += t, this
        },
        addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        },
        addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        },
        sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subScalar: function (t) {
            return this.x -= t, this.y -= t, this
        },
        subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        },
        multiply: function (t) {
            return this.x *= t.x, this.y *= t.y, this
        },
        multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this
        },
        divide: function (t) {
            return this.x /= t.x, this.y /= t.y, this
        },
        divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function (t) {
            var e = this.x,
                n = this.y,
                i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
        },
        min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        },
        max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        },
        clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        },
        clampScalar: function (t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
        },
        clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function (t) {
            return this.x * t.x + this.y * t.y
        },
        cross: function (t) {
            return this.x * t.y - this.y * t.x
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        angle: function () {
            return Math.atan2(-this.y, -this.x) + Math.PI
        },
        distanceTo: function (t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function (t) {
            var e = this.x - t.x,
                n = this.y - t.y;
            return e * e + n * n
        },
        manhattanDistanceTo: function (t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        },
        lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function (t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
        },
        fromBufferAttribute: function (t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
        },
        rotateAround: function (t, e) {
            var n = Math.cos(e),
                i = Math.sin(e),
                r = this.x - t.x,
                o = this.y - t.y;
            return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this
        },
        random: function () {
            return this.x = Math.random(), this.y = Math.random(), this
        }
    }), Object.assign(x.prototype, {
        isMatrix3: !0,
        set: function (t, e, n, i, r, o, a, s, l) {
            var c = this.elements;
            return c[0] = t, c[1] = i, c[2] = a, c[3] = e, c[4] = r, c[5] = s, c[6] = n, c[7] = o, c[8] = l, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function (t) {
            var e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
        },
        extractBasis: function (t, e, n) {
            return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        },
        setFromMatrix4: function (t) {
            var e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        multiply: function (t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function (t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function (t, e) {
            var n = t.elements,
                i = e.elements,
                r = this.elements,
                o = n[0],
                a = n[3],
                s = n[6],
                l = n[1],
                c = n[4],
                h = n[7],
                u = n[2],
                d = n[5],
                p = n[8],
                f = i[0],
                m = i[3],
                v = i[6],
                g = i[1],
                y = i[4],
                _ = i[7],
                x = i[2],
                b = i[5],
                w = i[8];
            return r[0] = o * f + a * g + s * x, r[3] = o * m + a * y + s * b, r[6] = o * v + a * _ + s * w, r[1] = l * f + c * g + h * x, r[4] = l * m + c * y + h * b, r[7] = l * v + c * _ + h * w, r[2] = u * f + d * g + p * x, r[5] = u * m + d * y + p * b, r[8] = u * v + d * _ + p * w, this
        },
        multiplyScalar: function (t) {
            var e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        },
        determinant: function () {
            var t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                r = t[3],
                o = t[4],
                a = t[5],
                s = t[6],
                l = t[7],
                c = t[8];
            return e * o * c - e * a * l - n * r * c + n * a * s + i * r * l - i * o * s
        },
        getInverse: function (t, e) {
            void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
            var n = t.elements,
                i = this.elements,
                r = n[0],
                o = n[1],
                a = n[2],
                s = n[3],
                l = n[4],
                c = n[5],
                h = n[6],
                u = n[7],
                d = n[8],
                p = d * l - c * u,
                f = c * h - d * s,
                m = u * s - l * h,
                v = r * p + o * f + a * m;
            if (0 === v) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            var g = 1 / v;
            return i[0] = p * g, i[1] = (a * u - d * o) * g, i[2] = (c * o - a * l) * g, i[3] = f * g, i[4] = (d * r - a * h) * g, i[5] = (a * s - c * r) * g, i[6] = m * g, i[7] = (o * h - u * r) * g, i[8] = (l * r - o * s) * g, this
        },
        transpose: function () {
            var t, e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function (t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function (t) {
            var e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        },
        setUvTransform: function (t, e, n, i, r, o, a) {
            var s = Math.cos(r),
                l = Math.sin(r);
            this.set(n * s, n * l, -n * (s * o + l * a) + o + t, -i * l, i * s, -i * (-l * o + s * a) + a + e, 0, 0, 1)
        },
        scale: function (t, e) {
            var n = this.elements;
            return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
        },
        rotate: function (t) {
            var e = Math.cos(t),
                n = Math.sin(t),
                i = this.elements,
                r = i[0],
                o = i[3],
                a = i[6],
                s = i[1],
                l = i[4],
                c = i[7];
            return i[0] = e * r + n * s, i[3] = e * o + n * l, i[6] = e * a + n * c, i[1] = -n * r + e * s, i[4] = -n * o + e * l, i[7] = -n * a + e * c, this
        },
        translate: function (t, e) {
            var n = this.elements;
            return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
        },
        equals: function (t) {
            for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
                if (e[i] !== n[i]) return !1;
            return !0
        },
        fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
        }
    });
    var b = {
            getDataURL: function (t) {
                var e;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    void 0 === g && (g = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), g.width = t.width, g.height = t.height;
                    var n = g.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = g
                }
                return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        },
        w = 0;

    function M(t, e, n, i, r, o, a, s, l, c) {
        Object.defineProperty(this, "id", {
            value: w++
        }), this.uuid = y.generateUUID(), this.name = "", this.image = void 0 !== t ? t : M.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : M.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== i ? i : 1001, this.magFilter = void 0 !== r ? r : 1006, this.minFilter = void 0 !== o ? o : 1008, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== a ? a : 1023, this.internalFormat = null, this.type = void 0 !== s ? s : 1009, this.offset = new _(0, 0), this.repeat = new _(1, 1), this.center = new _(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new x, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== c ? c : 3e3, this.version = 0, this.onUpdate = null
    }

    function S(t, e, n, i) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
    }

    function T(t, e, n) {
        this.width = t, this.height = e, this.scissor = new S(0, 0, t, e), this.scissorTest = !1, this.viewport = new S(0, 0, t, e), n = n || {}, this.texture = new M(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    function E(t, e, n) {
        T.call(this, t, e, n), this.samples = 4
    }

    function A(t, e, n, i) {
        this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
    }
    M.DEFAULT_IMAGE = void 0, M.DEFAULT_MAPPING = 300, M.prototype = Object.assign(Object.create(f.prototype), {
        constructor: M,
        isTexture: !0,
        updateMatrix: function () {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
        },
        toJSON: function (t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var i = this.image;
                if (void 0 === i.uuid && (i.uuid = y.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                    var r;
                    if (Array.isArray(i)) {
                        r = [];
                        for (var o = 0, a = i.length; o < a; o++) r.push(b.getDataURL(i[o]))
                    } else r = b.getDataURL(i);
                    t.images[i.uuid] = {
                        uuid: i.uuid,
                        url: r
                    }
                }
                n.image = i.uuid
            }
            return e || (t.textures[this.uuid] = n), n
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function (t) {
            if (300 !== this.mapping) return t;
            if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                case 1e3:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case 1001:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
            }
            if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                case 1e3:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case 1001:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
            }
            return this.flipY && (t.y = 1 - t.y), t
        }
    }), Object.defineProperty(M.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), Object.defineProperties(S.prototype, {
        width: {
            get: function () {
                return this.z
            },
            set: function (t) {
                this.z = t
            }
        },
        height: {
            get: function () {
                return this.w
            },
            set: function (t) {
                this.w = t
            }
        }
    }), Object.assign(S.prototype, {
        isVector4: !0,
        set: function (t, e, n, i) {
            return this.x = t, this.y = e, this.z = n, this.w = i, this
        },
        setScalar: function (t) {
            return this.x = t, this.y = t, this.z = t, this.w = t, this
        },
        setX: function (t) {
            return this.x = t, this
        },
        setY: function (t) {
            return this.y = t, this
        },
        setZ: function (t) {
            return this.z = t, this
        },
        setW: function (t) {
            return this.w = t, this
        },
        setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function (t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        },
        add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function (t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        },
        addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        },
        addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        },
        sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subScalar: function (t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        },
        subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        },
        multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        },
        applyMatrix4: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = this.w,
                o = t.elements;
            return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this
        },
        divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function (t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        },
        setAxisAngleFromRotationMatrix: function (t) {
            var e, n, i, r, o = t.elements,
                a = o[0],
                s = o[4],
                l = o[8],
                c = o[1],
                h = o[5],
                u = o[9],
                d = o[2],
                p = o[6],
                f = o[10];
            if (Math.abs(s - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) {
                if (Math.abs(s + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(a + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                var m = (a + 1) / 2,
                    v = (h + 1) / 2,
                    g = (f + 1) / 2,
                    y = (s + c) / 4,
                    _ = (l + d) / 4,
                    x = (u + p) / 4;
                return m > v && m > g ? m < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = y / (n = Math.sqrt(m)), r = _ / n) : v > g ? v < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = y / (i = Math.sqrt(v)), r = x / i) : g < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = _ / (r = Math.sqrt(g)), i = x / r), this.set(n, i, r, e), this
            }
            var b = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - s) * (c - s));
            return Math.abs(b) < .001 && (b = 1), this.x = (p - u) / b, this.y = (l - d) / b, this.z = (c - s) / b, this.w = Math.acos((a + h + f - 1) / 2), this
        },
        min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        },
        max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        },
        clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        },
        clampScalar: function (t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
        },
        clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        },
        lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function (t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        },
        fromBufferAttribute: function (t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
        },
        random: function () {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        }
    }), T.prototype = Object.assign(Object.create(f.prototype), {
        constructor: T,
        isWebGLRenderTarget: !0,
        setSize: function (t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), E.prototype = Object.assign(Object.create(T.prototype), {
        constructor: E,
        isWebGLMultisampleRenderTarget: !0,
        copy: function (t) {
            return T.prototype.copy.call(this, t), this.samples = t.samples, this
        }
    }), Object.assign(A, {
        slerp: function (t, e, n, i) {
            return n.copy(t).slerp(e, i)
        },
        slerpFlat: function (t, e, n, i, r, o, a) {
            var s = n[i + 0],
                l = n[i + 1],
                c = n[i + 2],
                h = n[i + 3],
                u = r[o + 0],
                d = r[o + 1],
                p = r[o + 2],
                f = r[o + 3];
            if (h !== f || s !== u || l !== d || c !== p) {
                var m = 1 - a,
                    v = s * u + l * d + c * p + h * f,
                    g = v >= 0 ? 1 : -1,
                    y = 1 - v * v;
                if (y > Number.EPSILON) {
                    var _ = Math.sqrt(y),
                        x = Math.atan2(_, v * g);
                    m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                }
                var b = a * g;
                if (s = s * m + u * b, l = l * m + d * b, c = c * m + p * b, h = h * m + f * b, m === 1 - a) {
                    var w = 1 / Math.sqrt(s * s + l * l + c * c + h * h);
                    s *= w, l *= w, c *= w, h *= w
                }
            }
            t[e] = s, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
        },
        multiplyQuaternionsFlat: function (t, e, n, i, r, o) {
            var a = n[i],
                s = n[i + 1],
                l = n[i + 2],
                c = n[i + 3],
                h = r[o],
                u = r[o + 1],
                d = r[o + 2],
                p = r[o + 3];
            return t[e] = a * p + c * h + s * d - l * u, t[e + 1] = s * p + c * u + l * h - a * d, t[e + 2] = l * p + c * d + a * u - s * h, t[e + 3] = c * p - a * h - s * u - l * d, t
        }
    }), Object.defineProperties(A.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (t) {
                this._x = t, this._onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (t) {
                this._y = t, this._onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (t) {
                this._z = t, this._onChangeCallback()
            }
        },
        w: {
            get: function () {
                return this._w
            },
            set: function (t) {
                this._w = t, this._onChangeCallback()
            }
        }
    }), Object.assign(A.prototype, {
        isQuaternion: !0,
        set: function (t, e, n, i) {
            return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function (t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
        },
        setFromEuler: function (t, e) {
            if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = t._x,
                i = t._y,
                r = t._z,
                o = t.order,
                a = Math.cos,
                s = Math.sin,
                l = a(n / 2),
                c = a(i / 2),
                h = a(r / 2),
                u = s(n / 2),
                d = s(i / 2),
                p = s(r / 2);
            switch (o) {
                case "XYZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "YXZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "ZXY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "ZYX":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "YZX":
                    this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "XZY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
            }
            return !1 !== e && this._onChangeCallback(), this
        },
        setFromAxisAngle: function (t, e) {
            var n = e / 2,
                i = Math.sin(n);
            return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        },
        setFromRotationMatrix: function (t) {
            var e, n = t.elements,
                i = n[0],
                r = n[4],
                o = n[8],
                a = n[1],
                s = n[5],
                l = n[9],
                c = n[2],
                h = n[6],
                u = n[10],
                d = i + s + u;
            return d > 0 ? (e = .5 / Math.sqrt(d + 1), this._w = .25 / e, this._x = (h - l) * e, this._y = (o - c) * e, this._z = (a - r) * e) : i > s && i > u ? (e = 2 * Math.sqrt(1 + i - s - u), this._w = (h - l) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (o + c) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - i - u), this._w = (o - c) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (l + h) / e) : (e = 2 * Math.sqrt(1 + u - i - s), this._w = (a - r) / e, this._x = (o + c) / e, this._y = (l + h) / e, this._z = .25 * e), this._onChangeCallback(), this
        },
        setFromUnitVectors: function (t, e) {
            var n = t.dot(e) + 1;
            return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
        },
        angleTo: function (t) {
            return 2 * Math.acos(Math.abs(y.clamp(this.dot(t), -1, 1)))
        },
        rotateTowards: function (t, e) {
            var n = this.angleTo(t);
            if (0 === n) return this;
            var i = Math.min(1, e / n);
            return this.slerp(t, i), this
        },
        inverse: function () {
            return this.conjugate()
        },
        conjugate: function () {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        },
        dot: function (t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function () {
            var t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
        },
        multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function (t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function (t, e) {
            var n = t._x,
                i = t._y,
                r = t._z,
                o = t._w,
                a = e._x,
                s = e._y,
                l = e._z,
                c = e._w;
            return this._x = n * c + o * a + i * l - r * s, this._y = i * c + o * s + r * a - n * l, this._z = r * c + o * l + n * s - i * a, this._w = o * c - n * a - i * s - r * l, this._onChangeCallback(), this
        },
        slerp: function (t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var n = this._x,
                i = this._y,
                r = this._z,
                o = this._w,
                a = o * t._w + n * t._x + i * t._y + r * t._z;
            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
            var s = 1 - a * a;
            if (s <= Number.EPSILON) {
                var l = 1 - e;
                return this._w = l * o + e * this._w, this._x = l * n + e * this._x, this._y = l * i + e * this._y, this._z = l * r + e * this._z, this.normalize(), this._onChangeCallback(), this
            }
            var c = Math.sqrt(s),
                h = Math.atan2(c, a),
                u = Math.sin((1 - e) * h) / c,
                d = Math.sin(e * h) / c;
            return this._w = o * u + this._w * d, this._x = n * u + this._x * d, this._y = i * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this
        },
        equals: function (t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        },
        fromBufferAttribute: function (t, e) {
            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
        },
        _onChange: function (t) {
            return this._onChangeCallback = t, this
        },
        _onChangeCallback: function () {}
    });
    var C = new P,
        L = new A;

    function P(t, e, n) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0
    }
    Object.assign(P.prototype, {
        isVector3: !0,
        set: function (t, e, n) {
            return this.x = t, this.y = e, this.z = n, this
        },
        setScalar: function (t) {
            return this.x = t, this.y = t, this.z = t, this
        },
        setX: function (t) {
            return this.x = t, this
        },
        setY: function (t) {
            return this.y = t, this
        },
        setZ: function (t) {
            return this.z = t, this
        },
        setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function (t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        },
        add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function (t) {
            return this.x += t, this.y += t, this.z += t, this
        },
        addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        },
        addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        },
        sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subScalar: function (t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        },
        subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        },
        multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        },
        multiplyVectors: function (t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        },
        applyEuler: function (t) {
            return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(L.setFromEuler(t))
        },
        applyAxisAngle: function (t, e) {
            return this.applyQuaternion(L.setFromAxisAngle(t, e))
        },
        applyMatrix3: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
        },
        applyNormalMatrix: function (t) {
            return this.applyMatrix3(t).normalize()
        },
        applyMatrix4: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements,
                o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this
        },
        applyQuaternion: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = t.x,
                o = t.y,
                a = t.z,
                s = t.w,
                l = s * e + o * i - a * n,
                c = s * n + a * e - r * i,
                h = s * i + r * n - o * e,
                u = -r * e - o * n - a * i;
            return this.x = l * s + u * -r + c * -a - h * -o, this.y = c * s + u * -o + h * -r - l * -a, this.z = h * s + u * -a + l * -o - c * -r, this
        },
        project: function (t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        },
        unproject: function (t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        },
        transformDirection: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
        },
        divide: function (t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        },
        divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        },
        min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        },
        max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        },
        clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        },
        clampScalar: function (t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
        },
        clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        },
        lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        cross: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
        },
        crossVectors: function (t, e) {
            var n = t.x,
                i = t.y,
                r = t.z,
                o = e.x,
                a = e.y,
                s = e.z;
            return this.x = i * s - r * a, this.y = r * o - n * s, this.z = n * a - i * o, this
        },
        projectOnVector: function (t) {
            var e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            var n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n)
        },
        projectOnPlane: function (t) {
            return C.copy(this).projectOnVector(t), this.sub(C)
        },
        reflect: function (t) {
            return this.sub(C.copy(t).multiplyScalar(2 * this.dot(t)))
        },
        angleTo: function (t) {
            var e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            var n = this.dot(t) / e;
            return Math.acos(y.clamp(n, -1, 1))
        },
        distanceTo: function (t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function (t) {
            var e = this.x - t.x,
                n = this.y - t.y,
                i = this.z - t.z;
            return e * e + n * n + i * i
        },
        manhattanDistanceTo: function (t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function (t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        },
        setFromSphericalCoords: function (t, e, n) {
            var i = Math.sin(e) * t;
            return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
        },
        setFromCylindrical: function (t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        },
        setFromCylindricalCoords: function (t, e, n) {
            return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
        },
        setFromMatrixPosition: function (t) {
            var e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function (t) {
            var e = this.setFromMatrixColumn(t, 0).length(),
                n = this.setFromMatrixColumn(t, 1).length(),
                i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = n, this.z = i, this
        },
        setFromMatrixColumn: function (t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        setFromMatrix3Column: function (t, e) {
            return this.fromArray(t.elements, 3 * e)
        },
        equals: function (t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        },
        fromBufferAttribute: function (t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        },
        random: function () {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
    });
    var R = new P,
        O = new B,
        D = new P(0, 0, 0),
        I = new P(1, 1, 1),
        N = new P,
        k = new P,
        z = new P;

    function B() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.assign(B.prototype, {
        isMatrix4: !0,
        set: function (t, e, n, i, r, o, a, s, l, c, h, u, d, p, f, m) {
            var v = this.elements;
            return v[0] = t, v[4] = e, v[8] = n, v[12] = i, v[1] = r, v[5] = o, v[9] = a, v[13] = s, v[2] = l, v[6] = c, v[10] = h, v[14] = u, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new B).fromArray(this.elements)
        },
        copy: function (t) {
            var e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
        },
        copyPosition: function (t) {
            var e = this.elements,
                n = t.elements;
            return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
        },
        extractBasis: function (t, e, n) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function (t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function (t) {
            var e = this.elements,
                n = t.elements,
                i = 1 / R.setFromMatrixColumn(t, 0).length(),
                r = 1 / R.setFromMatrixColumn(t, 1).length(),
                o = 1 / R.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromEuler: function (t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z,
                o = Math.cos(n),
                a = Math.sin(n),
                s = Math.cos(i),
                l = Math.sin(i),
                c = Math.cos(r),
                h = Math.sin(r);
            if ("XYZ" === t.order) {
                var u = o * c,
                    d = o * h,
                    p = a * c,
                    f = a * h;
                e[0] = s * c, e[4] = -s * h, e[8] = l, e[1] = d + p * l, e[5] = u - f * l, e[9] = -a * s, e[2] = f - u * l, e[6] = p + d * l, e[10] = o * s
            } else if ("YXZ" === t.order) {
                var m = s * c,
                    v = s * h,
                    g = l * c,
                    y = l * h;
                e[0] = m + y * a, e[4] = g * a - v, e[8] = o * l, e[1] = o * h, e[5] = o * c, e[9] = -a, e[2] = v * a - g, e[6] = y + m * a, e[10] = o * s
            } else if ("ZXY" === t.order) {
                m = s * c, v = s * h, g = l * c, y = l * h;
                e[0] = m - y * a, e[4] = -o * h, e[8] = g + v * a, e[1] = v + g * a, e[5] = o * c, e[9] = y - m * a, e[2] = -o * l, e[6] = a, e[10] = o * s
            } else if ("ZYX" === t.order) {
                u = o * c, d = o * h, p = a * c, f = a * h;
                e[0] = s * c, e[4] = p * l - d, e[8] = u * l + f, e[1] = s * h, e[5] = f * l + u, e[9] = d * l - p, e[2] = -l, e[6] = a * s, e[10] = o * s
            } else if ("YZX" === t.order) {
                var _ = o * s,
                    x = o * l,
                    b = a * s,
                    w = a * l;
                e[0] = s * c, e[4] = w - _ * h, e[8] = b * h + x, e[1] = h, e[5] = o * c, e[9] = -a * c, e[2] = -l * c, e[6] = x * h + b, e[10] = _ - w * h
            } else if ("XZY" === t.order) {
                _ = o * s, x = o * l, b = a * s, w = a * l;
                e[0] = s * c, e[4] = -h, e[8] = l * c, e[1] = _ * h + w, e[5] = o * c, e[9] = x * h - b, e[2] = b * h - x, e[6] = a * c, e[10] = w * h + _
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromQuaternion: function (t) {
            return this.compose(D, t, I)
        },
        lookAt: function (t, e, n) {
            var i = this.elements;
            return z.subVectors(t, e), 0 === z.lengthSq() && (z.z = 1), z.normalize(), N.crossVectors(n, z), 0 === N.lengthSq() && (1 === Math.abs(n.z) ? z.x += 1e-4 : z.z += 1e-4, z.normalize(), N.crossVectors(n, z)), N.normalize(), k.crossVectors(z, N), i[0] = N.x, i[4] = k.x, i[8] = z.x, i[1] = N.y, i[5] = k.y, i[9] = z.y, i[2] = N.z, i[6] = k.z, i[10] = z.z, this
        },
        multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        premultiply: function (t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function (t, e) {
            var n = t.elements,
                i = e.elements,
                r = this.elements,
                o = n[0],
                a = n[4],
                s = n[8],
                l = n[12],
                c = n[1],
                h = n[5],
                u = n[9],
                d = n[13],
                p = n[2],
                f = n[6],
                m = n[10],
                v = n[14],
                g = n[3],
                y = n[7],
                _ = n[11],
                x = n[15],
                b = i[0],
                w = i[4],
                M = i[8],
                S = i[12],
                T = i[1],
                E = i[5],
                A = i[9],
                C = i[13],
                L = i[2],
                P = i[6],
                R = i[10],
                O = i[14],
                D = i[3],
                I = i[7],
                N = i[11],
                k = i[15];
            return r[0] = o * b + a * T + s * L + l * D, r[4] = o * w + a * E + s * P + l * I, r[8] = o * M + a * A + s * R + l * N, r[12] = o * S + a * C + s * O + l * k, r[1] = c * b + h * T + u * L + d * D, r[5] = c * w + h * E + u * P + d * I, r[9] = c * M + h * A + u * R + d * N, r[13] = c * S + h * C + u * O + d * k, r[2] = p * b + f * T + m * L + v * D, r[6] = p * w + f * E + m * P + v * I, r[10] = p * M + f * A + m * R + v * N, r[14] = p * S + f * C + m * O + v * k, r[3] = g * b + y * T + _ * L + x * D, r[7] = g * w + y * E + _ * P + x * I, r[11] = g * M + y * A + _ * R + x * N, r[15] = g * S + y * C + _ * O + x * k, this
        },
        multiplyScalar: function (t) {
            var e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        },
        determinant: function () {
            var t = this.elements,
                e = t[0],
                n = t[4],
                i = t[8],
                r = t[12],
                o = t[1],
                a = t[5],
                s = t[9],
                l = t[13],
                c = t[2],
                h = t[6],
                u = t[10],
                d = t[14];
            return t[3] * (+r * s * h - i * l * h - r * a * u + n * l * u + i * a * d - n * s * d) + t[7] * (+e * s * d - e * l * u + r * o * u - i * o * d + i * l * c - r * s * c) + t[11] * (+e * l * h - e * a * d - r * o * h + n * o * d + r * a * c - n * l * c) + t[15] * (-i * a * c - e * s * h + e * a * u + i * o * h - n * o * u + n * s * c)
        },
        transpose: function () {
            var t, e = this.elements;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        setPosition: function (t, e, n) {
            var i = this.elements;
            return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
        },
        getInverse: function (t, e) {
            void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
            var n = this.elements,
                i = t.elements,
                r = i[0],
                o = i[1],
                a = i[2],
                s = i[3],
                l = i[4],
                c = i[5],
                h = i[6],
                u = i[7],
                d = i[8],
                p = i[9],
                f = i[10],
                m = i[11],
                v = i[12],
                g = i[13],
                y = i[14],
                _ = i[15],
                x = p * y * u - g * f * u + g * h * m - c * y * m - p * h * _ + c * f * _,
                b = v * f * u - d * y * u - v * h * m + l * y * m + d * h * _ - l * f * _,
                w = d * g * u - v * p * u + v * c * m - l * g * m - d * c * _ + l * p * _,
                M = v * p * h - d * g * h - v * c * f + l * g * f + d * c * y - l * p * y,
                S = r * x + o * b + a * w + s * M;
            if (0 === S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var T = 1 / S;
            return n[0] = x * T, n[1] = (g * f * s - p * y * s - g * a * m + o * y * m + p * a * _ - o * f * _) * T, n[2] = (c * y * s - g * h * s + g * a * u - o * y * u - c * a * _ + o * h * _) * T, n[3] = (p * h * s - c * f * s - p * a * u + o * f * u + c * a * m - o * h * m) * T, n[4] = b * T, n[5] = (d * y * s - v * f * s + v * a * m - r * y * m - d * a * _ + r * f * _) * T, n[6] = (v * h * s - l * y * s - v * a * u + r * y * u + l * a * _ - r * h * _) * T, n[7] = (l * f * s - d * h * s + d * a * u - r * f * u - l * a * m + r * h * m) * T, n[8] = w * T, n[9] = (v * p * s - d * g * s - v * o * m + r * g * m + d * o * _ - r * p * _) * T, n[10] = (l * g * s - v * c * s + v * o * u - r * g * u - l * o * _ + r * c * _) * T, n[11] = (d * c * s - l * p * s - d * o * u + r * p * u + l * o * m - r * c * m) * T, n[12] = M * T, n[13] = (d * g * a - v * p * a + v * o * f - r * g * f - d * o * y + r * p * y) * T, n[14] = (v * c * a - l * g * a - v * o * h + r * g * h + l * o * y - r * c * y) * T, n[15] = (l * p * a - d * c * a + d * o * h - r * p * h - l * o * f + r * c * f) * T, this
        },
        scale: function (t) {
            var e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z;
            return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
        },
        getMaxScaleOnAxis: function () {
            var t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i))
        },
        makeTranslation: function (t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
        },
        makeRotationX: function (t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function (t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function (t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function (t, e) {
            var n = Math.cos(e),
                i = Math.sin(e),
                r = 1 - n,
                o = t.x,
                a = t.y,
                s = t.z,
                l = r * o,
                c = r * a;
            return this.set(l * o + n, l * a - i * s, l * s + i * a, 0, l * a + i * s, c * a + n, c * s - i * o, 0, l * s - i * a, c * s + i * o, r * s * s + n, 0, 0, 0, 0, 1), this
        },
        makeScale: function (t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        },
        makeShear: function (t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
        },
        compose: function (t, e, n) {
            var i = this.elements,
                r = e._x,
                o = e._y,
                a = e._z,
                s = e._w,
                l = r + r,
                c = o + o,
                h = a + a,
                u = r * l,
                d = r * c,
                p = r * h,
                f = o * c,
                m = o * h,
                v = a * h,
                g = s * l,
                y = s * c,
                _ = s * h,
                x = n.x,
                b = n.y,
                w = n.z;
            return i[0] = (1 - (f + v)) * x, i[1] = (d + _) * x, i[2] = (p - y) * x, i[3] = 0, i[4] = (d - _) * b, i[5] = (1 - (u + v)) * b, i[6] = (m + g) * b, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - g) * w, i[10] = (1 - (u + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
        },
        decompose: function (t, e, n) {
            var i = this.elements,
                r = R.set(i[0], i[1], i[2]).length(),
                o = R.set(i[4], i[5], i[6]).length(),
                a = R.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], O.copy(this);
            var s = 1 / r,
                l = 1 / o,
                c = 1 / a;
            return O.elements[0] *= s, O.elements[1] *= s, O.elements[2] *= s, O.elements[4] *= l, O.elements[5] *= l, O.elements[6] *= l, O.elements[8] *= c, O.elements[9] *= c, O.elements[10] *= c, e.setFromRotationMatrix(O), n.x = r, n.y = o, n.z = a, this
        },
        makePerspective: function (t, e, n, i, r, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements,
                s = 2 * r / (e - t),
                l = 2 * r / (n - i),
                c = (e + t) / (e - t),
                h = (n + i) / (n - i),
                u = -(o + r) / (o - r),
                d = -2 * o * r / (o - r);
            return a[0] = s, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makeOrthographic: function (t, e, n, i, r, o) {
            var a = this.elements,
                s = 1 / (e - t),
                l = 1 / (n - i),
                c = 1 / (o - r),
                h = (e + t) * s,
                u = (n + i) * l,
                d = (o + r) * c;
            return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function (t) {
            for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
                if (e[i] !== n[i]) return !1;
            return !0
        },
        fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
        }
    });
    var F = new B,
        U = new A;

    function H(t, e, n, i) {
        this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || H.DefaultOrder
    }

    function G() {
        this.mask = 1
    }
    H.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], H.DefaultOrder = "XYZ", Object.defineProperties(H.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (t) {
                this._x = t, this._onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (t) {
                this._y = t, this._onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (t) {
                this._z = t, this._onChangeCallback()
            }
        },
        order: {
            get: function () {
                return this._order
            },
            set: function (t) {
                this._order = t, this._onChangeCallback()
            }
        }
    }), Object.assign(H.prototype, {
        isEuler: !0,
        set: function (t, e, n, i) {
            return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function (t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
        },
        setFromRotationMatrix: function (t, e, n) {
            var i = y.clamp,
                r = t.elements,
                o = r[0],
                a = r[4],
                s = r[8],
                l = r[1],
                c = r[5],
                h = r[9],
                u = r[2],
                d = r[6],
                p = r[10];
            switch (e = e || this._order) {
                case "XYZ":
                    this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, c), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, o), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, o));
                    break;
                case "ZYX":
                    this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-a, c));
                    break;
                case "YZX":
                    this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, p));
                    break;
                case "XZY":
                    this._z = Math.asin(-i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-h, p), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
            }
            return this._order = e, !1 !== n && this._onChangeCallback(), this
        },
        setFromQuaternion: function (t, e, n) {
            return F.makeRotationFromQuaternion(t), this.setFromRotationMatrix(F, e, n)
        },
        setFromVector3: function (t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function (t) {
            return U.setFromEuler(this), this.setFromQuaternion(U, t)
        },
        equals: function (t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function (t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        },
        toVector3: function (t) {
            return t ? t.set(this._x, this._y, this._z) : new P(this._x, this._y, this._z)
        },
        _onChange: function (t) {
            return this._onChangeCallback = t, this
        },
        _onChangeCallback: function () {}
    }), Object.assign(G.prototype, {
        set: function (t) {
            this.mask = 1 << t | 0
        },
        enable: function (t) {
            this.mask |= 1 << t | 0
        },
        enableAll: function () {
            this.mask = -1
        },
        toggle: function (t) {
            this.mask ^= 1 << t | 0
        },
        disable: function (t) {
            this.mask &= ~(1 << t | 0)
        },
        disableAll: function () {
            this.mask = 0
        },
        test: function (t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var V = 0,
        j = new P,
        W = new A,
        q = new B,
        X = new P,
        Y = new P,
        J = new P,
        Z = new A,
        Q = new P(1, 0, 0),
        K = new P(0, 1, 0),
        $ = new P(0, 0, 1),
        tt = {
            type: "added"
        },
        et = {
            type: "removed"
        };

    function nt() {
        Object.defineProperty(this, "id", {
            value: V++
        }), this.uuid = y.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = nt.DefaultUp.clone();
        var t = new P,
            e = new H,
            n = new A,
            i = new P(1, 1, 1);
        e._onChange((function () {
            n.setFromEuler(e, !1)
        })), n._onChange((function () {
            e.setFromQuaternion(n, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new B
            },
            normalMatrix: {
                value: new x
            }
        }), this.matrix = new B, this.matrixWorld = new B, this.matrixAutoUpdate = nt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new G, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function it() {
        nt.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    nt.DefaultUp = new P(0, 1, 0), nt.DefaultMatrixAutoUpdate = !0, nt.prototype = Object.assign(Object.create(f.prototype), {
        constructor: nt,
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix4: function (t) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function (t) {
            return this.quaternion.premultiply(t), this
        },
        setRotationFromAxisAngle: function (t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function (t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function (t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function (t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function (t, e) {
            return W.setFromAxisAngle(t, e), this.quaternion.multiply(W), this
        },
        rotateOnWorldAxis: function (t, e) {
            return W.setFromAxisAngle(t, e), this.quaternion.premultiply(W), this
        },
        rotateX: function (t) {
            return this.rotateOnAxis(Q, t)
        },
        rotateY: function (t) {
            return this.rotateOnAxis(K, t)
        },
        rotateZ: function (t) {
            return this.rotateOnAxis($, t)
        },
        translateOnAxis: function (t, e) {
            return j.copy(t).applyQuaternion(this.quaternion), this.position.add(j.multiplyScalar(e)), this
        },
        translateX: function (t) {
            return this.translateOnAxis(Q, t)
        },
        translateY: function (t) {
            return this.translateOnAxis(K, t)
        },
        translateZ: function (t) {
            return this.translateOnAxis($, t)
        },
        localToWorld: function (t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function (t) {
            return t.applyMatrix4(q.getInverse(this.matrixWorld))
        },
        lookAt: function (t, e, n) {
            t.isVector3 ? X.copy(t) : X.set(t, e, n);
            var i = this.parent;
            this.updateWorldMatrix(!0, !1), Y.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? q.lookAt(Y, X, this.up) : q.lookAt(X, Y, this.up), this.quaternion.setFromRotationMatrix(q), i && (q.extractRotation(i.matrixWorld), W.setFromRotationMatrix(q), this.quaternion.premultiply(W.inverse()))
        },
        add: function (t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(tt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        },
        remove: function (t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            var n = this.children.indexOf(t);
            return -1 !== n && (t.parent = null, this.children.splice(n, 1), t.dispatchEvent(et)), this
        },
        attach: function (t) {
            return this.updateWorldMatrix(!0, !1), q.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), q.multiply(t.parent.matrixWorld)), t.applyMatrix4(q), t.updateWorldMatrix(!1, !1), this.add(t), this
        },
        getObjectById: function (t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function (t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function (t, e) {
            if (this[t] === e) return this;
            for (var n = 0, i = this.children.length; n < i; n++) {
                var r = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== r) return r
            }
        },
        getWorldPosition: function (t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new P), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function (t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new A), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Y, t, J), t
        },
        getWorldScale: function (t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new P), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Y, Z, t), t
        },
        getWorldDirection: function (t) {
            void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new P), this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        },
        raycast: function () {},
        traverse: function (t) {
            t(this);
            for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverse(t)
        },
        traverseVisible: function (t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
            }
        },
        traverseAncestors: function (t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        },
        updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function (t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
        },
        updateWorldMatrix: function (t, e) {
            var n = this.parent;
            if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                for (var i = this.children, r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0)
        },
        toJSON: function (t) {
            var e = void 0 === t || "string" == typeof t,
                n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var i = {};

            function r(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
            }
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(t.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes) {
                    var a = o.shapes;
                    if (Array.isArray(a))
                        for (var s = 0, l = a.length; s < l; s++) {
                            var c = a[s];
                            r(t.shapes, c)
                        } else r(t.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var h = [];
                    for (s = 0, l = this.material.length; s < l; s++) h.push(r(t.materials, this.material[s]));
                    i.material = h
                } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(t).object)
            }
            if (e) {
                var u = m(t.geometries),
                    d = m(t.materials),
                    p = m(t.textures),
                    f = m(t.images);
                a = m(t.shapes);
                u.length > 0 && (n.geometries = u), d.length > 0 && (n.materials = d), p.length > 0 && (n.textures = p), f.length > 0 && (n.images = f), a.length > 0 && (n.shapes = a)
            }
            return n.object = i, n;

            function m(t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    delete i.metadata, e.push(i)
                }
                return e
            }
        },
        clone: function (t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function (t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (var n = 0; n < t.children.length; n++) {
                    var i = t.children[n];
                    this.add(i.clone())
                }
            return this
        }
    }), it.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: it,
        isScene: !0,
        copy: function (t, e) {
            return nt.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
        },
        toJSON: function (t) {
            var e = nt.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var rt = [new P, new P, new P, new P, new P, new P, new P, new P],
        ot = new P,
        at = new gt,
        st = new P,
        lt = new P,
        ct = new P,
        ht = new P,
        ut = new P,
        dt = new P,
        pt = new P,
        ft = new P,
        mt = new P,
        vt = new P;

    function gt(t, e) {
        this.min = void 0 !== t ? t : new P(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new P(-1 / 0, -1 / 0, -1 / 0)
    }

    function yt(t, e, n, i, r) {
        var o, a;
        for (o = 0, a = t.length - 3; o <= a; o += 3) {
            vt.fromArray(t, o);
            var s = r.x * Math.abs(vt.x) + r.y * Math.abs(vt.y) + r.z * Math.abs(vt.z),
                l = e.dot(vt),
                c = n.dot(vt),
                h = i.dot(vt);
            if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > s) return !1
        }
        return !0
    }
    Object.assign(gt.prototype, {
        isBox3: !0,
        set: function (t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromArray: function (t) {
            for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.length; s < l; s += 3) {
                var c = t[s],
                    h = t[s + 1],
                    u = t[s + 2];
                c < e && (e = c), h < n && (n = h), u < i && (i = u), c > r && (r = c), h > o && (o = h), u > a && (a = u)
            }
            return this.min.set(e, n, i), this.max.set(r, o, a), this
        },
        setFromBufferAttribute: function (t) {
            for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.count; s < l; s++) {
                var c = t.getX(s),
                    h = t.getY(s),
                    u = t.getZ(s);
                c < e && (e = c), h < n && (n = h), u < i && (i = u), c > r && (r = c), h > o && (o = h), u > a && (a = u)
            }
            return this.min.set(e, n, i), this.max.set(r, o, a), this
        },
        setFromPoints: function (t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function (t, e) {
            var n = ot.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
        },
        setFromObject: function (t) {
            return this.makeEmpty(), this.expandByObject(t)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function (t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new P), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new P), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function (t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function (t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function (t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        expandByObject: function (t) {
            t.updateWorldMatrix(!1, !1);
            var e = t.geometry;
            void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), at.copy(e.boundingBox), at.applyMatrix4(t.matrixWorld), this.union(at));
            for (var n = t.children, i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
            return this
        },
        containsPoint: function (t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function (t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new P), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function (t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: function (t) {
            return this.clampPoint(t.center, ot), ot.distanceToSquared(t.center) <= t.radius * t.radius
        },
        intersectsPlane: function (t) {
            var e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
        },
        intersectsTriangle: function (t) {
            if (this.isEmpty()) return !1;
            this.getCenter(pt), ft.subVectors(this.max, pt), st.subVectors(t.a, pt), lt.subVectors(t.b, pt), ct.subVectors(t.c, pt), ht.subVectors(lt, st), ut.subVectors(ct, lt), dt.subVectors(st, ct);
            var e = [0, -ht.z, ht.y, 0, -ut.z, ut.y, 0, -dt.z, dt.y, ht.z, 0, -ht.x, ut.z, 0, -ut.x, dt.z, 0, -dt.x, -ht.y, ht.x, 0, -ut.y, ut.x, 0, -dt.y, dt.x, 0];
            return !!yt(e, st, lt, ct, ft) && (!!yt(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], st, lt, ct, ft) && (mt.crossVectors(ht, ut), yt(e = [mt.x, mt.y, mt.z], st, lt, ct, ft)))
        },
        clampPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new P), e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function (t) {
            return ot.copy(t).clamp(this.min, this.max).sub(t).length()
        },
        getBoundingSphere: function (t) {
            return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(ot).length(), t
        },
        intersect: function (t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function (t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        applyMatrix4: function (t) {
            return this.isEmpty() || (rt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), rt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), rt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), rt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), rt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), rt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), rt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), rt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(rt)), this
        },
        translate: function (t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function (t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    });
    var _t = new gt;

    function xt(t, e) {
        this.center = void 0 !== t ? t : new P, this.radius = void 0 !== e ? e : -1
    }
    Object.assign(xt.prototype, {
        set: function (t, e) {
            return this.center.copy(t), this.radius = e, this
        },
        setFromPoints: function (t, e) {
            var n = this.center;
            void 0 !== e ? n.copy(e) : _t.setFromPoints(t).getCenter(n);
            for (var i = 0, r = 0, o = t.length; r < o; r++) i = Math.max(i, n.distanceToSquared(t[r]));
            return this.radius = Math.sqrt(i), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        },
        isEmpty: function () {
            return this.radius < 0
        },
        makeEmpty: function () {
            return this.center.set(0, 0, 0), this.radius = -1, this
        },
        containsPoint: function (t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function (t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function (t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function (t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function (t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function (t, e) {
            var n = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new P), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
        },
        getBoundingBox: function (t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new gt), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
        },
        applyMatrix4: function (t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
        },
        translate: function (t) {
            return this.center.add(t), this
        },
        equals: function (t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    });
    var bt = new P,
        wt = new P,
        Mt = new P,
        St = new P,
        Tt = new P,
        Et = new P,
        At = new P;

    function Ct(t, e) {
        this.origin = void 0 !== t ? t : new P, this.direction = void 0 !== e ? e : new P(0, 0, -1)
    }
    Object.assign(Ct.prototype, {
        set: function (t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        },
        at: function (t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new P), e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function (t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
        },
        recast: function (t) {
            return this.origin.copy(this.at(t, bt)), this
        },
        closestPointToPoint: function (t, e) {
            void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new P), e.subVectors(t, this.origin);
            var n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function (t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function (t) {
            var e = bt.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (bt.copy(this.direction).multiplyScalar(e).add(this.origin), bt.distanceToSquared(t))
        },
        distanceSqToSegment: function (t, e, n, i) {
            wt.copy(t).add(e).multiplyScalar(.5), Mt.copy(e).sub(t).normalize(), St.copy(this.origin).sub(wt);
            var r, o, a, s, l = .5 * t.distanceTo(e),
                c = -this.direction.dot(Mt),
                h = St.dot(this.direction),
                u = -St.dot(Mt),
                d = St.lengthSq(),
                p = Math.abs(1 - c * c);
            if (p > 0)
                if (o = c * h - u, s = l * p, (r = c * u - h) >= 0)
                    if (o >= -s)
                        if (o <= s) {
                            var f = 1 / p;
                            a = (r *= f) * (r + c * (o *= f) + 2 * h) + o * (c * r + o + 2 * u) + d
                        } else o = l, a = -(r = Math.max(0, -(c * o + h))) * r + o * (o + 2 * u) + d;
            else o = -l, a = -(r = Math.max(0, -(c * o + h))) * r + o * (o + 2 * u) + d;
            else o <= -s ? a = -(r = Math.max(0, -(-c * l + h))) * r + (o = r > 0 ? -l : Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + d : o <= s ? (r = 0, a = (o = Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + d) : a = -(r = Math.max(0, -(c * l + h))) * r + (o = r > 0 ? l : Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + d;
            else o = c > 0 ? -l : l, a = -(r = Math.max(0, -(c * o + h))) * r + o * (o + 2 * u) + d;
            return n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy(Mt).multiplyScalar(o).add(wt), a
        },
        intersectSphere: function (t, e) {
            bt.subVectors(t.center, this.origin);
            var n = bt.dot(this.direction),
                i = bt.dot(bt) - n * n,
                r = t.radius * t.radius;
            if (i > r) return null;
            var o = Math.sqrt(r - i),
                a = n - o,
                s = n + o;
            return a < 0 && s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e)
        },
        intersectsSphere: function (t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        },
        distanceToPlane: function (t) {
            var e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        },
        intersectPlane: function (t, e) {
            var n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        },
        intersectsPlane: function (t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function (t, e) {
            var n, i, r, o, a, s, l = 1 / this.direction.x,
                c = 1 / this.direction.y,
                h = 1 / this.direction.z,
                u = this.origin;
            return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, o = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, o = (t.min.y - u.y) * c), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), h >= 0 ? (a = (t.min.z - u.z) * h, s = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, s = (t.min.z - u.z) * h), n > s || a > i ? null : ((a > n || n != n) && (n = a), (s < i || i != i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        },
        intersectsBox: function (t) {
            return null !== this.intersectBox(t, bt)
        },
        intersectTriangle: function (t, e, n, i, r) {
            Tt.subVectors(e, t), Et.subVectors(n, t), At.crossVectors(Tt, Et);
            var o, a = this.direction.dot(At);
            if (a > 0) {
                if (i) return null;
                o = 1
            } else {
                if (!(a < 0)) return null;
                o = -1, a = -a
            }
            St.subVectors(this.origin, t);
            var s = o * this.direction.dot(Et.crossVectors(St, Et));
            if (s < 0) return null;
            var l = o * this.direction.dot(Tt.cross(St));
            if (l < 0) return null;
            if (s + l > a) return null;
            var c = -o * St.dot(At);
            return c < 0 ? null : this.at(c / a, r)
        },
        applyMatrix4: function (t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        },
        equals: function (t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    });
    var Lt = new P,
        Pt = new P,
        Rt = new x;

    function Ot(t, e) {
        this.normal = void 0 !== t ? t : new P(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }
    Object.assign(Ot.prototype, {
        isPlane: !0,
        set: function (t, e) {
            return this.normal.copy(t), this.constant = e, this
        },
        setComponents: function (t, e, n, i) {
            return this.normal.set(t, e, n), this.constant = i, this
        },
        setFromNormalAndCoplanarPoint: function (t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        },
        setFromCoplanarPoints: function (t, e, n) {
            var i = Lt.subVectors(n, e).cross(Pt.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        },
        normalize: function () {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        },
        negate: function () {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function (t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function (t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new P), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function (t, e) {
            void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new P);
            var n = t.delta(Lt),
                i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
            var r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
        },
        intersectsLine: function (t) {
            var e = this.distanceToPoint(t.start),
                n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        },
        intersectsBox: function (t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function (t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function (t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new P), t.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function (t, e) {
            var n = e || Rt.getNormalMatrix(t),
                i = this.coplanarPoint(Lt).applyMatrix4(t),
                r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r), this
        },
        translate: function (t) {
            return this.constant -= t.dot(this.normal), this
        },
        equals: function (t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    });
    var Dt = new P,
        It = new P,
        Nt = new P,
        kt = new P,
        zt = new P,
        Bt = new P,
        Ft = new P,
        Ut = new P,
        Ht = new P,
        Gt = new P;

    function Vt(t, e, n) {
        this.a = void 0 !== t ? t : new P, this.b = void 0 !== e ? e : new P, this.c = void 0 !== n ? n : new P
    }
    Object.assign(Vt, {
        getNormal: function (t, e, n, i) {
            void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new P), i.subVectors(n, e), Dt.subVectors(t, e), i.cross(Dt);
            var r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        },
        getBarycoord: function (t, e, n, i, r) {
            Dt.subVectors(i, e), It.subVectors(n, e), Nt.subVectors(t, e);
            var o = Dt.dot(Dt),
                a = Dt.dot(It),
                s = Dt.dot(Nt),
                l = It.dot(It),
                c = It.dot(Nt),
                h = o * l - a * a;
            if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new P), 0 === h) return r.set(-2, -1, -1);
            var u = 1 / h,
                d = (l * s - a * c) * u,
                p = (o * c - a * s) * u;
            return r.set(1 - d - p, p, d)
        },
        containsPoint: function (t, e, n, i) {
            return Vt.getBarycoord(t, e, n, i, kt), kt.x >= 0 && kt.y >= 0 && kt.x + kt.y <= 1
        },
        getUV: function (t, e, n, i, r, o, a, s) {
            return this.getBarycoord(t, e, n, i, kt), s.set(0, 0), s.addScaledVector(r, kt.x), s.addScaledVector(o, kt.y), s.addScaledVector(a, kt.z), s
        },
        isFrontFacing: function (t, e, n, i) {
            return Dt.subVectors(n, e), It.subVectors(t, e), Dt.cross(It).dot(i) < 0
        }
    }), Object.assign(Vt.prototype, {
        set: function (t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
        },
        setFromPointsAndIndices: function (t, e, n, i) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        },
        getArea: function () {
            return Dt.subVectors(this.c, this.b), It.subVectors(this.a, this.b), .5 * Dt.cross(It).length()
        },
        getMidpoint: function (t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new P), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function (t) {
            return Vt.getNormal(this.a, this.b, this.c, t)
        },
        getPlane: function (t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Ot), t.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function (t, e) {
            return Vt.getBarycoord(t, this.a, this.b, this.c, e)
        },
        getUV: function (t, e, n, i, r) {
            return Vt.getUV(t, this.a, this.b, this.c, e, n, i, r)
        },
        containsPoint: function (t) {
            return Vt.containsPoint(t, this.a, this.b, this.c)
        },
        isFrontFacing: function (t) {
            return Vt.isFrontFacing(this.a, this.b, this.c, t)
        },
        intersectsBox: function (t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: function (t, e) {
            void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new P);
            var n, i, r = this.a,
                o = this.b,
                a = this.c;
            zt.subVectors(o, r), Bt.subVectors(a, r), Ut.subVectors(t, r);
            var s = zt.dot(Ut),
                l = Bt.dot(Ut);
            if (s <= 0 && l <= 0) return e.copy(r);
            Ht.subVectors(t, o);
            var c = zt.dot(Ht),
                h = Bt.dot(Ht);
            if (c >= 0 && h <= c) return e.copy(o);
            var u = s * h - c * l;
            if (u <= 0 && s >= 0 && c <= 0) return n = s / (s - c), e.copy(r).addScaledVector(zt, n);
            Gt.subVectors(t, a);
            var d = zt.dot(Gt),
                p = Bt.dot(Gt);
            if (p >= 0 && d <= p) return e.copy(a);
            var f = d * l - s * p;
            if (f <= 0 && l >= 0 && p <= 0) return i = l / (l - p), e.copy(r).addScaledVector(Bt, i);
            var m = c * p - d * h;
            if (m <= 0 && h - c >= 0 && d - p >= 0) return Ft.subVectors(a, o), i = (h - c) / (h - c + (d - p)), e.copy(o).addScaledVector(Ft, i);
            var v = 1 / (m + f + u);
            return n = f * v, i = u * v, e.copy(r).addScaledVector(zt, n).addScaledVector(Bt, i)
        },
        equals: function (t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    });
    var jt = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        Wt = {
            h: 0,
            s: 0,
            l: 0
        },
        qt = {
            h: 0,
            s: 0,
            l: 0
        };

    function Xt(t, e, n) {
        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    }

    function Yt(t, e, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }

    function Jt(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }

    function Zt(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }

    function Qt(t, e, n, i, r, o) {
        this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new P, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Xt, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
    }
    Object.assign(Xt.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function (t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        },
        setScalar: function (t) {
            return this.r = t, this.g = t, this.b = t, this
        },
        setHex: function (t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        },
        setRGB: function (t, e, n) {
            return this.r = t, this.g = e, this.b = n, this
        },
        setHSL: function (t, e, n) {
            if (t = y.euclideanModulo(t, 1), e = y.clamp(e, 0, 1), n = y.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
            else {
                var i = n <= .5 ? n * (1 + e) : n + e - n * e,
                    r = 2 * n - i;
                this.r = Yt(r, i, t + 1 / 3), this.g = Yt(r, i, t), this.b = Yt(r, i, t - 1 / 3)
            }
            return this
        },
        setStyle: function (t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var i, r = n[1],
                    o = n[2];
                switch (r) {
                    case "rgb":
                    case "rgba":
                        if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                        if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                            var a = parseFloat(i[1]) / 360,
                                s = parseInt(i[2], 10) / 100,
                                l = parseInt(i[3], 10) / 100;
                            return e(i[5]), this.setHSL(a, s, l)
                        }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var c = n[1],
                    h = c.length;
                if (3 === h) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                if (6 === h) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
            }
            return t && t.length > 0 ? this.setColorName(t) : this
        },
        setColorName: function (t) {
            var e = jt[t];
            return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
        },
        clone: function () {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function (t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        },
        copyGammaToLinear: function (t, e) {
            return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        },
        copyLinearToGamma: function (t, e) {
            void 0 === e && (e = 2);
            var n = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
        },
        convertGammaToLinear: function (t) {
            return this.copyGammaToLinear(this, t), this
        },
        convertLinearToGamma: function (t) {
            return this.copyLinearToGamma(this, t), this
        },
        copySRGBToLinear: function (t) {
            return this.r = Jt(t.r), this.g = Jt(t.g), this.b = Jt(t.b), this
        },
        copyLinearToSRGB: function (t) {
            return this.r = Zt(t.r), this.g = Zt(t.g), this.b = Zt(t.b), this
        },
        convertSRGBToLinear: function () {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function () {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function (t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                h: 0,
                s: 0,
                l: 0
            });
            var e, n, i = this.r,
                r = this.g,
                o = this.b,
                a = Math.max(i, r, o),
                s = Math.min(i, r, o),
                l = (s + a) / 2;
            if (s === a) e = 0, n = 0;
            else {
                var c = a - s;
                switch (n = l <= .5 ? c / (a + s) : c / (2 - a - s), a) {
                    case i:
                        e = (r - o) / c + (r < o ? 6 : 0);
                        break;
                    case r:
                        e = (o - i) / c + 2;
                        break;
                    case o:
                        e = (i - r) / c + 4
                }
                e /= 6
            }
            return t.h = e, t.s = n, t.l = l, t
        },
        getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function (t, e, n) {
            return this.getHSL(Wt), Wt.h += t, Wt.s += e, Wt.l += n, this.setHSL(Wt.h, Wt.s, Wt.l), this
        },
        add: function (t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        },
        addColors: function (t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        },
        addScalar: function (t) {
            return this.r += t, this.g += t, this.b += t, this
        },
        sub: function (t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
        },
        multiply: function (t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        },
        multiplyScalar: function (t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        },
        lerp: function (t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        },
        lerpHSL: function (t, e) {
            this.getHSL(Wt), t.getHSL(qt);
            var n = y.lerp(Wt.h, qt.h, e),
                i = y.lerp(Wt.s, qt.s, e),
                r = y.lerp(Wt.l, qt.l, e);
            return this.setHSL(n, i, r), this
        },
        equals: function (t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        },
        toJSON: function () {
            return this.getHex()
        }
    }), Xt.NAMES = jt, Object.assign(Qt.prototype, {
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
            for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    });
    var Kt = 0;

    function $t() {
        Object.defineProperty(this, "id", {
            value: Kt++
        }), this.uuid = y.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
    }

    function te(t) {
        $t.call(this), this.type = "MeshBasicMaterial", this.color = new Xt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
    }
    $t.prototype = Object.assign(Object.create(f.prototype), {
        constructor: $t,
        isMaterial: !0,
        onBeforeCompile: function () {},
        setValues: function (t) {
            if (void 0 !== t)
                for (var e in t) {
                    var n = t[e];
                    if (void 0 !== n)
                        if ("shading" !== e) {
                            var i = this[e];
                            void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                    else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
        },
        toJSON: function (t) {
            var e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function i(t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    delete i.metadata, e.push(i)
                }
                return e
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                var r = i(t.textures),
                    o = i(t.images);
                r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o)
            }
            return n
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
            var e = t.clippingPlanes,
                n = null;
            if (null !== e) {
                var i = e.length;
                n = new Array(i);
                for (var r = 0; r !== i; ++r) n[r] = e[r].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty($t.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), te.prototype = Object.create($t.prototype), te.prototype.constructor = te, te.prototype.isMeshBasicMaterial = !0, te.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    };
    var ee = new P;

    function ne(t, e, n) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function ie(t, e, n) {
        ne.call(this, new Int8Array(t), e, n)
    }

    function re(t, e, n) {
        ne.call(this, new Uint8Array(t), e, n)
    }

    function oe(t, e, n) {
        ne.call(this, new Uint8ClampedArray(t), e, n)
    }

    function ae(t, e, n) {
        ne.call(this, new Int16Array(t), e, n)
    }

    function se(t, e, n) {
        ne.call(this, new Uint16Array(t), e, n)
    }

    function le(t, e, n) {
        ne.call(this, new Int32Array(t), e, n)
    }

    function ce(t, e, n) {
        ne.call(this, new Uint32Array(t), e, n)
    }

    function he(t, e, n) {
        ne.call(this, new Float32Array(t), e, n)
    }

    function ue(t, e, n) {
        ne.call(this, new Float64Array(t), e, n)
    }

    function de() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function pe(t) {
        if (0 === t.length) return -1 / 0;
        for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
        return e
    }
    Object.defineProperty(ne.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), Object.assign(ne.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function () {},
        setUsage: function (t) {
            return this.usage = t, this
        },
        copy: function (t) {
            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
        },
        copyAt: function (t, e, n) {
            t *= this.itemSize, n *= e.itemSize;
            for (var i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        },
        copyArray: function (t) {
            return this.array.set(t), this
        },
        copyColorsArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), o = new Xt), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b
            }
            return this
        },
        copyVector2sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), o = new _), e[n++] = o.x, e[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), o = new P), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), o = new S), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w
            }
            return this
        },
        applyMatrix3: function (t) {
            for (var e = 0, n = this.count; e < n; e++) ee.x = this.getX(e), ee.y = this.getY(e), ee.z = this.getZ(e), ee.applyMatrix3(t), this.setXYZ(e, ee.x, ee.y, ee.z);
            return this
        },
        applyMatrix4: function (t) {
            for (var e = 0, n = this.count; e < n; e++) ee.x = this.getX(e), ee.y = this.getY(e), ee.z = this.getZ(e), ee.applyMatrix4(t), this.setXYZ(e, ee.x, ee.y, ee.z);
            return this
        },
        applyNormalMatrix: function (t) {
            for (var e = 0, n = this.count; e < n; e++) ee.x = this.getX(e), ee.y = this.getY(e), ee.z = this.getZ(e), ee.applyNormalMatrix(t), this.setXYZ(e, ee.x, ee.y, ee.z);
            return this
        },
        transformDirection: function (t) {
            for (var e = 0, n = this.count; e < n; e++) ee.x = this.getX(e), ee.y = this.getY(e), ee.z = this.getZ(e), ee.transformDirection(t), this.setXYZ(e, ee.x, ee.y, ee.z);
            return this
        },
        set: function (t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        getX: function (t) {
            return this.array[t * this.itemSize]
        },
        setX: function (t, e) {
            return this.array[t * this.itemSize] = e, this
        },
        getY: function (t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function (t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        },
        getZ: function (t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function (t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        },
        getW: function (t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function (t, e) {
            return this.array[t * this.itemSize + 3] = e, this
        },
        setXY: function (t, e, n) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
        },
        setXYZ: function (t, e, n, i) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
        },
        setXYZW: function (t, e, n, i, r) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
        },
        onUpload: function (t) {
            return this.onUploadCallback = t, this
        },
        clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function () {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), ie.prototype = Object.create(ne.prototype), ie.prototype.constructor = ie, re.prototype = Object.create(ne.prototype), re.prototype.constructor = re, oe.prototype = Object.create(ne.prototype), oe.prototype.constructor = oe, ae.prototype = Object.create(ne.prototype), ae.prototype.constructor = ae, se.prototype = Object.create(ne.prototype), se.prototype.constructor = se, le.prototype = Object.create(ne.prototype), le.prototype.constructor = le, ce.prototype = Object.create(ne.prototype), ce.prototype.constructor = ce, he.prototype = Object.create(ne.prototype), he.prototype.constructor = he, ue.prototype = Object.create(ne.prototype), ue.prototype.constructor = ue, Object.assign(de.prototype, {
        computeGroups: function (t) {
            for (var e, n = [], i = void 0, r = t.faces, o = 0; o < r.length; o++) {
                var a = r[o];
                a.materialIndex !== i && (i = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), e = {
                    start: 3 * o,
                    materialIndex: i
                })
            }
            void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), this.groups = n
        },
        fromGeometry: function (t) {
            var e, n = t.faces,
                i = t.vertices,
                r = t.faceVertexUvs,
                o = r[0] && r[0].length > 0,
                a = r[1] && r[1].length > 0,
                s = t.morphTargets,
                l = s.length;
            if (l > 0) {
                e = [];
                for (var c = 0; c < l; c++) e[c] = {
                    name: s[c].name,
                    data: []
                };
                this.morphTargets.position = e
            }
            var h, u = t.morphNormals,
                d = u.length;
            if (d > 0) {
                h = [];
                for (c = 0; c < d; c++) h[c] = {
                    name: u[c].name,
                    data: []
                };
                this.morphTargets.normal = h
            }
            var p = t.skinIndices,
                f = t.skinWeights,
                m = p.length === i.length,
                v = f.length === i.length;
            i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (c = 0; c < n.length; c++) {
                var g = n[c];
                this.vertices.push(i[g.a], i[g.b], i[g.c]);
                var y = g.vertexNormals;
                if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                else {
                    var x = g.normal;
                    this.normals.push(x, x, x)
                }
                var b, w = g.vertexColors;
                if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
                else {
                    var M = g.color;
                    this.colors.push(M, M, M)
                }
                if (!0 === o) void 0 !== (b = r[0][c]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", c), this.uvs.push(new _, new _, new _));
                if (!0 === a) void 0 !== (b = r[1][c]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", c), this.uvs2.push(new _, new _, new _));
                for (var S = 0; S < l; S++) {
                    var T = s[S].vertices;
                    e[S].data.push(T[g.a], T[g.b], T[g.c])
                }
                for (S = 0; S < d; S++) {
                    var E = u[S].vertexNormals[c];
                    h[S].data.push(E.a, E.b, E.c)
                }
                m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
            }
            return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        }
    });
    var fe = 1,
        me = new B,
        ve = new nt,
        ge = new P,
        ye = new gt,
        _e = new gt,
        xe = new P;

    function be() {
        Object.defineProperty(this, "id", {
            value: fe += 2
        }), this.uuid = y.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    be.prototype = Object.assign(Object.create(f.prototype), {
        constructor: be,
        isBufferGeometry: !0,
        getIndex: function () {
            return this.index
        },
        setIndex: function (t) {
            Array.isArray(t) ? this.index = new(pe(t) > 65535 ? ce : se)(t, 1) : this.index = t
        },
        getAttribute: function (t) {
            return this.attributes[t]
        },
        setAttribute: function (t, e) {
            return this.attributes[t] = e, this
        },
        deleteAttribute: function (t) {
            return delete this.attributes[t], this
        },
        addGroup: function (t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function () {
            this.groups = []
        },
        setDrawRange: function (t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        },
        applyMatrix4: function (t) {
            var e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
            var n = this.attributes.normal;
            if (void 0 !== n) {
                var i = (new x).getNormalMatrix(t);
                n.applyNormalMatrix(i), n.needsUpdate = !0
            }
            var r = this.attributes.tangent;
            return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function (t) {
            return me.makeRotationX(t), this.applyMatrix4(me), this
        },
        rotateY: function (t) {
            return me.makeRotationY(t), this.applyMatrix4(me), this
        },
        rotateZ: function (t) {
            return me.makeRotationZ(t), this.applyMatrix4(me), this
        },
        translate: function (t, e, n) {
            return me.makeTranslation(t, e, n), this.applyMatrix4(me), this
        },
        scale: function (t, e, n) {
            return me.makeScale(t, e, n), this.applyMatrix4(me), this
        },
        lookAt: function (t) {
            return ve.lookAt(t), ve.updateMatrix(), this.applyMatrix4(ve.matrix), this
        },
        center: function () {
            return this.computeBoundingBox(), this.boundingBox.getCenter(ge).negate(), this.translate(ge.x, ge.y, ge.z), this
        },
        setFromObject: function (t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                var n = new he(3 * e.vertices.length, 3),
                    i = new he(3 * e.colors.length, 3);
                if (this.setAttribute("position", n.copyVector3sArray(e.vertices)), this.setAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    var r = new he(e.lineDistances.length, 1);
                    this.setAttribute("lineDistance", r.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function (t) {
            for (var e = [], n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.push(r.x, r.y, r.z || 0)
            }
            return this.setAttribute("position", new he(e, 3)), this
        },
        updateFromObject: function (t) {
            var e, n = t.geometry;
            if (t.isMesh) {
                var i = n.__directGeometry;
                if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n);
                i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i
            }
            return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
        },
        fromGeometry: function (t) {
            return t.__directGeometry = (new de).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function (t) {
            var e = new Float32Array(3 * t.vertices.length);
            if (this.setAttribute("position", new ne(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                var n = new Float32Array(3 * t.normals.length);
                this.setAttribute("normal", new ne(n, 3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                var i = new Float32Array(3 * t.colors.length);
                this.setAttribute("color", new ne(i, 3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                var r = new Float32Array(2 * t.uvs.length);
                this.setAttribute("uv", new ne(r, 2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                var o = new Float32Array(2 * t.uvs2.length);
                this.setAttribute("uv2", new ne(o, 2).copyVector2sArray(t.uvs2))
            }
            for (var a in this.groups = t.groups, t.morphTargets) {
                for (var s = [], l = t.morphTargets[a], c = 0, h = l.length; c < h; c++) {
                    var u = l[c],
                        d = new he(3 * u.data.length, 3);
                    d.name = u.name, s.push(d.copyVector3sArray(u.data))
                }
                this.morphAttributes[a] = s
            }
            if (t.skinIndices.length > 0) {
                var p = new he(4 * t.skinIndices.length, 4);
                this.setAttribute("skinIndex", p.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                var f = new he(4 * t.skinWeights.length, 4);
                this.setAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new gt);
            var t = this.attributes.position,
                e = this.morphAttributes.position;
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t), e)
                    for (var n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        ye.setFromBufferAttribute(r), this.morphTargetsRelative ? (xe.addVectors(this.boundingBox.min, ye.min), this.boundingBox.expandByPoint(xe), xe.addVectors(this.boundingBox.max, ye.max), this.boundingBox.expandByPoint(xe)) : (this.boundingBox.expandByPoint(ye.min), this.boundingBox.expandByPoint(ye.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new xt);
            var t = this.attributes.position,
                e = this.morphAttributes.position;
            if (t) {
                var n = this.boundingSphere.center;
                if (ye.setFromBufferAttribute(t), e)
                    for (var i = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        _e.setFromBufferAttribute(o), this.morphTargetsRelative ? (xe.addVectors(ye.min, _e.min), ye.expandByPoint(xe), xe.addVectors(ye.max, _e.max), ye.expandByPoint(xe)) : (ye.expandByPoint(_e.min), ye.expandByPoint(_e.max))
                    }
                ye.getCenter(n);
                var a = 0;
                for (i = 0, r = t.count; i < r; i++) xe.fromBufferAttribute(t, i), a = Math.max(a, n.distanceToSquared(xe));
                if (e)
                    for (i = 0, r = e.length; i < r; i++) {
                        o = e[i];
                        for (var s = this.morphTargetsRelative, l = 0, c = o.count; l < c; l++) xe.fromBufferAttribute(o, l), s && (ge.fromBufferAttribute(t, l), xe.add(ge)), a = Math.max(a, n.distanceToSquared(xe))
                    }
                this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
            var t = this.index,
                e = this.attributes;
            if (e.position) {
                var n = e.position.array;
                if (void 0 === e.normal) this.setAttribute("normal", new ne(new Float32Array(n.length), 3));
                else
                    for (var i = e.normal.array, r = 0, o = i.length; r < o; r++) i[r] = 0;
                var a, s, l, c = e.normal.array,
                    h = new P,
                    u = new P,
                    d = new P,
                    p = new P,
                    f = new P;
                if (t) {
                    var m = t.array;
                    for (r = 0, o = t.count; r < o; r += 3) a = 3 * m[r + 0], s = 3 * m[r + 1], l = 3 * m[r + 2], h.fromArray(n, a), u.fromArray(n, s), d.fromArray(n, l), p.subVectors(d, u), f.subVectors(h, u), p.cross(f), c[a] += p.x, c[a + 1] += p.y, c[a + 2] += p.z, c[s] += p.x, c[s + 1] += p.y, c[s + 2] += p.z, c[l] += p.x, c[l + 1] += p.y, c[l + 2] += p.z
                } else
                    for (r = 0, o = n.length; r < o; r += 9) h.fromArray(n, r), u.fromArray(n, r + 3), d.fromArray(n, r + 6), p.subVectors(d, u), f.subVectors(h, u), p.cross(f), c[r] = p.x, c[r + 1] = p.y, c[r + 2] = p.z, c[r + 3] = p.x, c[r + 4] = p.y, c[r + 5] = p.z, c[r + 6] = p.x, c[r + 7] = p.y, c[r + 8] = p.z;
                this.normalizeNormals(), e.normal.needsUpdate = !0
            }
        },
        merge: function (t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n = this.attributes;
                for (var i in n)
                    if (void 0 !== t.attributes[i])
                        for (var r = n[i].array, o = t.attributes[i], a = o.array, s = o.itemSize * e, l = Math.min(a.length, r.length - s), c = 0, h = s; c < l; c++, h++) r[h] = a[c];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        },
        normalizeNormals: function () {
            for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++) xe.x = t.getX(e), xe.y = t.getY(e), xe.z = t.getZ(e), xe.normalize(), t.setXYZ(e, xe.x, xe.y, xe.z)
        },
        toNonIndexed: function () {
            function t(t, e) {
                for (var n = t.array, i = t.itemSize, r = new n.constructor(e.length * i), o = 0, a = 0, s = 0, l = e.length; s < l; s++) {
                    o = e[s] * i;
                    for (var c = 0; c < i; c++) r[a++] = n[o++]
                }
                return new ne(r, i)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var e = new be,
                n = this.index.array,
                i = this.attributes;
            for (var r in i) {
                var o = t(i[r], n);
                e.setAttribute(r, o)
            }
            var a = this.morphAttributes;
            for (r in a) {
                for (var s = [], l = a[r], c = 0, h = l.length; c < h; c++) {
                    o = t(l[c], n);
                    s.push(o)
                }
                e.morphAttributes[r] = s
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            for (var u = this.groups, d = (c = 0, u.length); c < d; c++) {
                var p = u[c];
                e.addGroup(p.start, p.count, p.materialIndex)
            }
            return e
        },
        toJSON: function () {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var i = this.index;
            null !== i && (t.data.index = {
                type: i.array.constructor.name,
                array: Array.prototype.slice.call(i.array)
            });
            var r = this.attributes;
            for (var n in r) {
                var o = (d = r[n]).toJSON();
                "" !== d.name && (o.name = d.name), t.data.attributes[n] = o
            }
            var a = {},
                s = !1;
            for (var n in this.morphAttributes) {
                for (var l = this.morphAttributes[n], c = [], h = 0, u = l.length; h < u; h++) {
                    var d;
                    o = (d = l[h]).toJSON();
                    "" !== d.name && (o.name = d.name), c.push(o)
                }
                c.length > 0 && (a[n] = c, s = !0)
            }
            s && (t.data.morphAttributes = a, t.data.morphTargetsRelative = this.morphTargetsRelative);
            var p = this.groups;
            p.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(p)));
            var f = this.boundingSphere;
            return null !== f && (t.data.boundingSphere = {
                center: f.center.toArray(),
                radius: f.radius
            }), t
        },
        clone: function () {
            return (new be).copy(this)
        },
        copy: function (t) {
            var e, n, i;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var r = t.index;
            null !== r && this.setIndex(r.clone());
            var o = t.attributes;
            for (e in o) {
                var a = o[e];
                this.setAttribute(e, a.clone())
            }
            var s = t.morphAttributes;
            for (e in s) {
                var l = [],
                    c = s[e];
                for (n = 0, i = c.length; n < i; n++) l.push(c[n].clone());
                this.morphAttributes[e] = l
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            var h = t.groups;
            for (n = 0, i = h.length; n < i; n++) {
                var u = h[n];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var d = t.boundingBox;
            null !== d && (this.boundingBox = d.clone());
            var p = t.boundingSphere;
            return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var we = new B,
        Me = new Ct,
        Se = new xt,
        Te = new P,
        Ee = new P,
        Ae = new P,
        Ce = new P,
        Le = new P,
        Pe = new P,
        Re = new P,
        Oe = new P,
        De = new P,
        Ie = new _,
        Ne = new _,
        ke = new _,
        ze = new P,
        Be = new P;

    function Fe(t, e) {
        nt.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new be, this.material = void 0 !== e ? e : new te, this.updateMorphTargets()
    }

    function Ue(t, e, n, i, r, o, a, s) {
        if (null === (1 === e.side ? i.intersectTriangle(a, o, r, !0, s) : i.intersectTriangle(r, o, a, 2 !== e.side, s))) return null;
        Be.copy(s), Be.applyMatrix4(t.matrixWorld);
        var l = n.ray.origin.distanceTo(Be);
        return l < n.near || l > n.far ? null : {
            distance: l,
            point: Be.clone(),
            object: t
        }
    }

    function He(t, e, n, i, r, o, a, s, l, c, h, u) {
        Te.fromBufferAttribute(r, c), Ee.fromBufferAttribute(r, h), Ae.fromBufferAttribute(r, u);
        var d = t.morphTargetInfluences;
        if (e.morphTargets && o && d) {
            Re.set(0, 0, 0), Oe.set(0, 0, 0), De.set(0, 0, 0);
            for (var p = 0, f = o.length; p < f; p++) {
                var m = d[p],
                    v = o[p];
                0 !== m && (Ce.fromBufferAttribute(v, c), Le.fromBufferAttribute(v, h), Pe.fromBufferAttribute(v, u), a ? (Re.addScaledVector(Ce, m), Oe.addScaledVector(Le, m), De.addScaledVector(Pe, m)) : (Re.addScaledVector(Ce.sub(Te), m), Oe.addScaledVector(Le.sub(Ee), m), De.addScaledVector(Pe.sub(Ae), m)))
            }
            Te.add(Re), Ee.add(Oe), Ae.add(De)
        }
        t.isSkinnedMesh && (t.boneTransform(c, Te), t.boneTransform(h, Ee), t.boneTransform(u, Ae));
        var g = Ue(t, e, n, i, Te, Ee, Ae, ze);
        if (g) {
            s && (Ie.fromBufferAttribute(s, c), Ne.fromBufferAttribute(s, h), ke.fromBufferAttribute(s, u), g.uv = Vt.getUV(ze, Te, Ee, Ae, Ie, Ne, ke, new _)), l && (Ie.fromBufferAttribute(l, c), Ne.fromBufferAttribute(l, h), ke.fromBufferAttribute(l, u), g.uv2 = Vt.getUV(ze, Te, Ee, Ae, Ie, Ne, ke, new _));
            var y = new Qt(c, h, u);
            Vt.getNormal(Te, Ee, Ae, y.normal), g.face = y
        }
        return g
    }
    Fe.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: Fe,
        isMesh: !0,
        copy: function (t) {
            return nt.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
        },
        updateMorphTargets: function () {
            var t, e, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes,
                    o = Object.keys(r);
                if (o.length > 0) {
                    var a = r[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) n = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                }
            } else {
                var s = i.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function (t, e) {
            var n, i = this.geometry,
                r = this.material,
                o = this.matrixWorld;
            if (void 0 !== r && (null === i.boundingSphere && i.computeBoundingSphere(), Se.copy(i.boundingSphere), Se.applyMatrix4(o), !1 !== t.ray.intersectsSphere(Se) && (we.getInverse(o), Me.copy(t.ray).applyMatrix4(we), null === i.boundingBox || !1 !== Me.intersectsBox(i.boundingBox))))
                if (i.isBufferGeometry) {
                    var a, s, l, c, h, u, d, p, f, m = i.index,
                        v = i.attributes.position,
                        g = i.morphAttributes.position,
                        y = i.morphTargetsRelative,
                        x = i.attributes.uv,
                        b = i.attributes.uv2,
                        w = i.groups,
                        M = i.drawRange;
                    if (null !== m)
                        if (Array.isArray(r))
                            for (c = 0, u = w.length; c < u; c++)
                                for (f = r[(p = w[c]).materialIndex], h = Math.max(p.start, M.start), d = Math.min(p.start + p.count, M.start + M.count); h < d; h += 3) a = m.getX(h), s = m.getX(h + 1), l = m.getX(h + 2), (n = He(this, f, t, Me, v, g, y, x, b, a, s, l)) && (n.faceIndex = Math.floor(h / 3), n.face.materialIndex = p.materialIndex, e.push(n));
                        else
                            for (c = Math.max(0, M.start), u = Math.min(m.count, M.start + M.count); c < u; c += 3) a = m.getX(c), s = m.getX(c + 1), l = m.getX(c + 2), (n = He(this, r, t, Me, v, g, y, x, b, a, s, l)) && (n.faceIndex = Math.floor(c / 3), e.push(n));
                    else if (void 0 !== v)
                        if (Array.isArray(r))
                            for (c = 0, u = w.length; c < u; c++)
                                for (f = r[(p = w[c]).materialIndex], h = Math.max(p.start, M.start), d = Math.min(p.start + p.count, M.start + M.count); h < d; h += 3)(n = He(this, f, t, Me, v, g, y, x, b, a = h, s = h + 1, l = h + 2)) && (n.faceIndex = Math.floor(h / 3), n.face.materialIndex = p.materialIndex, e.push(n));
                        else
                            for (c = Math.max(0, M.start), u = Math.min(v.count, M.start + M.count); c < u; c += 3)(n = He(this, r, t, Me, v, g, y, x, b, a = c, s = c + 1, l = c + 2)) && (n.faceIndex = Math.floor(c / 3), e.push(n))
                } else if (i.isGeometry) {
                var S, T, E, A, C = Array.isArray(r),
                    L = i.vertices,
                    P = i.faces,
                    R = i.faceVertexUvs[0];
                R.length > 0 && (A = R);
                for (var O = 0, D = P.length; O < D; O++) {
                    var I = P[O],
                        N = C ? r[I.materialIndex] : r;
                    if (void 0 !== N && (S = L[I.a], T = L[I.b], E = L[I.c], n = Ue(this, N, t, Me, S, T, E, ze))) {
                        if (A && A[O]) {
                            var k = A[O];
                            Ie.copy(k[0]), Ne.copy(k[1]), ke.copy(k[2]), n.uv = Vt.getUV(ze, S, T, E, Ie, Ne, ke, new _)
                        }
                        n.face = I, n.faceIndex = O, e.push(n)
                    }
                }
            }
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var Ge = 0,
        Ve = new B,
        je = new nt,
        We = new P;

    function qe() {
        Object.defineProperty(this, "id", {
            value: Ge += 2
        }), this.uuid = y.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }
    qe.prototype = Object.assign(Object.create(f.prototype), {
        constructor: qe,
        isGeometry: !0,
        applyMatrix4: function (t) {
            for (var e = (new x).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                this.vertices[n].applyMatrix4(t)
            }
            for (n = 0, i = this.faces.length; n < i; n++) {
                var r = this.faces[n];
                r.normal.applyMatrix3(e).normalize();
                for (var o = 0, a = r.vertexNormals.length; o < a; o++) r.vertexNormals[o].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function (t) {
            return Ve.makeRotationX(t), this.applyMatrix4(Ve), this
        },
        rotateY: function (t) {
            return Ve.makeRotationY(t), this.applyMatrix4(Ve), this
        },
        rotateZ: function (t) {
            return Ve.makeRotationZ(t), this.applyMatrix4(Ve), this
        },
        translate: function (t, e, n) {
            return Ve.makeTranslation(t, e, n), this.applyMatrix4(Ve), this
        },
        scale: function (t, e, n) {
            return Ve.makeScale(t, e, n), this.applyMatrix4(Ve), this
        },
        lookAt: function (t) {
            return je.lookAt(t), je.updateMatrix(), this.applyMatrix4(je.matrix), this
        },
        fromBufferGeometry: function (t) {
            var e = this,
                n = null !== t.index ? t.index.array : void 0,
                i = t.attributes;
            if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
            var r = i.position.array,
                o = void 0 !== i.normal ? i.normal.array : void 0,
                a = void 0 !== i.color ? i.color.array : void 0,
                s = void 0 !== i.uv ? i.uv.array : void 0,
                l = void 0 !== i.uv2 ? i.uv2.array : void 0;
            void 0 !== l && (this.faceVertexUvs[1] = []);
            for (var c = 0; c < r.length; c += 3) e.vertices.push((new P).fromArray(r, c)), void 0 !== a && e.colors.push((new Xt).fromArray(a, c));

            function h(t, n, i, r) {
                var c = void 0 === a ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                    h = new Qt(t, n, i, void 0 === o ? [] : [(new P).fromArray(o, 3 * t), (new P).fromArray(o, 3 * n), (new P).fromArray(o, 3 * i)], c, r);
                e.faces.push(h), void 0 !== s && e.faceVertexUvs[0].push([(new _).fromArray(s, 2 * t), (new _).fromArray(s, 2 * n), (new _).fromArray(s, 2 * i)]), void 0 !== l && e.faceVertexUvs[1].push([(new _).fromArray(l, 2 * t), (new _).fromArray(l, 2 * n), (new _).fromArray(l, 2 * i)])
            }
            var u = t.groups;
            if (u.length > 0)
                for (c = 0; c < u.length; c++)
                    for (var d = u[c], p = d.start, f = p, m = p + d.count; f < m; f += 3) void 0 !== n ? h(n[f], n[f + 1], n[f + 2], d.materialIndex) : h(f, f + 1, f + 2, d.materialIndex);
            else if (void 0 !== n)
                for (c = 0; c < n.length; c += 3) h(n[c], n[c + 1], n[c + 2]);
            else
                for (c = 0; c < r.length / 3; c += 3) h(c, c + 1, c + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        },
        center: function () {
            return this.computeBoundingBox(), this.boundingBox.getCenter(We).negate(), this.translate(We.x, We.y, We.z), this
        },
        normalize: function () {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center,
                e = this.boundingSphere.radius,
                n = 0 === e ? 1 : 1 / e,
                i = new B;
            return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this
        },
        computeFaceNormals: function () {
            for (var t = new P, e = new P, n = 0, i = this.faces.length; n < i; n++) {
                var r = this.faces[n],
                    o = this.vertices[r.a],
                    a = this.vertices[r.b],
                    s = this.vertices[r.c];
                t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), r.normal.copy(t)
            }
        },
        computeVertexNormals: function (t) {
            var e, n, i, r, o, a;
            for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) a[e] = new P;
            if (t) {
                var s, l, c, h = new P,
                    u = new P;
                for (i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], s = this.vertices[o.a], l = this.vertices[o.b], c = this.vertices[o.c], h.subVectors(c, l), u.subVectors(s, l), h.cross(u), a[o.a].add(h), a[o.b].add(h), a[o.c].add(h)
            } else
                for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) a[(o = this.faces[i]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
            for (e = 0, n = this.vertices.length; e < n; e++) a[e].normalize();
            for (i = 0, r = this.faces.length; i < r; i++) {
                var d = (o = this.faces[i]).vertexNormals;
                3 === d.length ? (d[0].copy(a[o.a]), d[1].copy(a[o.b]), d[2].copy(a[o.c])) : (d[0] = a[o.a].clone(), d[1] = a[o.b].clone(), d[2] = a[o.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function () {
            var t, e, n;
            for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                var i = (n = this.faces[t]).vertexNormals;
                3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function () {
            var t, e, n, i, r;
            for (n = 0, i = this.faces.length; n < i; n++)
                for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
            var o = new qe;
            for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                    var a = this.morphNormals[t].faceNormals,
                        s = this.morphNormals[t].vertexNormals;
                    for (n = 0, i = this.faces.length; n < i; n++) l = new P, c = {
                        a: new P,
                        b: new P,
                        c: new P
                    }, a.push(l), s.push(c)
                }
                var l, c, h = this.morphNormals[t];
                for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], l = h.faceNormals[n], c = h.vertexNormals[n], l.copy(r.normal), c.a.copy(r.vertexNormals[0]), c.b.copy(r.vertexNormals[1]), c.c.copy(r.vertexNormals[2])
            }
            for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new gt), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new xt), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function (t, e, n) {
            if (t && t.isGeometry) {
                var i, r = this.vertices.length,
                    o = this.vertices,
                    a = t.vertices,
                    s = this.faces,
                    l = t.faces,
                    c = this.colors,
                    h = t.colors;
                void 0 === n && (n = 0), void 0 !== e && (i = (new x).getNormalMatrix(e));
                for (var u = 0, d = a.length; u < d; u++) {
                    var p = a[u].clone();
                    void 0 !== e && p.applyMatrix4(e), o.push(p)
                }
                for (u = 0, d = h.length; u < d; u++) c.push(h[u].clone());
                for (u = 0, d = l.length; u < d; u++) {
                    var f, m, v, g = l[u],
                        y = g.vertexNormals,
                        _ = g.vertexColors;
                    (f = new Qt(g.a + r, g.b + r, g.c + r)).normal.copy(g.normal), void 0 !== i && f.normal.applyMatrix3(i).normalize();
                    for (var b = 0, w = y.length; b < w; b++) m = y[b].clone(), void 0 !== i && m.applyMatrix3(i).normalize(), f.vertexNormals.push(m);
                    f.color.copy(g.color);
                    for (b = 0, w = _.length; b < w; b++) v = _[b], f.vertexColors.push(v.clone());
                    f.materialIndex = g.materialIndex + n, s.push(f)
                }
                for (u = 0, d = t.faceVertexUvs.length; u < d; u++) {
                    var M = t.faceVertexUvs[u];
                    void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                    for (b = 0, w = M.length; b < w; b++) {
                        for (var S = M[b], T = [], E = 0, A = S.length; E < A; E++) T.push(S[E].clone());
                        this.faceVertexUvs[u].push(T)
                    }
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
        },
        mergeMesh: function (t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        },
        mergeVertices: function () {
            var t, e, n, i, r, o, a, s, l = {},
                c = [],
                h = [],
                u = Math.pow(10, 4);
            for (n = 0, i = this.vertices.length; n < i; n++) t = this.vertices[n], void 0 === l[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (l[e] = n, c.push(this.vertices[n]), h[n] = c.length - 1) : h[n] = h[l[e]];
            var d = [];
            for (n = 0, i = this.faces.length; n < i; n++) {
                (r = this.faces[n]).a = h[r.a], r.b = h[r.b], r.c = h[r.c], o = [r.a, r.b, r.c];
                for (var p = 0; p < 3; p++)
                    if (o[p] === o[(p + 1) % 3]) {
                        d.push(n);
                        break
                    }
            }
            for (n = d.length - 1; n >= 0; n--) {
                var f = d[n];
                for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - c.length;
            return this.vertices = c, m
        },
        setFromPoints: function (t) {
            this.vertices = [];
            for (var e = 0, n = t.length; e < n; e++) {
                var i = t[e];
                this.vertices.push(new P(i.x, i.y, i.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function () {
            for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
            t.sort((function (t, e) {
                return t.materialIndex - e.materialIndex
            }));
            var i, r, o = this.faceVertexUvs[0],
                a = this.faceVertexUvs[1];
            o && o.length === e && (i = []), a && a.length === e && (r = []);
            for (n = 0; n < e; n++) {
                var s = t[n]._id;
                i && i.push(o[s]), r && r.push(a[s])
            }
            i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function () {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            for (var i = [], r = 0; r < this.vertices.length; r++) {
                var o = this.vertices[r];
                i.push(o.x, o.y, o.z)
            }
            var a = [],
                s = [],
                l = {},
                c = [],
                h = {},
                u = [],
                d = {};
            for (r = 0; r < this.faces.length; r++) {
                var p = this.faces[r],
                    f = void 0 !== this.faceVertexUvs[0][r],
                    m = p.normal.length() > 0,
                    v = p.vertexNormals.length > 0,
                    g = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                    y = p.vertexColors.length > 0,
                    _ = 0;
                if (_ = M(_, 0, 0), _ = M(_, 1, !0), _ = M(_, 2, !1), _ = M(_, 3, f), _ = M(_, 4, m), _ = M(_, 5, v), _ = M(_, 6, g), _ = M(_, 7, y), a.push(_), a.push(p.a, p.b, p.c), a.push(p.materialIndex), f) {
                    var x = this.faceVertexUvs[0][r];
                    a.push(E(x[0]), E(x[1]), E(x[2]))
                }
                if (m && a.push(S(p.normal)), v) {
                    var b = p.vertexNormals;
                    a.push(S(b[0]), S(b[1]), S(b[2]))
                }
                if (g && a.push(T(p.color)), y) {
                    var w = p.vertexColors;
                    a.push(T(w[0]), T(w[1]), T(w[2]))
                }
            }

            function M(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }

            function S(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== l[e] || (l[e] = s.length / 3, s.push(t.x, t.y, t.z)), l[e]
            }

            function T(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== h[e] || (h[e] = c.length, c.push(t.getHex())), h[e]
            }

            function E(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== d[e] || (d[e] = u.length / 2, u.push(t.x, t.y)), d[e]
            }
            return t.data = {}, t.data.vertices = i, t.data.normals = s, c.length > 0 && (t.data.colors = c), u.length > 0 && (t.data.uvs = [u]), t.data.faces = a, t
        },
        clone: function () {
            return (new qe).copy(this)
        },
        copy: function (t) {
            var e, n, i, r, o, a;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var s = t.vertices;
            for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
            var l = t.colors;
            for (e = 0, n = l.length; e < n; e++) this.colors.push(l[e].clone());
            var c = t.faces;
            for (e = 0, n = c.length; e < n; e++) this.faces.push(c[e].clone());
            for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                var h = t.faceVertexUvs[e];
                for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = h.length; i < r; i++) {
                    var u = h[i],
                        d = [];
                    for (o = 0, a = u.length; o < a; o++) {
                        var p = u[o];
                        d.push(p.clone())
                    }
                    this.faceVertexUvs[e].push(d)
                }
            }
            var f = t.morphTargets;
            for (e = 0, n = f.length; e < n; e++) {
                var m = {};
                if (m.name = f[e].name, void 0 !== f[e].vertices)
                    for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++) m.vertices.push(f[e].vertices[i].clone());
                if (void 0 !== f[e].normals)
                    for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++) m.normals.push(f[e].normals[i].clone());
                this.morphTargets.push(m)
            }
            var v = t.morphNormals;
            for (e = 0, n = v.length; e < n; e++) {
                var g = {};
                if (void 0 !== v[e].vertexNormals)
                    for (g.vertexNormals = [], i = 0, r = v[e].vertexNormals.length; i < r; i++) {
                        var y = v[e].vertexNormals[i],
                            _ = {};
                        _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), g.vertexNormals.push(_)
                    }
                if (void 0 !== v[e].faceNormals)
                    for (g.faceNormals = [], i = 0, r = v[e].faceNormals.length; i < r; i++) g.faceNormals.push(v[e].faceNormals[i].clone());
                this.morphNormals.push(g)
            }
            var x = t.skinWeights;
            for (e = 0, n = x.length; e < n; e++) this.skinWeights.push(x[e].clone());
            var b = t.skinIndices;
            for (e = 0, n = b.length; e < n; e++) this.skinIndices.push(b[e].clone());
            var w = t.lineDistances;
            for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
            var M = t.boundingBox;
            null !== M && (this.boundingBox = M.clone());
            var S = t.boundingSphere;
            return null !== S && (this.boundingSphere = S.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    class Xe extends be {
        constructor(t, e, n, i, r, o) {
            super(), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: o
            };
            var a = this;
            t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
            var s = [],
                l = [],
                c = [],
                h = [],
                u = 0,
                d = 0;

            function p(t, e, n, i, r, o, p, f, m, v, g) {
                var y, _, x = o / m,
                    b = p / v,
                    w = o / 2,
                    M = p / 2,
                    S = f / 2,
                    T = m + 1,
                    E = v + 1,
                    A = 0,
                    C = 0,
                    L = new P;
                for (_ = 0; _ < E; _++) {
                    var R = _ * b - M;
                    for (y = 0; y < T; y++) {
                        var O = y * x - w;
                        L[t] = O * i, L[e] = R * r, L[n] = S, l.push(L.x, L.y, L.z), L[t] = 0, L[e] = 0, L[n] = f > 0 ? 1 : -1, c.push(L.x, L.y, L.z), h.push(y / m), h.push(1 - _ / v), A += 1
                    }
                }
                for (_ = 0; _ < v; _++)
                    for (y = 0; y < m; y++) {
                        var D = u + y + T * _,
                            I = u + y + T * (_ + 1),
                            N = u + (y + 1) + T * (_ + 1),
                            k = u + (y + 1) + T * _;
                        s.push(D, I, k), s.push(I, N, k), C += 6
                    }
                a.addGroup(d, C, g), d += C, u += A
            }
            p("z", "y", "x", -1, -1, n, e, t, o, r, 0), p("z", "y", "x", 1, -1, n, e, -t, o, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, o, 2), p("x", "z", "y", 1, -1, t, n, -e, i, o, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(s), this.setAttribute("position", new he(l, 3)), this.setAttribute("normal", new he(c, 3)), this.setAttribute("uv", new he(h, 2))
        }
    }

    function Ye(t) {
        var e = {};
        for (var n in t)
            for (var i in e[n] = {}, t[n]) {
                var r = t[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
            }
        return e
    }

    function Je(t) {
        for (var e = {}, n = 0; n < t.length; n++) {
            var i = Ye(t[n]);
            for (var r in i) e[r] = i[r]
        }
        return e
    }
    var Ze = {
        clone: Ye,
        merge: Je
    };

    function Qe(t) {
        $t.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }

    function Ke() {
        nt.call(this), this.type = "Camera", this.matrixWorldInverse = new B, this.projectionMatrix = new B, this.projectionMatrixInverse = new B
    }

    function $e(t, e, n, i) {
        Ke.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    Qe.prototype = Object.create($t.prototype), Qe.prototype.constructor = Qe, Qe.prototype.isShaderMaterial = !0, Qe.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ye(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
    }, Qe.prototype.toJSON = function (t) {
        var e = $t.prototype.toJSON.call(this, t);
        for (var n in e.uniforms = {}, this.uniforms) {
            var i = this.uniforms[n].value;
            i && i.isTexture ? e.uniforms[n] = {
                type: "t",
                value: i.toJSON(t).uuid
            } : i && i.isColor ? e.uniforms[n] = {
                type: "c",
                value: i.getHex()
            } : i && i.isVector2 ? e.uniforms[n] = {
                type: "v2",
                value: i.toArray()
            } : i && i.isVector3 ? e.uniforms[n] = {
                type: "v3",
                value: i.toArray()
            } : i && i.isVector4 ? e.uniforms[n] = {
                type: "v4",
                value: i.toArray()
            } : i && i.isMatrix3 ? e.uniforms[n] = {
                type: "m3",
                value: i.toArray()
            } : i && i.isMatrix4 ? e.uniforms[n] = {
                type: "m4",
                value: i.toArray()
            } : e.uniforms[n] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
        var r = {};
        for (var o in this.extensions) !0 === this.extensions[o] && (r[o] = !0);
        return Object.keys(r).length > 0 && (e.extensions = r), e
    }, Ke.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: Ke,
        isCamera: !0,
        copy: function (t, e) {
            return nt.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
        },
        getWorldDirection: function (t) {
            void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new P), this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        },
        updateMatrixWorld: function (t) {
            nt.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        updateWorldMatrix: function (t, e) {
            nt.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), $e.prototype = Object.assign(Object.create(Ke.prototype), {
        constructor: $e,
        isPerspectiveCamera: !0,
        copy: function (t, e) {
            return Ke.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
        },
        setFocalLength: function (t) {
            var e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * y.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function () {
            var t = Math.tan(.5 * y.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function () {
            return 2 * y.RAD2DEG * Math.atan(Math.tan(.5 * y.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function (t, e, n, i, r, o) {
            this.aspect = t / e, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var t = this.near,
                e = t * Math.tan(.5 * y.DEG2RAD * this.fov) / this.zoom,
                n = 2 * e,
                i = this.aspect * n,
                r = -.5 * i,
                o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth,
                    s = o.fullHeight;
                r += o.offsetX * i / a, e -= o.offsetY * n / s, i *= o.width / a, n *= o.height / s
            }
            var l = this.filmOffset;
            0 !== l && (r += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function (t) {
            var e = nt.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    });

    function tn(t, e, n, i) {
        nt.call(this), this.type = "CubeCamera";
        var r = new $e(90, 1, t, e);
        r.up.set(0, -1, 0), r.lookAt(new P(1, 0, 0)), this.add(r);
        var o = new $e(90, 1, t, e);
        o.up.set(0, -1, 0), o.lookAt(new P(-1, 0, 0)), this.add(o);
        var a = new $e(90, 1, t, e);
        a.up.set(0, 0, 1), a.lookAt(new P(0, 1, 0)), this.add(a);
        var s = new $e(90, 1, t, e);
        s.up.set(0, 0, -1), s.lookAt(new P(0, -1, 0)), this.add(s);
        var l = new $e(90, 1, t, e);
        l.up.set(0, -1, 0), l.lookAt(new P(0, 0, 1)), this.add(l);
        var c = new $e(90, 1, t, e);
        c.up.set(0, -1, 0), c.lookAt(new P(0, 0, -1)), this.add(c), i = i || {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }, this.renderTarget = new en(n, i), this.renderTarget.texture.name = "CubeCamera", this.update = function (t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = t.getRenderTarget(),
                i = this.renderTarget,
                h = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1, t.setRenderTarget(i, 0), t.render(e, r), t.setRenderTarget(i, 1), t.render(e, o), t.setRenderTarget(i, 2), t.render(e, a), t.setRenderTarget(i, 3), t.render(e, s), t.setRenderTarget(i, 4), t.render(e, l), i.texture.generateMipmaps = h, t.setRenderTarget(i, 5), t.render(e, c), t.setRenderTarget(n)
        }, this.clear = function (t, e, n, i) {
            for (var r = t.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++) t.setRenderTarget(o, a), t.clear(e, n, i);
            t.setRenderTarget(r)
        }
    }

    function en(t, e, n) {
        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), T.call(this, t, t, e)
    }

    function nn(t, e, n, i, r, o, a, s, l, c, h, u) {
        M.call(this, null, o, a, s, l, c, i, r, h, u), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1
        }, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== c ? c : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
    tn.prototype = Object.create(nt.prototype), tn.prototype.constructor = tn, en.prototype = Object.create(T.prototype), en.prototype.constructor = en, en.prototype.isWebGLCubeRenderTarget = !0, en.prototype.fromEquirectangularTexture = function (t, e) {
        this.texture.type = e.type, this.texture.format = e.format, this.texture.encoding = e.encoding;
        var n = new it,
            i = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
                fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
            },
            r = new Qe({
                type: "CubemapFromEquirect",
                uniforms: Ye(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: 1,
                blending: 0
            });
        r.uniforms.tEquirect.value = e;
        var o = new Fe(new Xe(5, 5, 5), r);
        n.add(o);
        var a = new tn(1, 10, 1);
        return a.renderTarget = this, a.renderTarget.texture.name = "CubeCameraTexture", a.update(t, n), o.geometry.dispose(), o.material.dispose(), this
    }, nn.prototype = Object.create(M.prototype), nn.prototype.constructor = nn, nn.prototype.isDataTexture = !0;
    var rn = new xt,
        on = new P;

    function an(t, e, n, i, r, o) {
        this.planes = [void 0 !== t ? t : new Ot, void 0 !== e ? e : new Ot, void 0 !== n ? n : new Ot, void 0 !== i ? i : new Ot, void 0 !== r ? r : new Ot, void 0 !== o ? o : new Ot]
    }
    Object.assign(an.prototype, {
        set: function (t, e, n, i, r, o) {
            var a = this.planes;
            return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this
        },
        setFromProjectionMatrix: function (t) {
            var e = this.planes,
                n = t.elements,
                i = n[0],
                r = n[1],
                o = n[2],
                a = n[3],
                s = n[4],
                l = n[5],
                c = n[6],
                h = n[7],
                u = n[8],
                d = n[9],
                p = n[10],
                f = n[11],
                m = n[12],
                v = n[13],
                g = n[14],
                y = n[15];
            return e[0].setComponents(a - i, h - s, f - u, y - m).normalize(), e[1].setComponents(a + i, h + s, f + u, y + m).normalize(), e[2].setComponents(a + r, h + l, f + d, y + v).normalize(), e[3].setComponents(a - r, h - l, f - d, y - v).normalize(), e[4].setComponents(a - o, h - c, f - p, y - g).normalize(), e[5].setComponents(a + o, h + c, f + p, y + g).normalize(), this
        },
        intersectsObject: function (t) {
            var e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(), rn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(rn)
        },
        intersectsSprite: function (t) {
            return rn.center.set(0, 0, 0), rn.radius = .7071067811865476, rn.applyMatrix4(t.matrixWorld), this.intersectsSphere(rn)
        },
        intersectsSphere: function (t) {
            for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                if (e[r].distanceToPoint(n) < i) return !1
            }
            return !0
        },
        intersectsBox: function (t) {
            for (var e = this.planes, n = 0; n < 6; n++) {
                var i = e[n];
                if (on.x = i.normal.x > 0 ? t.max.x : t.min.x, on.y = i.normal.y > 0 ? t.max.y : t.min.y, on.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(on) < 0) return !1
            }
            return !0
        },
        containsPoint: function (t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0) return !1;
            return !0
        }
    });
    var sn = {
        common: {
            diffuse: {
                value: new Xt(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new x
            },
            uv2Transform: {
                value: new x
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new _(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Xt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Xt(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new x
            }
        },
        sprite: {
            diffuse: {
                value: new Xt(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new _(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new x
            }
        }
    };

    function ln() {
        var t = null,
            e = !1,
            n = null;

        function i(r, o) {
            !1 !== e && (n(r, o), t.requestAnimationFrame(i))
        }
        return {
            start: function () {
                !0 !== e && null !== n && (t.requestAnimationFrame(i), e = !0)
            },
            stop: function () {
                e = !1
            },
            setAnimationLoop: function (t) {
                n = t
            },
            setContext: function (e) {
                t = e
            }
        }
    }

    function cn(t, e) {
        var n = e.isWebGL2,
            i = new WeakMap;
        return {
            get: function (t) {
                return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
            },
            remove: function (e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var n = i.get(e);
                n && (t.deleteBuffer(n.buffer), i.delete(e))
            },
            update: function (e, r) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var o = i.get(e);
                void 0 === o ? i.set(e, function (e, n) {
                    var i = e.array,
                        r = e.usage,
                        o = t.createBuffer();
                    t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback();
                    var a = 5126;
                    return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), {
                        buffer: o,
                        type: a,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(e, r)) : o.version < e.version && (! function (e, i, r) {
                    var o = i.array,
                        a = i.updateRange;
                    t.bindBuffer(r, e), -1 === a.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, a.offset * o.BYTES_PER_ELEMENT, o, a.offset, a.count) : t.bufferSubData(r, a.offset * o.BYTES_PER_ELEMENT, o.subarray(a.offset, a.offset + a.count)), a.count = -1)
                }(o.buffer, e, r), o.version = e.version)
            }
        }
    }

    function hn(t, e, n, i) {
        qe.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        }, this.fromBufferGeometry(new un(t, e, n, i)), this.mergeVertices()
    }

    function un(t, e, n, i) {
        be.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        };
        var r, o, a = (t = t || 1) / 2,
            s = (e = e || 1) / 2,
            l = Math.floor(n) || 1,
            c = Math.floor(i) || 1,
            h = l + 1,
            u = c + 1,
            d = t / l,
            p = e / c,
            f = [],
            m = [],
            v = [],
            g = [];
        for (o = 0; o < u; o++) {
            var y = o * p - s;
            for (r = 0; r < h; r++) {
                var _ = r * d - a;
                m.push(_, -y, 0), v.push(0, 0, 1), g.push(r / l), g.push(1 - o / c)
            }
        }
        for (o = 0; o < c; o++)
            for (r = 0; r < l; r++) {
                var x = r + h * o,
                    b = r + h * (o + 1),
                    w = r + 1 + h * (o + 1),
                    M = r + 1 + h * o;
                f.push(x, b, M), f.push(b, w, M)
            }
        this.setIndex(f), this.setAttribute("position", new he(m, 3)), this.setAttribute("normal", new he(v, 3)), this.setAttribute("uv", new he(g, 2))
    }
    hn.prototype = Object.create(qe.prototype), hn.prototype.constructor = hn, un.prototype = Object.create(be.prototype), un.prototype.constructor = un;
    var dn = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        },
        pn = {
            basic: {
                uniforms: Je([sn.common, sn.specularmap, sn.envmap, sn.aomap, sn.lightmap, sn.fog]),
                vertexShader: dn.meshbasic_vert,
                fragmentShader: dn.meshbasic_frag
            },
            lambert: {
                uniforms: Je([sn.common, sn.specularmap, sn.envmap, sn.aomap, sn.lightmap, sn.emissivemap, sn.fog, sn.lights, {
                    emissive: {
                        value: new Xt(0)
                    }
                }]),
                vertexShader: dn.meshlambert_vert,
                fragmentShader: dn.meshlambert_frag
            },
            phong: {
                uniforms: Je([sn.common, sn.specularmap, sn.envmap, sn.aomap, sn.lightmap, sn.emissivemap, sn.bumpmap, sn.normalmap, sn.displacementmap, sn.fog, sn.lights, {
                    emissive: {
                        value: new Xt(0)
                    },
                    specular: {
                        value: new Xt(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: dn.meshphong_vert,
                fragmentShader: dn.meshphong_frag
            },
            standard: {
                uniforms: Je([sn.common, sn.envmap, sn.aomap, sn.lightmap, sn.emissivemap, sn.bumpmap, sn.normalmap, sn.displacementmap, sn.roughnessmap, sn.metalnessmap, sn.fog, sn.lights, {
                    emissive: {
                        value: new Xt(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: dn.meshphysical_vert,
                fragmentShader: dn.meshphysical_frag
            },
            toon: {
                uniforms: Je([sn.common, sn.specularmap, sn.aomap, sn.lightmap, sn.emissivemap, sn.bumpmap, sn.normalmap, sn.displacementmap, sn.gradientmap, sn.fog, sn.lights, {
                    emissive: {
                        value: new Xt(0)
                    },
                    specular: {
                        value: new Xt(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: dn.meshtoon_vert,
                fragmentShader: dn.meshtoon_frag
            },
            matcap: {
                uniforms: Je([sn.common, sn.bumpmap, sn.normalmap, sn.displacementmap, sn.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: dn.meshmatcap_vert,
                fragmentShader: dn.meshmatcap_frag
            },
            points: {
                uniforms: Je([sn.points, sn.fog]),
                vertexShader: dn.points_vert,
                fragmentShader: dn.points_frag
            },
            dashed: {
                uniforms: Je([sn.common, sn.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: dn.linedashed_vert,
                fragmentShader: dn.linedashed_frag
            },
            depth: {
                uniforms: Je([sn.common, sn.displacementmap]),
                vertexShader: dn.depth_vert,
                fragmentShader: dn.depth_frag
            },
            normal: {
                uniforms: Je([sn.common, sn.bumpmap, sn.normalmap, sn.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: dn.normal_vert,
                fragmentShader: dn.normal_frag
            },
            sprite: {
                uniforms: Je([sn.sprite, sn.fog]),
                vertexShader: dn.sprite_vert,
                fragmentShader: dn.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new x
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: dn.background_vert,
                fragmentShader: dn.background_frag
            },
            cube: {
                uniforms: Je([sn.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: dn.cube_vert,
                fragmentShader: dn.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: dn.equirect_vert,
                fragmentShader: dn.equirect_frag
            },
            distanceRGBA: {
                uniforms: Je([sn.common, sn.displacementmap, {
                    referencePosition: {
                        value: new P
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: dn.distanceRGBA_vert,
                fragmentShader: dn.distanceRGBA_frag
            },
            shadow: {
                uniforms: Je([sn.lights, sn.fog, {
                    color: {
                        value: new Xt(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: dn.shadow_vert,
                fragmentShader: dn.shadow_frag
            }
        };

    function fn(t, e, n, i) {
        var r, o, a = new Xt(0),
            s = 0,
            l = null,
            c = 0,
            h = null;

        function u(t, n) {
            e.buffers.color.setClear(t.r, t.g, t.b, n, i)
        }
        return {
            getClearColor: function () {
                return a
            },
            setClearColor: function (t, e) {
                a.set(t), u(a, s = void 0 !== e ? e : 1)
            },
            getClearAlpha: function () {
                return s
            },
            setClearAlpha: function (t) {
                u(a, s = t)
            },
            render: function (e, i, d, p) {
                var f = i.background,
                    m = t.xr,
                    v = m.getSession && m.getSession();
                if (v && "additive" === v.environmentBlendMode && (f = null), null === f ? u(a, s) : f && f.isColor && (u(f, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.isWebGLCubeRenderTarget || 306 === f.mapping)) {
                    void 0 === o && ((o = new Fe(new Xe(1, 1, 1), new Qe({
                        type: "BackgroundCubeMaterial",
                        uniforms: Ye(pn.cube.uniforms),
                        vertexShader: pn.cube.vertexShader,
                        fragmentShader: pn.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(o.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), n.update(o));
                    var g = f.isWebGLCubeRenderTarget ? f.texture : f;
                    o.material.uniforms.envMap.value = g, o.material.uniforms.flipEnvMap.value = g.isCubeTexture ? -1 : 1, l === f && c === g.version && h === t.toneMapping || (o.material.needsUpdate = !0, l = f, c = g.version, h = t.toneMapping), e.unshift(o, o.geometry, o.material, 0, 0, null)
                } else f && f.isTexture && (void 0 === r && ((r = new Fe(new un(2, 2), new Qe({
                    type: "BackgroundMaterial",
                    uniforms: Ye(pn.background.uniforms),
                    vertexShader: pn.background.vertexShader,
                    fragmentShader: pn.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.deleteAttribute("normal"), Object.defineProperty(r.material, "map", {
                    get: function () {
                        return this.uniforms.t2D.value
                    }
                }), n.update(r)), r.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), r.material.uniforms.uvTransform.value.copy(f.matrix), l === f && c === f.version && h === t.toneMapping || (r.material.needsUpdate = !0, l = f, c = f.version, h = t.toneMapping), e.unshift(r, r.geometry, r.material, 0, 0, null))
            }
        }
    }

    function mn(t, e, n, i) {
        var r, o = i.isWebGL2;
        this.setMode = function (t) {
            r = t
        }, this.render = function (e, i) {
            t.drawArrays(r, e, i), n.update(i, r)
        }, this.renderInstances = function (i, a, s, l) {
            if (0 !== l) {
                var c, h;
                if (o) c = t, h = "drawArraysInstanced";
                else if (h = "drawArraysInstancedANGLE", null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                c[h](r, a, s, l), n.update(s, r, l)
            }
        }
    }

    function vn(t, e, n) {
        var i;

        function r(e) {
            if ("highp" === e) {
                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                e = "mediump"
            }
            return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext,
            a = void 0 !== n.precision ? n.precision : "highp",
            s = r(a);
        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
        var l = !0 === n.logarithmicDepthBuffer,
            c = t.getParameter(34930),
            h = t.getParameter(35660),
            u = t.getParameter(3379),
            d = t.getParameter(34076),
            p = t.getParameter(34921),
            f = t.getParameter(36347),
            m = t.getParameter(36348),
            v = t.getParameter(36349),
            g = h > 0,
            y = o || !!e.get("OES_texture_float");
        return {
            isWebGL2: o,
            getMaxAnisotropy: function () {
                if (void 0 !== i) return i;
                var n = e.get("EXT_texture_filter_anisotropic");
                return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: h,
            maxTextureSize: u,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: v,
            vertexTextures: g,
            floatFragmentTextures: y,
            floatVertexTextures: g && y,
            maxSamples: o ? t.getParameter(36183) : 0
        }
    }

    function gn() {
        var t = this,
            e = null,
            n = 0,
            i = !1,
            r = !1,
            o = new Ot,
            a = new x,
            s = {
                value: null,
                needsUpdate: !1
            };

        function l() {
            s.value !== e && (s.value = e, s.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
        }

        function c(e, n, i, r) {
            var l = null !== e ? e.length : 0,
                c = null;
            if (0 !== l) {
                if (c = s.value, !0 !== r || null === c) {
                    var h = i + 4 * l,
                        u = n.matrixWorldInverse;
                    a.getNormalMatrix(u), (null === c || c.length < h) && (c = new Float32Array(h));
                    for (var d = 0, p = i; d !== l; ++d, p += 4) o.copy(e[d]).applyMatrix4(u, a), o.normal.toArray(c, p), c[p + 3] = o.constant
                }
                s.value = c, s.needsUpdate = !0
            }
            return t.numPlanes = l, t.numIntersection = 0, c
        }
        this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, r, o) {
            var a = 0 !== t.length || r || 0 !== n || i;
            return i = r, e = c(t, o, 0), n = t.length, a
        }, this.beginShadows = function () {
            r = !0, c(null)
        }, this.endShadows = function () {
            r = !1, l()
        }, this.setState = function (t, o, a, h, u, d) {
            if (!i || null === t || 0 === t.length || r && !a) r ? c(null) : l();
            else {
                var p = r ? 0 : n,
                    f = 4 * p,
                    m = u.clippingState || null;
                s.value = m, m = c(t, h, f, d);
                for (var v = 0; v !== f; ++v) m[v] = e[v];
                u.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += p
            }
        }
    }

    function yn(t) {
        var e = {};
        return {
            get: function (n) {
                if (void 0 !== e[n]) return e[n];
                var i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = t.getExtension(n)
                }
                return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
            }
        }
    }

    function _n(t, e, n) {
        var i = new WeakMap,
            r = new WeakMap;

        function o(t) {
            var a = t.target,
                s = i.get(a);
            for (var l in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[l]);
            a.removeEventListener("dispose", o), i.delete(a);
            var c = r.get(s);
            c && (e.remove(c), r.delete(s)), n.memory.geometries--
        }

        function a(t) {
            var n = [],
                i = t.index,
                o = t.attributes.position,
                a = 0;
            if (null !== i) {
                var s = i.array;
                a = i.version;
                for (var l = 0, c = s.length; l < c; l += 3) {
                    var h = s[l + 0],
                        u = s[l + 1],
                        d = s[l + 2];
                    n.push(h, u, u, d, d, h)
                }
            } else {
                s = o.array;
                a = o.version;
                for (l = 0, c = s.length / 3 - 1; l < c; l += 3) {
                    h = l + 0, u = l + 1, d = l + 2;
                    n.push(h, u, u, d, d, h)
                }
            }
            var p = new(pe(n) > 65535 ? ce : se)(n, 1);
            p.version = a, e.update(p, 34963);
            var f = r.get(t);
            f && e.remove(f), r.set(t, p)
        }
        return {
            get: function (t, e) {
                var r = i.get(e);
                return r || (e.addEventListener("dispose", o), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new be).setFromObject(t)), r = e._bufferGeometry), i.set(e, r), n.memory.geometries++, r)
            },
            update: function (t) {
                var n = t.index,
                    i = t.attributes;
                for (var r in null !== n && e.update(n, 34963), i) e.update(i[r], 34962);
                var o = t.morphAttributes;
                for (var r in o)
                    for (var a = o[r], s = 0, l = a.length; s < l; s++) e.update(a[s], 34962)
            },
            getWireframeAttribute: function (t) {
                var e = r.get(t);
                if (e) {
                    var n = t.index;
                    null !== n && e.version < n.version && a(t)
                } else a(t);
                return r.get(t)
            }
        }
    }

    function xn(t, e, n, i) {
        var r, o, a, s = i.isWebGL2;
        this.setMode = function (t) {
            r = t
        }, this.setIndex = function (t) {
            o = t.type, a = t.bytesPerElement
        }, this.render = function (e, i) {
            t.drawElements(r, i, o, e * a), n.update(i, r)
        }, this.renderInstances = function (i, l, c, h) {
            if (0 !== h) {
                var u, d;
                if (s) u = t, d = "drawElementsInstanced";
                else if (d = "drawElementsInstancedANGLE", null === (u = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[d](r, c, o, l * a, h), n.update(c, r, h)
            }
        }
    }

    function bn(t) {
        var e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
                e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
            },
            update: function (t, n, i) {
                switch (i = i || 1, e.calls++, n) {
                    case 4:
                        e.triangles += i * (t / 3);
                        break;
                    case 1:
                        e.lines += i * (t / 2);
                        break;
                    case 3:
                        e.lines += i * (t - 1);
                        break;
                    case 2:
                        e.lines += i * t;
                        break;
                    case 0:
                        e.points += i * t;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                }
            }
        }
    }

    function wn(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }

    function Mn(t) {
        var e = {},
            n = new Float32Array(8);
        return {
            update: function (i, r, o, a) {
                var s = i.morphTargetInfluences,
                    l = void 0 === s ? 0 : s.length,
                    c = e[r.id];
                if (void 0 === c) {
                    c = [];
                    for (var h = 0; h < l; h++) c[h] = [h, 0];
                    e[r.id] = c
                }
                var u = o.morphTargets && r.morphAttributes.position,
                    d = o.morphNormals && r.morphAttributes.normal;
                for (h = 0; h < l; h++) {
                    0 !== (f = c[h])[1] && (u && r.deleteAttribute("morphTarget" + h), d && r.deleteAttribute("morphNormal" + h))
                }
                for (h = 0; h < l; h++) {
                    (f = c[h])[0] = h, f[1] = s[h]
                }
                c.sort(wn);
                var p = 0;
                for (h = 0; h < 8; h++) {
                    var f;
                    if (f = c[h]) {
                        var m = f[0],
                            v = f[1];
                        if (v) {
                            u && r.setAttribute("morphTarget" + h, u[m]), d && r.setAttribute("morphNormal" + h, d[m]), n[h] = v, p += v;
                            continue
                        }
                    }
                    n[h] = 0
                }
                var g = r.morphTargetsRelative ? 1 : 1 - p;
                a.getUniforms().setValue(t, "morphTargetBaseInfluence", g), a.getUniforms().setValue(t, "morphTargetInfluences", n)
            }
        }
    }

    function Sn(t, e, n, i) {
        var r = new WeakMap;
        return {
            update: function (t) {
                var o = i.render.frame,
                    a = t.geometry,
                    s = e.get(t, a);
                return r.get(s) !== o && (a.isGeometry && s.updateFromObject(t), e.update(s), r.set(s, o)), t.isInstancedMesh && n.update(t.instanceMatrix, 34962), s
            },
            dispose: function () {
                r = new WeakMap
            }
        }
    }

    function Tn(t, e, n, i, r, o, a, s, l, c) {
        t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, a = void 0 !== a ? a : 1022, M.call(this, t, e, n, i, r, o, a, s, l, c), this.flipY = !1
    }

    function En(t, e, n, i) {
        M.call(this, null), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1,
            depth: i || 1
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }

    function An(t, e, n, i) {
        M.call(this, null), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1,
            depth: i || 1
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }
    pn.physical = {
        uniforms: Je([pn.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new _(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Xt(0)
            },
            transparency: {
                value: 0
            }
        }]),
        vertexShader: dn.meshphysical_vert,
        fragmentShader: dn.meshphysical_frag
    }, Tn.prototype = Object.create(M.prototype), Tn.prototype.constructor = Tn, Tn.prototype.isCubeTexture = !0, Object.defineProperty(Tn.prototype, "images", {
        get: function () {
            return this.image
        },
        set: function (t) {
            this.image = t
        }
    }), En.prototype = Object.create(M.prototype), En.prototype.constructor = En, En.prototype.isDataTexture2DArray = !0, An.prototype = Object.create(M.prototype), An.prototype.constructor = An, An.prototype.isDataTexture3D = !0;
    var Cn = new M,
        Ln = new En,
        Pn = new An,
        Rn = new Tn,
        On = [],
        Dn = [],
        In = new Float32Array(16),
        Nn = new Float32Array(9),
        kn = new Float32Array(4);

    function zn(t, e, n) {
        var i = t[0];
        if (i <= 0 || i > 0) return t;
        var r = e * n,
            o = On[r];
        if (void 0 === o && (o = new Float32Array(r), On[r] = o), 0 !== e) {
            i.toArray(o, 0);
            for (var a = 1, s = 0; a !== e; ++a) s += n, t[a].toArray(o, s)
        }
        return o
    }

    function Bn(t, e) {
        if (t.length !== e.length) return !1;
        for (var n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n]) return !1;
        return !0
    }

    function Fn(t, e) {
        for (var n = 0, i = e.length; n < i; n++) t[n] = e[n]
    }

    function Un(t, e) {
        var n = Dn[e];
        void 0 === n && (n = new Int32Array(e), Dn[e] = n);
        for (var i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
        return n
    }

    function Hn(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
    }

    function Gn(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
        else {
            if (Bn(n, e)) return;
            t.uniform2fv(this.addr, e), Fn(n, e)
        }
    }

    function Vn(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
        else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
        else {
            if (Bn(n, e)) return;
            t.uniform3fv(this.addr, e), Fn(n, e)
        }
    }

    function jn(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
        else {
            if (Bn(n, e)) return;
            t.uniform4fv(this.addr, e), Fn(n, e)
        }
    }

    function Wn(t, e) {
        var n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Bn(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), Fn(n, e)
        } else {
            if (Bn(n, i)) return;
            kn.set(i), t.uniformMatrix2fv(this.addr, !1, kn), Fn(n, i)
        }
    }

    function qn(t, e) {
        var n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Bn(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), Fn(n, e)
        } else {
            if (Bn(n, i)) return;
            Nn.set(i), t.uniformMatrix3fv(this.addr, !1, Nn), Fn(n, i)
        }
    }

    function Xn(t, e) {
        var n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Bn(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), Fn(n, e)
        } else {
            if (Bn(n, i)) return;
            In.set(i), t.uniformMatrix4fv(this.addr, !1, In), Fn(n, i)
        }
    }

    function Yn(t, e, n) {
        var i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || Cn, r)
    }

    function Jn(t, e, n) {
        var i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Ln, r)
    }

    function Zn(t, e, n) {
        var i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Pn, r)
    }

    function Qn(t, e, n) {
        var i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Rn, r)
    }

    function Kn(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
    }

    function $n(t, e) {
        var n = this.cache;
        Bn(n, e) || (t.uniform2iv(this.addr, e), Fn(n, e))
    }

    function ti(t, e) {
        var n = this.cache;
        Bn(n, e) || (t.uniform3iv(this.addr, e), Fn(n, e))
    }

    function ei(t, e) {
        var n = this.cache;
        Bn(n, e) || (t.uniform4iv(this.addr, e), Fn(n, e))
    }

    function ni(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
    }

    function ii(t, e) {
        t.uniform1fv(this.addr, e)
    }

    function ri(t, e) {
        t.uniform1iv(this.addr, e)
    }

    function oi(t, e) {
        t.uniform2iv(this.addr, e)
    }

    function ai(t, e) {
        t.uniform3iv(this.addr, e)
    }

    function si(t, e) {
        t.uniform4iv(this.addr, e)
    }

    function li(t, e) {
        var n = zn(e, this.size, 2);
        t.uniform2fv(this.addr, n)
    }

    function ci(t, e) {
        var n = zn(e, this.size, 3);
        t.uniform3fv(this.addr, n)
    }

    function hi(t, e) {
        var n = zn(e, this.size, 4);
        t.uniform4fv(this.addr, n)
    }

    function ui(t, e) {
        var n = zn(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n)
    }

    function di(t, e) {
        var n = zn(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n)
    }

    function pi(t, e) {
        var n = zn(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n)
    }

    function fi(t, e, n) {
        var i = e.length,
            r = Un(n, i);
        t.uniform1iv(this.addr, r);
        for (var o = 0; o !== i; ++o) n.safeSetTexture2D(e[o] || Cn, r[o])
    }

    function mi(t, e, n) {
        var i = e.length,
            r = Un(n, i);
        t.uniform1iv(this.addr, r);
        for (var o = 0; o !== i; ++o) n.safeSetTextureCube(e[o] || Rn, r[o])
    }

    function vi(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
            switch (t) {
                case 5126:
                    return Hn;
                case 35664:
                    return Gn;
                case 35665:
                    return Vn;
                case 35666:
                    return jn;
                case 35674:
                    return Wn;
                case 35675:
                    return qn;
                case 35676:
                    return Xn;
                case 5124:
                case 35670:
                    return Kn;
                case 35667:
                case 35671:
                    return $n;
                case 35668:
                case 35672:
                    return ti;
                case 35669:
                case 35673:
                    return ei;
                case 5125:
                    return ni;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Yn;
                case 35679:
                case 36299:
                case 36307:
                    return Zn;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Qn;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return Jn
            }
        }(e.type)
    }

    function gi(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
            switch (t) {
                case 5126:
                    return ii;
                case 35664:
                    return li;
                case 35665:
                    return ci;
                case 35666:
                    return hi;
                case 35674:
                    return ui;
                case 35675:
                    return di;
                case 35676:
                    return pi;
                case 5124:
                case 35670:
                    return ri;
                case 35667:
                case 35671:
                    return oi;
                case 35668:
                case 35672:
                    return ai;
                case 35669:
                case 35673:
                    return si;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return fi;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return mi
            }
        }(e.type)
    }

    function yi(t) {
        this.id = t, this.seq = [], this.map = {}
    }
    gi.prototype.updateCache = function (t) {
        var e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Fn(e, t)
    }, yi.prototype.setValue = function (t, e, n) {
        for (var i = this.seq, r = 0, o = i.length; r !== o; ++r) {
            var a = i[r];
            a.setValue(t, e[a.id], n)
        }
    };
    var _i = /([\w\d_]+)(\])?(\[|\.)?/g;

    function xi(t, e) {
        t.seq.push(e), t.map[e.id] = e
    }

    function bi(t, e, n) {
        var i = t.name,
            r = i.length;
        for (_i.lastIndex = 0;;) {
            var o = _i.exec(i),
                a = _i.lastIndex,
                s = o[1],
                l = "]" === o[2],
                c = o[3];
            if (l && (s |= 0), void 0 === c || "[" === c && a + 2 === r) {
                xi(n, void 0 === c ? new vi(s, t, e) : new gi(s, t, e));
                break
            }
            var h = n.map[s];
            void 0 === h && xi(n, h = new yi(s)), n = h
        }
    }

    function wi(t, e) {
        this.seq = [], this.map = {};
        for (var n = t.getProgramParameter(e, 35718), i = 0; i < n; ++i) {
            var r = t.getActiveUniform(e, i);
            bi(r, t.getUniformLocation(e, r.name), this)
        }
    }

    function Mi(t, e, n) {
        var i = t.createShader(e);
        return t.shaderSource(i, n), t.compileShader(i), i
    }
    wi.prototype.setValue = function (t, e, n, i) {
        var r = this.map[e];
        void 0 !== r && r.setValue(t, n, i)
    }, wi.prototype.setOptional = function (t, e, n) {
        var i = e[n];
        void 0 !== i && this.setValue(t, n, i)
    }, wi.upload = function (t, e, n, i) {
        for (var r = 0, o = e.length; r !== o; ++r) {
            var a = e[r],
                s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(t, s.value, i)
        }
    }, wi.seqWithValue = function (t, e) {
        for (var n = [], i = 0, r = t.length; i !== r; ++i) {
            var o = t[i];
            o.id in e && n.push(o)
        }
        return n
    };
    var Si = 0;

    function Ti(t) {
        switch (t) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
                return ["LogLuv", "( value )"];
            default:
                throw new Error("unsupported encoding: " + t)
        }
    }

    function Ei(t, e, n) {
        var i = t.getShaderParameter(e, 35713),
            r = t.getShaderInfoLog(e).trim();
        return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (t) {
            for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
            return e.join("\n")
        }(t.getShaderSource(e))
    }

    function Ai(t, e) {
        var n = Ti(e);
        return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function Ci(t, e) {
        var n;
        switch (e) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "Uncharted2";
                break;
            case 4:
                n = "OptimizedCineon";
                break;
            case 5:
                n = "ACESFilmic";
                break;
            default:
                throw new Error("unsupported toneMapping: " + e)
        }
        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function Li(t) {
        return "" !== t
    }

    function Pi(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }

    function Ri(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    var Oi = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Di(t) {
        return t.replace(Oi, Ii)
    }

    function Ii(t, e) {
        var n = dn[e];
        if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
        return Di(n)
    }
    var Ni = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        ki = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

    function zi(t) {
        return t.replace(ki, Fi).replace(Ni, Bi)
    }

    function Bi(t, e, n, i) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Fi(t, e, n, i)
    }

    function Fi(t, e, n, i) {
        for (var r = "", o = parseInt(e); o < parseInt(n); o++) r += i.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
        return r
    }

    function Ui(t) {
        var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
        return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
    }

    function Hi(t, e, n) {
        var i, r, o, a, s, l = t.getContext(),
            c = n.defines,
            h = n.vertexShader,
            u = n.fragmentShader,
            d = function (t) {
                var e = "SHADOWMAP_TYPE_BASIC";
                return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
            }(n),
            p = function (t) {
                var e = "ENVMAP_TYPE_CUBE";
                if (t.envMap) switch (t.envMapMode) {
                    case 301:
                    case 302:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                    case 307:
                        e = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case 303:
                    case 304:
                        e = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case 305:
                        e = "ENVMAP_TYPE_SPHERE"
                }
                return e
            }(n),
            f = function (t) {
                var e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap) switch (t.envMapMode) {
                    case 302:
                    case 304:
                        e = "ENVMAP_MODE_REFRACTION"
                }
                return e
            }(n),
            m = function (t) {
                var e = "ENVMAP_BLENDING_NONE";
                if (t.envMap) switch (t.combine) {
                    case 0:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        e = "ENVMAP_BLENDING_ADD"
                }
                return e
            }(n),
            v = t.gammaFactor > 0 ? t.gammaFactor : 1,
            g = n.isWebGL2 ? "" : function (t) {
                return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Li).join("\n")
            }(n),
            y = function (t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    !1 !== i && e.push("#define " + n + " " + i)
                }
                return e.join("\n")
            }(c),
            _ = l.createProgram();
        if (n.isRawShaderMaterial ? ((i = [y].filter(Li).join("\n")).length > 0 && (i += "\n"), (r = [g, y].filter(Li).join("\n")).length > 0 && (r += "\n")) : (i = [Ui(n), "#define SHADER_NAME " + n.shaderName, y, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + v, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Li).join("\n"), r = [g, Ui(n), "#define SHADER_NAME " + n.shaderName, y, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? dn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ci("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? dn.encodings_pars_fragment : "", n.mapEncoding ? Ai("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? Ai("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? Ai("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? Ai("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? Ai("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? (o = "linearToOutputTexel", a = n.outputEncoding, s = Ti(a), "vec4 " + o + "( vec4 value ) { return LinearTo" + s[0] + s[1] + "; }") : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Li).join("\n")), h = Ri(h = Pi(h = Di(h), n), n), u = Ri(u = Pi(u = Di(u), n), n), h = zi(h), u = zi(u), n.isWebGL2 && !n.isRawShaderMaterial) {
            var x = !1,
                b = /^\s*#version\s+300\s+es\s*\n/;
            n.isShaderMaterial && null !== h.match(b) && null !== u.match(b) && (x = !0, h = h.replace(b, ""), u = u.replace(b, "")), i = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, r = ["#version 300 es\n", "#define varying in", x ? "" : "out highp vec4 pc_fragColor;", x ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + r
        }
        var w, M, S = r + u,
            T = Mi(l, 35633, i + h),
            E = Mi(l, 35632, S);
        if (l.attachShader(_, T), l.attachShader(_, E), void 0 !== n.index0AttributeName ? l.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === n.morphTargets && l.bindAttribLocation(_, 0, "position"), l.linkProgram(_), t.debug.checkShaderErrors) {
            var A = l.getProgramInfoLog(_).trim(),
                C = l.getShaderInfoLog(T).trim(),
                L = l.getShaderInfoLog(E).trim(),
                P = !0,
                R = !0;
            if (!1 === l.getProgramParameter(_, 35714)) {
                P = !1;
                var O = Ei(l, T, "vertex"),
                    D = Ei(l, E, "fragment");
                console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(_, 35715), "gl.getProgramInfoLog", A, O, D)
            } else "" !== A ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", A) : "" !== C && "" !== L || (R = !1);
            R && (this.diagnostics = {
                runnable: P,
                programLog: A,
                vertexShader: {
                    log: C,
                    prefix: i
                },
                fragmentShader: {
                    log: L,
                    prefix: r
                }
            })
        }
        return l.deleteShader(T), l.deleteShader(E), this.getUniforms = function () {
            return void 0 === w && (w = new wi(l, _)), w
        }, this.getAttributes = function () {
            return void 0 === M && (M = function (t, e) {
                for (var n = {}, i = t.getProgramParameter(e, 35721), r = 0; r < i; r++) {
                    var o = t.getActiveAttrib(e, r).name;
                    n[o] = t.getAttribLocation(e, o)
                }
                return n
            }(l, _)), M
        }, this.destroy = function () {
            l.deleteProgram(_), this.program = void 0
        }, this.name = n.shaderName, this.id = Si++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = T, this.fragmentShader = E, this
    }

    function Gi(t, e, n) {
        var i = [],
            r = n.isWebGL2,
            o = n.logarithmicDepthBuffer,
            a = n.floatVertexTextures,
            s = n.precision,
            l = n.maxVertexUniforms,
            c = n.vertexTextures,
            h = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            u = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

        function d(t) {
            var e;
            return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = 3e3, e
        }
        this.getParameters = function (i, u, p, f, m, v, g) {
            var y = f.fog,
                _ = i.isMeshStandardMaterial ? f.environment : null,
                x = i.envMap || _,
                b = h[i.type],
                w = g.isSkinnedMesh ? function (t) {
                    var e = t.skeleton.bones;
                    if (a) return 1024;
                    var n = l,
                        i = Math.floor((n - 20) / 4),
                        r = Math.min(i, e.length);
                    return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + r + "."), 0) : r
                }(g) : 0;
            null !== i.precision && (s = n.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", s, "instead.");
            var M = function (t, e) {
                var n;
                if (e) {
                    var i = pn[e];
                    n = {
                        name: t.type,
                        uniforms: Ze.clone(i.uniforms),
                        vertexShader: i.vertexShader,
                        fragmentShader: i.fragmentShader
                    }
                } else n = {
                    name: t.type,
                    uniforms: t.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                };
                return n
            }(i, b);
            i.onBeforeCompile(M, t);
            var S = t.getRenderTarget();
            return {
                isWebGL2: r,
                shaderID: b,
                shaderName: M.name,
                uniforms: M.uniforms,
                vertexShader: M.vertexShader,
                fragmentShader: M.fragmentShader,
                defines: i.defines,
                isRawShaderMaterial: i.isRawShaderMaterial,
                isShaderMaterial: i.isShaderMaterial,
                precision: s,
                instancing: !0 === g.isInstancedMesh,
                supportsVertexTextures: c,
                outputEncoding: null !== S ? d(S.texture) : t.outputEncoding,
                map: !!i.map,
                mapEncoding: d(i.map),
                matcap: !!i.matcap,
                matcapEncoding: d(i.matcap),
                envMap: !!x,
                envMapMode: x && x.mapping,
                envMapEncoding: d(x),
                envMapCubeUV: !!x && (306 === x.mapping || 307 === x.mapping),
                lightMap: !!i.lightMap,
                lightMapEncoding: d(i.lightMap),
                aoMap: !!i.aoMap,
                emissiveMap: !!i.emissiveMap,
                emissiveMapEncoding: d(i.emissiveMap),
                bumpMap: !!i.bumpMap,
                normalMap: !!i.normalMap,
                objectSpaceNormalMap: 1 === i.normalMapType,
                tangentSpaceNormalMap: 0 === i.normalMapType,
                clearcoatMap: !!i.clearcoatMap,
                clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                clearcoatNormalMap: !!i.clearcoatNormalMap,
                displacementMap: !!i.displacementMap,
                roughnessMap: !!i.roughnessMap,
                metalnessMap: !!i.metalnessMap,
                specularMap: !!i.specularMap,
                alphaMap: !!i.alphaMap,
                gradientMap: !!i.gradientMap,
                sheen: !!i.sheen,
                combine: i.combine,
                vertexTangents: i.normalMap && i.vertexTangents,
                vertexColors: i.vertexColors,
                vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap),
                uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || !i.displacementMap),
                fog: !!y,
                useFog: i.fog,
                fogExp2: y && y.isFogExp2,
                flatShading: i.flatShading,
                sizeAttenuation: i.sizeAttenuation,
                logarithmicDepthBuffer: o,
                skinning: i.skinning && w > 0,
                maxBones: w,
                useVertexTexture: a,
                morphTargets: i.morphTargets,
                morphNormals: i.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: u.directional.length,
                numPointLights: u.point.length,
                numSpotLights: u.spot.length,
                numRectAreaLights: u.rectArea.length,
                numHemiLights: u.hemi.length,
                numDirLightShadows: u.directionalShadowMap.length,
                numPointLightShadows: u.pointShadowMap.length,
                numSpotLightShadows: u.spotShadowMap.length,
                numClippingPlanes: m,
                numClipIntersection: v,
                dithering: i.dithering,
                shadowMapEnabled: t.shadowMap.enabled && p.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: i.toneMapped ? t.toneMapping : 0,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: i.premultipliedAlpha,
                alphaTest: i.alphaTest,
                doubleSided: 2 === i.side,
                flipSided: 1 === i.side,
                depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                index0AttributeName: i.index0AttributeName,
                extensionDerivatives: i.extensions && i.extensions.derivatives,
                extensionFragDepth: i.extensions && i.extensions.fragDepth,
                extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: r || null !== e.get("EXT_frag_depth"),
                rendererExtensionDrawBuffers: r || null !== e.get("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: r || null !== e.get("EXT_shader_texture_lod"),
                onBeforeCompile: i.onBeforeCompile
            }
        }, this.getProgramCacheKey = function (e) {
            var n = [];
            if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                for (var i in e.defines) n.push(i), n.push(e.defines[i]);
            if (void 0 === e.isRawShaderMaterial) {
                for (var r = 0; r < u.length; r++) n.push(e[u[r]]);
                n.push(t.outputEncoding), n.push(t.gammaFactor)
            }
            return n.push(e.onBeforeCompile.toString()), n.join()
        }, this.acquireProgram = function (e, n) {
            for (var r, o = 0, a = i.length; o < a; o++) {
                var s = i[o];
                if (s.cacheKey === n) {
                    ++(r = s).usedTimes;
                    break
                }
            }
            return void 0 === r && (r = new Hi(t, n, e), i.push(r)), r
        }, this.releaseProgram = function (t) {
            if (0 == --t.usedTimes) {
                var e = i.indexOf(t);
                i[e] = i[i.length - 1], i.pop(), t.destroy()
            }
        }, this.programs = i
    }

    function Vi() {
        var t = new WeakMap;
        return {
            get: function (e) {
                var n = t.get(e);
                return void 0 === n && (n = {}, t.set(e, n)), n
            },
            remove: function (e) {
                t.delete(e)
            },
            update: function (e, n, i) {
                t.get(e)[n] = i
            },
            dispose: function () {
                t = new WeakMap
            }
        }
    }

    function ji(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function Wi(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }

    function qi() {
        var t = [],
            e = 0,
            n = [],
            i = [],
            r = {
                id: -1
            };

        function o(n, i, o, a, s, l) {
            var c = t[e];
            return void 0 === c ? (c = {
                id: n.id,
                object: n,
                geometry: i,
                material: o,
                program: o.program || r,
                groupOrder: a,
                renderOrder: n.renderOrder,
                z: s,
                group: l
            }, t[e] = c) : (c.id = n.id, c.object = n, c.geometry = i, c.material = o, c.program = o.program || r, c.groupOrder = a, c.renderOrder = n.renderOrder, c.z = s, c.group = l), e++, c
        }
        return {
            opaque: n,
            transparent: i,
            init: function () {
                e = 0, n.length = 0, i.length = 0
            },
            push: function (t, e, r, a, s, l) {
                var c = o(t, e, r, a, s, l);
                (!0 === r.transparent ? i : n).push(c)
            },
            unshift: function (t, e, r, a, s, l) {
                var c = o(t, e, r, a, s, l);
                (!0 === r.transparent ? i : n).unshift(c)
            },
            finish: function () {
                for (var n = e, i = t.length; n < i; n++) {
                    var r = t[n];
                    if (null === r.id) break;
                    r.id = null, r.object = null, r.geometry = null, r.material = null, r.program = null, r.group = null
                }
            },
            sort: function (t, e) {
                n.length > 1 && n.sort(t || ji), i.length > 1 && i.sort(e || Wi)
            }
        }
    }

    function Xi() {
        var t = new WeakMap;

        function e(n) {
            var i = n.target;
            i.removeEventListener("dispose", e), t.delete(i)
        }
        return {
            get: function (n, i) {
                var r, o = t.get(n);
                return void 0 === o ? (r = new qi, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : void 0 === (r = o.get(i)) && (r = new qi, o.set(i, r)), r
            },
            dispose: function () {
                t = new WeakMap
            }
        }
    }

    function Yi() {
        var t = {};
        return {
            get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id];
                var n;
                switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new P,
                            color: new Xt
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new P,
                            direction: new P,
                            color: new Xt,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new P,
                            color: new Xt,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new P,
                            skyColor: new Xt,
                            groundColor: new Xt
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new Xt,
                            position: new P,
                            halfWidth: new P,
                            halfHeight: new P
                        }
                }
                return t[e.id] = n, n
            }
        }
    }
    var Ji = 0;

    function Zi(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
    }

    function Qi() {
        for (var t, e = new Yi, n = (t = {}, {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    var n;
                    switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new _
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new _,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                    }
                    return t[e.id] = n, n
                }
            }), i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            }, r = 0; r < 9; r++) i.probe.push(new P);
        var o = new P,
            a = new B,
            s = new B;
        return {
            setup: function (t, r, l) {
                for (var c = 0, h = 0, u = 0, d = 0; d < 9; d++) i.probe[d].set(0, 0, 0);
                var p = 0,
                    f = 0,
                    m = 0,
                    v = 0,
                    g = 0,
                    y = 0,
                    _ = 0,
                    x = 0,
                    b = l.matrixWorldInverse;
                t.sort(Zi), d = 0;
                for (var w = t.length; d < w; d++) {
                    var M = t[d],
                        S = M.color,
                        T = M.intensity,
                        E = M.distance,
                        A = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
                    if (M.isAmbientLight) c += S.r * T, h += S.g * T, u += S.b * T;
                    else if (M.isLightProbe)
                        for (var C = 0; C < 9; C++) i.probe[C].addScaledVector(M.sh.coefficients[C], T);
                    else if (M.isDirectionalLight) {
                        if ((R = e.get(M)).color.copy(M.color).multiplyScalar(M.intensity), R.direction.setFromMatrixPosition(M.matrixWorld), o.setFromMatrixPosition(M.target.matrixWorld), R.direction.sub(o), R.direction.transformDirection(b), M.castShadow) {
                            var L = M.shadow;
                            (P = n.get(M)).shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, i.directionalShadow[p] = P, i.directionalShadowMap[p] = A, i.directionalShadowMatrix[p] = M.shadow.matrix, y++
                        }
                        i.directional[p] = R, p++
                    } else if (M.isSpotLight) {
                        if ((R = e.get(M)).position.setFromMatrixPosition(M.matrixWorld), R.position.applyMatrix4(b), R.color.copy(S).multiplyScalar(T), R.distance = E, R.direction.setFromMatrixPosition(M.matrixWorld), o.setFromMatrixPosition(M.target.matrixWorld), R.direction.sub(o), R.direction.transformDirection(b), R.coneCos = Math.cos(M.angle), R.penumbraCos = Math.cos(M.angle * (1 - M.penumbra)), R.decay = M.decay, M.castShadow) {
                            L = M.shadow;
                            (P = n.get(M)).shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, i.spotShadow[m] = P, i.spotShadowMap[m] = A, i.spotShadowMatrix[m] = M.shadow.matrix, x++
                        }
                        i.spot[m] = R, m++
                    } else if (M.isRectAreaLight) {
                        (R = e.get(M)).color.copy(S).multiplyScalar(T), R.position.setFromMatrixPosition(M.matrixWorld), R.position.applyMatrix4(b), s.identity(), a.copy(M.matrixWorld), a.premultiply(b), s.extractRotation(a), R.halfWidth.set(.5 * M.width, 0, 0), R.halfHeight.set(0, .5 * M.height, 0), R.halfWidth.applyMatrix4(s), R.halfHeight.applyMatrix4(s), i.rectArea[v] = R, v++
                    } else if (M.isPointLight) {
                        if ((R = e.get(M)).position.setFromMatrixPosition(M.matrixWorld), R.position.applyMatrix4(b), R.color.copy(M.color).multiplyScalar(M.intensity), R.distance = M.distance, R.decay = M.decay, M.castShadow) {
                            var P;
                            L = M.shadow;
                            (P = n.get(M)).shadowBias = L.bias, P.shadowRadius = L.radius, P.shadowMapSize = L.mapSize, P.shadowCameraNear = L.camera.near, P.shadowCameraFar = L.camera.far, i.pointShadow[f] = P, i.pointShadowMap[f] = A, i.pointShadowMatrix[f] = M.shadow.matrix, _++
                        }
                        i.point[f] = R, f++
                    } else if (M.isHemisphereLight) {
                        var R;
                        (R = e.get(M)).direction.setFromMatrixPosition(M.matrixWorld), R.direction.transformDirection(b), R.direction.normalize(), R.skyColor.copy(M.color).multiplyScalar(T), R.groundColor.copy(M.groundColor).multiplyScalar(T), i.hemi[g] = R, g++
                    }
                }
                i.ambient[0] = c, i.ambient[1] = h, i.ambient[2] = u;
                var O = i.hash;
                O.directionalLength === p && O.pointLength === f && O.spotLength === m && O.rectAreaLength === v && O.hemiLength === g && O.numDirectionalShadows === y && O.numPointShadows === _ && O.numSpotShadows === x || (i.directional.length = p, i.spot.length = m, i.rectArea.length = v, i.point.length = f, i.hemi.length = g, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = _, i.pointShadowMap.length = _, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = _, i.spotShadowMatrix.length = x, O.directionalLength = p, O.pointLength = f, O.spotLength = m, O.rectAreaLength = v, O.hemiLength = g, O.numDirectionalShadows = y, O.numPointShadows = _, O.numSpotShadows = x, i.version = Ji++)
            },
            state: i
        }
    }

    function Ki() {
        var t = new Qi,
            e = [],
            n = [];
        return {
            init: function () {
                e.length = 0, n.length = 0
            },
            state: {
                lightsArray: e,
                shadowsArray: n,
                lights: t
            },
            setupLights: function (i) {
                t.setup(e, n, i)
            },
            pushLight: function (t) {
                e.push(t)
            },
            pushShadow: function (t) {
                n.push(t)
            }
        }
    }

    function $i() {
        var t = new WeakMap;

        function e(n) {
            var i = n.target;
            i.removeEventListener("dispose", e), t.delete(i)
        }
        return {
            get: function (n, i) {
                var r;
                return !1 === t.has(n) ? (r = new Ki, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : !1 === t.get(n).has(i) ? (r = new Ki, t.get(n).set(i, r)) : r = t.get(n).get(i), r
            },
            dispose: function () {
                t = new WeakMap
            }
        }
    }

    function tr(t) {
        $t.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
    }

    function er(t) {
        $t.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new P, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
    }
    tr.prototype = Object.create($t.prototype), tr.prototype.constructor = tr, tr.prototype.isMeshDepthMaterial = !0, tr.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, er.prototype = Object.create($t.prototype), er.prototype.constructor = er, er.prototype.isMeshDistanceMaterial = !0, er.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    };

    function nr(t, e, n) {
        var i = new an,
            r = new _,
            o = new _,
            a = new S,
            s = [],
            l = [],
            c = {},
            h = {
                0: 1,
                1: 0,
                2: 2
            },
            u = new Qe({
                defines: {
                    SAMPLE_RATE: 2 / 8,
                    HALF_SAMPLE_RATE: 1 / 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new _
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            }),
            d = u.clone();
        d.defines.HORIZONAL_PASS = 1;
        var p = new be;
        p.setAttribute("position", new ne(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        var f = new Fe(p, u),
            m = this;

        function v(n, i) {
            var r = e.update(f);
            u.uniforms.shadow_pass.value = n.map.texture, u.uniforms.resolution.value = n.mapSize, u.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, u, f, null), d.uniforms.shadow_pass.value = n.mapPass.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, d, f, null)
        }

        function g(t, e, n) {
            var i = t << 0 | e << 1 | n << 2,
                r = s[i];
            return void 0 === r && (r = new tr({
                depthPacking: 3201,
                morphTargets: t,
                skinning: e
            }), s[i] = r), r
        }

        function y(t, e, n) {
            var i = t << 0 | e << 1 | n << 2,
                r = l[i];
            return void 0 === r && (r = new er({
                morphTargets: t,
                skinning: e
            }), l[i] = r), r
        }

        function x(e, n, i, r, o, a, s) {
            var l = null,
                u = g,
                d = e.customDepthMaterial;
            if (!0 === r.isPointLight && (u = y, d = e.customDistanceMaterial), void 0 === d) {
                var p = !1;
                !0 === i.morphTargets && (p = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                var f = !1;
                !0 === e.isSkinnedMesh && (!0 === i.skinning ? f = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), l = u(p, f, !0 === e.isInstancedMesh)
            } else l = d;
            if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                var m = l.uuid,
                    v = i.uuid,
                    _ = c[m];
                void 0 === _ && (_ = {}, c[m] = _);
                var x = _[v];
                void 0 === x && (x = l.clone(), _[v] = x), l = x
            }
            return l.visible = i.visible, l.wireframe = i.wireframe, l.side = 3 === s ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : h[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = o, l.farDistance = a), l
        }

        function b(n, r, o, a, s) {
            if (!1 !== n.visible) {
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    var l = e.update(n),
                        c = n.material;
                    if (Array.isArray(c))
                        for (var h = l.groups, u = 0, d = h.length; u < d; u++) {
                            var p = h[u],
                                f = c[p.materialIndex];
                            if (f && f.visible) {
                                var m = x(n, l, f, a, o.near, o.far, s);
                                t.renderBufferDirect(o, null, l, m, n, p)
                            }
                        } else if (c.visible) {
                            m = x(n, l, c, a, o.near, o.far, s);
                            t.renderBufferDirect(o, null, l, m, n, null)
                        }
                }
                for (var v = n.children, g = 0, y = v.length; g < y; g++) b(v[g], r, o, a, s)
            }
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, s, l) {
            if (!1 !== m.enabled && (!1 !== m.autoUpdate || !1 !== m.needsUpdate) && 0 !== e.length) {
                var c = t.getRenderTarget(),
                    h = t.getActiveCubeFace(),
                    u = t.getActiveMipmapLevel(),
                    d = t.state;
                d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                for (var p = 0, f = e.length; p < f; p++) {
                    var g = e[p],
                        y = g.shadow;
                    if (void 0 !== y) {
                        r.copy(y.mapSize);
                        var _ = y.getFrameExtents();
                        if (r.multiply(_), o.copy(y.mapSize), (r.x > n || r.y > n) && (r.x > n && (o.x = Math.floor(n / _.x), r.x = o.x * _.x, y.mapSize.x = o.x), r.y > n && (o.y = Math.floor(n / _.y), r.y = o.y * _.y, y.mapSize.y = o.y)), null === y.map && !y.isPointLightShadow && 3 === this.type) {
                            var x = {
                                minFilter: 1006,
                                magFilter: 1006,
                                format: 1023
                            };
                            y.map = new T(r.x, r.y, x), y.map.texture.name = g.name + ".shadowMap", y.mapPass = new T(r.x, r.y, x), y.camera.updateProjectionMatrix()
                        }
                        if (null === y.map) {
                            x = {
                                minFilter: 1003,
                                magFilter: 1003,
                                format: 1023
                            };
                            y.map = new T(r.x, r.y, x), y.map.texture.name = g.name + ".shadowMap", y.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(y.map), t.clear();
                        for (var w = y.getViewportCount(), M = 0; M < w; M++) {
                            var S = y.getViewport(M);
                            a.set(o.x * S.x, o.y * S.y, o.x * S.z, o.y * S.w), d.viewport(a), y.updateMatrices(g, M), i = y.getFrustum(), b(s, l, y.camera, g, this.type)
                        }
                        y.isPointLightShadow || 3 !== this.type || v(y, l)
                    } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.")
                }
                m.needsUpdate = !1, t.setRenderTarget(c, h, u)
            }
        }
    }

    function ir(t, e, n) {
        var i = n.isWebGL2;
        var r = new function () {
                var e = !1,
                    n = new S,
                    i = null,
                    r = new S(0, 0, 0, 0);
                return {
                    setMask: function (n) {
                        i === n || e || (t.colorMask(n, n, n, n), i = n)
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e, i, o, a, s) {
                        !0 === s && (e *= a, i *= a, o *= a), n.set(e, i, o, a), !1 === r.equals(n) && (t.clearColor(e, i, o, a), r.copy(n))
                    },
                    reset: function () {
                        e = !1, i = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
            o = new function () {
                var e = !1,
                    n = null,
                    i = null,
                    r = null;
                return {
                    setTest: function (t) {
                        t ? F(2929) : U(2929)
                    },
                    setMask: function (i) {
                        n === i || e || (t.depthMask(i), n = i)
                    },
                    setFunc: function (e) {
                        if (i !== e) {
                            if (e) switch (e) {
                                case 0:
                                    t.depthFunc(512);
                                    break;
                                case 1:
                                    t.depthFunc(519);
                                    break;
                                case 2:
                                    t.depthFunc(513);
                                    break;
                                case 3:
                                    t.depthFunc(515);
                                    break;
                                case 4:
                                    t.depthFunc(514);
                                    break;
                                case 5:
                                    t.depthFunc(518);
                                    break;
                                case 6:
                                    t.depthFunc(516);
                                    break;
                                case 7:
                                    t.depthFunc(517);
                                    break;
                                default:
                                    t.depthFunc(515)
                            } else t.depthFunc(515);
                            i = e
                        }
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e) {
                        r !== e && (t.clearDepth(e), r = e)
                    },
                    reset: function () {
                        e = !1, n = null, i = null, r = null
                    }
                }
            },
            a = new function () {
                var e = !1,
                    n = null,
                    i = null,
                    r = null,
                    o = null,
                    a = null,
                    s = null,
                    l = null,
                    c = null;
                return {
                    setTest: function (t) {
                        e || (t ? F(2960) : U(2960))
                    },
                    setMask: function (i) {
                        n === i || e || (t.stencilMask(i), n = i)
                    },
                    setFunc: function (e, n, a) {
                        i === e && r === n && o === a || (t.stencilFunc(e, n, a), i = e, r = n, o = a)
                    },
                    setOp: function (e, n, i) {
                        a === e && s === n && l === i || (t.stencilOp(e, n, i), a = e, s = n, l = i)
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e) {
                        c !== e && (t.clearStencil(e), c = e)
                    },
                    reset: function () {
                        e = !1, n = null, i = null, r = null, o = null, a = null, s = null, l = null, c = null
                    }
                }
            },
            s = t.getParameter(34921),
            l = new Uint8Array(s),
            c = new Uint8Array(s),
            h = new Uint8Array(s),
            u = {},
            d = null,
            p = null,
            f = null,
            m = null,
            v = null,
            g = null,
            y = null,
            _ = null,
            x = null,
            b = !1,
            w = null,
            M = null,
            T = null,
            E = null,
            A = null,
            C = t.getParameter(35661),
            L = !1,
            P = 0,
            R = t.getParameter(7938); - 1 !== R.indexOf("WebGL") ? (P = parseFloat(/^WebGL\ ([0-9])/.exec(R)[1]), L = P >= 1) : -1 !== R.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(R)[1]), L = P >= 2);
        var O = null,
            D = {},
            I = new S,
            N = new S;

        function k(e, n, i) {
            var r = new Uint8Array(4),
                o = t.createTexture();
            t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
            for (var a = 0; a < i; a++) t.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return o
        }
        var z = {};

        function B(n, r) {
            (l[n] = 1, 0 === c[n] && (t.enableVertexAttribArray(n), c[n] = 1), h[n] !== r) && ((i ? t : e.get("ANGLE_instanced_arrays"))[i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), h[n] = r)
        }

        function F(e) {
            !0 !== u[e] && (t.enable(e), u[e] = !0)
        }

        function U(e) {
            !1 !== u[e] && (t.disable(e), u[e] = !1)
        }
        z[3553] = k(3553, 3553, 1), z[34067] = k(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), F(2929), o.setFunc(3), W(!1), q(1), F(2884), j(0);
        var H = {
            100: 32774,
            101: 32778,
            102: 32779
        };
        if (i) H[103] = 32775, H[104] = 32776;
        else {
            var G = e.get("EXT_blend_minmax");
            null !== G && (H[103] = G.MIN_EXT, H[104] = G.MAX_EXT)
        }
        var V = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
        };

        function j(e, n, i, r, o, a, s, l) {
            if (0 !== e) {
                if (p || (F(3042), p = !0), 5 === e) o = o || n, a = a || i, s = s || r, n === m && o === y || (t.blendEquationSeparate(H[n], H[o]), m = n, y = o), i === v && r === g && a === _ && s === x || (t.blendFuncSeparate(V[i], V[r], V[a], V[s]), v = i, g = r, _ = a, x = s), f = e, b = null;
                else if (e !== f || l !== b) {
                    if (100 === m && 100 === y || (t.blendEquation(32774), m = 100, y = 100), l) switch (e) {
                        case 1:
                            t.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(1, 1);
                            break;
                        case 3:
                            t.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            t.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    } else switch (e) {
                        case 1:
                            t.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(770, 1);
                            break;
                        case 3:
                            t.blendFunc(0, 769);
                            break;
                        case 4:
                            t.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    }
                    v = null, g = null, _ = null, x = null, f = e, b = l
                }
            } else p && (U(3042), p = !1)
        }

        function W(e) {
            w !== e && (e ? t.frontFace(2304) : t.frontFace(2305), w = e)
        }

        function q(e) {
            0 !== e ? (F(2884), e !== M && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : U(2884), M = e
        }

        function X(e, n, i) {
            e ? (F(32823), E === n && A === i || (t.polygonOffset(n, i), E = n, A = i)) : U(32823)
        }

        function Y(e) {
            void 0 === e && (e = 33984 + C - 1), O !== e && (t.activeTexture(e), O = e)
        }
        return {
            buffers: {
                color: r,
                depth: o,
                stencil: a
            },
            initAttributes: function () {
                for (var t = 0, e = l.length; t < e; t++) l[t] = 0
            },
            enableAttribute: function (t) {
                B(t, 0)
            },
            enableAttributeAndDivisor: B,
            disableUnusedAttributes: function () {
                for (var e = 0, n = c.length; e !== n; ++e) c[e] !== l[e] && (t.disableVertexAttribArray(e), c[e] = 0)
            },
            vertexAttribPointer: function (e, n, r, o, a, s) {
                !0 !== i || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, a, s) : t.vertexAttribIPointer(e, n, r, o, a, s)
            },
            enable: F,
            disable: U,
            useProgram: function (e) {
                return d !== e && (t.useProgram(e), d = e, !0)
            },
            setBlending: j,
            setMaterial: function (t, e) {
                2 === t.side ? U(2884) : F(2884);
                var n = 1 === t.side;
                e && (n = !n), W(n), 1 === t.blending && !1 === t.transparent ? j(0) : j(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), r.setMask(t.colorWrite);
                var i = t.stencilWrite;
                a.setTest(i), i && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            },
            setFlipSided: W,
            setCullFace: q,
            setLineWidth: function (e) {
                e !== T && (L && t.lineWidth(e), T = e)
            },
            setPolygonOffset: X,
            setScissorTest: function (t) {
                t ? F(3089) : U(3089)
            },
            activeTexture: Y,
            bindTexture: function (e, n) {
                null === O && Y();
                var i = D[O];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                }, D[O] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || z[e]), i.type = e, i.texture = n)
            },
            unbindTexture: function () {
                var e = D[O];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
            },
            compressedTexImage2D: function () {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function () {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage3D: function () {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function (e) {
                !1 === I.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), I.copy(e))
            },
            viewport: function (e) {
                !1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), N.copy(e))
            },
            reset: function () {
                for (var e = 0; e < c.length; e++) 1 === c[e] && (t.disableVertexAttribArray(e), c[e] = 0);
                u = {}, O = null, D = {}, d = null, f = null, w = null, M = null, r.reset(), o.reset(), a.reset()
            }
        }
    }

    function rr(t, e, n, i, r, o, a) {
        var s, l = r.isWebGL2,
            c = r.maxTextures,
            h = r.maxCubemapSize,
            u = r.maxTextureSize,
            d = r.maxSamples,
            p = new WeakMap,
            f = !1;
        try {
            f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (t) {}

        function m(t, e) {
            return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function v(t, e, n, i) {
            var r = 1;
            if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    var o = e ? y.floorPowerOfTwo : Math.floor,
                        a = o(r * t.width),
                        l = o(r * t.height);
                    void 0 === s && (s = m(a, l));
                    var c = n ? m(a, l) : s;
                    return c.width = a, c.height = l, c.getContext("2d").drawImage(t, 0, 0, a, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a + "x" + l + ")."), c
                }
                return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
            }
            return t
        }

        function g(t) {
            return y.isPowerOfTwo(t.width) && y.isPowerOfTwo(t.height)
        }

        function _(t, e) {
            return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        }

        function x(e, n, r, o) {
            t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
        }

        function b(n, i, r) {
            if (!1 === l) return i;
            if (null !== n) {
                if (void 0 !== t[n]) return t[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            var o = i;
            return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
        }

        function w(t) {
            return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
        }

        function M(e) {
            var n = e.target;
            n.removeEventListener("dispose", M),
                function (e) {
                    var n = i.get(e);
                    if (void 0 === n.__webglInit) return;
                    t.deleteTexture(n.__webglTexture), i.remove(e)
                }(n), n.isVideoTexture && p.delete(n), a.memory.textures--
        }

        function S(e) {
            var n = e.target;
            n.removeEventListener("dispose", S),
                function (e) {
                    var n = i.get(e),
                        r = i.get(e.texture);
                    if (!e) return;
                    void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLCubeRenderTarget)
                        for (var o = 0; o < 6; o++) t.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                    else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                    i.remove(e.texture), i.remove(e)
                }(n), a.memory.textures--
        }
        var T = 0;

        function E(t, e) {
            var r = i.get(t);
            if (t.isVideoTexture && function (t) {
                    var e = a.render.frame;
                    p.get(t) !== e && (p.set(t, e), t.update())
                }(t), t.version > 0 && r.__version !== t.version) {
                var o = t.image;
                if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== o.complete) return void D(r, t, e);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
        }

        function A(e, r) {
            if (6 === e.image.length) {
                var a = i.get(e);
                if (e.version > 0 && a.__version !== e.version) {
                    O(a, e), n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture), t.pixelStorei(37440, e.flipY);
                    for (var s = e && (e.isCompressedTexture || e.image[0].isCompressedTexture), c = e.image[0] && e.image[0].isDataTexture, u = [], d = 0; d < 6; d++) u[d] = s || c ? c ? e.image[d].image : e.image[d] : v(e.image[d], !1, !0, h);
                    var p, f = u[0],
                        m = g(f) || l,
                        y = o.convert(e.format),
                        w = o.convert(e.type),
                        M = b(e.internalFormat, y, w);
                    if (R(34067, e, m), s) {
                        for (d = 0; d < 6; d++) {
                            p = u[d].mipmaps;
                            for (var S = 0; S < p.length; S++) {
                                var T = p[S];
                                1023 !== e.format && 1022 !== e.format ? null !== y ? n.compressedTexImage2D(34069 + d, S, M, T.width, T.height, 0, T.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + d, S, M, T.width, T.height, 0, y, w, T.data)
                            }
                        }
                        a.__maxMipLevel = p.length - 1
                    } else {
                        p = e.mipmaps;
                        for (d = 0; d < 6; d++)
                            if (c) {
                                n.texImage2D(34069 + d, 0, M, u[d].width, u[d].height, 0, y, w, u[d].data);
                                for (S = 0; S < p.length; S++) {
                                    var E = (T = p[S]).image[d].image;
                                    n.texImage2D(34069 + d, S + 1, M, E.width, E.height, 0, y, w, E.data)
                                }
                            } else {
                                n.texImage2D(34069 + d, 0, M, y, w, u[d]);
                                for (S = 0; S < p.length; S++) {
                                    T = p[S];
                                    n.texImage2D(34069 + d, S + 1, M, y, w, T.image[d])
                                }
                            } a.__maxMipLevel = p.length
                    }
                    _(e, m) && x(34067, e, f.width, f.height), a.__version = e.version, e.onUpdate && e.onUpdate(e)
                } else n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture)
            }
        }

        function C(t, e) {
            n.activeTexture(33984 + e), n.bindTexture(34067, i.get(t).__webglTexture)
        }
        var L = {
                1e3: 10497,
                1001: 33071,
                1002: 33648
            },
            P = {
                1003: 9728,
                1004: 9984,
                1005: 9986,
                1006: 9729,
                1007: 9985,
                1008: 9987
            };

        function R(n, o, a) {
            a ? (t.texParameteri(n, 10242, L[o.wrapS]), t.texParameteri(n, 10243, L[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, L[o.wrapR]), t.texParameteri(n, 10240, P[o.magFilter]), t.texParameteri(n, 10241, P[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), 1001 === o.wrapS && 1001 === o.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(o.magFilter)), t.texParameteri(n, 10241, w(o.minFilter)), 1003 !== o.minFilter && 1006 !== o.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
            var s = e.get("EXT_texture_filter_anisotropic");
            if (s) {
                if (1015 === o.type && null === e.get("OES_texture_float_linear")) return;
                if (1016 === o.type && null === (l || e.get("OES_texture_half_float_linear"))) return;
                (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
            }
        }

        function O(e, n) {
            void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", M), e.__webglTexture = t.createTexture(), a.memory.textures++)
        }

        function D(e, i, r) {
            var a = 3553;
            i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), O(e, i), n.activeTexture(33984 + r), n.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment);
            var s = function (t) {
                    return !l && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter)
                }(i) && !1 === g(i.image),
                c = v(i.image, s, !1, u),
                h = g(c) || l,
                d = o.convert(i.format),
                p = o.convert(i.type),
                f = b(i.internalFormat, d, p);
            R(a, i, h);
            var m, y = i.mipmaps;
            if (i.isDepthTexture) f = 6402, l ? f = 1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i.format && 6402 === f && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = 1012, p = o.convert(i.type)), 1027 === i.format && 6402 === f && (f = 34041, 1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = 1020, p = o.convert(i.type))), n.texImage2D(3553, 0, f, c.width, c.height, 0, d, p, null);
            else if (i.isDataTexture)
                if (y.length > 0 && h) {
                    for (var w = 0, M = y.length; w < M; w++) m = y[w], n.texImage2D(3553, w, f, m.width, m.height, 0, d, p, m.data);
                    i.generateMipmaps = !1, e.__maxMipLevel = y.length - 1
                } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, p, c.data), e.__maxMipLevel = 0;
            else if (i.isCompressedTexture) {
                for (w = 0, M = y.length; w < M; w++) m = y[w], 1023 !== i.format && 1022 !== i.format ? null !== d ? n.compressedTexImage2D(3553, w, f, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, w, f, m.width, m.height, 0, d, p, m.data);
                e.__maxMipLevel = y.length - 1
            } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, p, c.data), e.__maxMipLevel = 0;
            else if (i.isDataTexture3D) n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, p, c.data), e.__maxMipLevel = 0;
            else if (y.length > 0 && h) {
                for (w = 0, M = y.length; w < M; w++) m = y[w], n.texImage2D(3553, w, f, d, p, m);
                i.generateMipmaps = !1, e.__maxMipLevel = y.length - 1
            } else n.texImage2D(3553, 0, f, d, p, c), e.__maxMipLevel = 0;
            _(i, h) && x(a, i, c.width, c.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
        }

        function I(e, r, a, s) {
            var l = o.convert(r.texture.format),
                c = o.convert(r.texture.type),
                h = b(r.texture.internalFormat, l, c);
            n.texImage2D(s, 0, h, r.width, r.height, 0, l, c, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, s, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
        }

        function N(e, n, i) {
            if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                var r = 33189;
                if (i) {
                    var a = n.depthTexture;
                    a && a.isDepthTexture && (1015 === a.type ? r = 36012 : 1014 === a.type && (r = 33190));
                    var s = z(n);
                    t.renderbufferStorageMultisample(36161, s, r, n.width, n.height)
                } else t.renderbufferStorage(36161, r, n.width, n.height);
                t.framebufferRenderbuffer(36160, 36096, 36161, e)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (i) {
                    s = z(n);
                    t.renderbufferStorageMultisample(36161, s, 35056, n.width, n.height)
                } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                t.framebufferRenderbuffer(36160, 33306, 36161, e)
            } else {
                var l = o.convert(n.texture.format),
                    c = o.convert(n.texture.type);
                r = b(n.texture.internalFormat, l, c);
                if (i) {
                    s = z(n);
                    t.renderbufferStorageMultisample(36161, s, r, n.width, n.height)
                } else t.renderbufferStorage(36161, r, n.width, n.height)
            }
            t.bindRenderbuffer(36161, null)
        }

        function k(e) {
            var n = i.get(e),
                r = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
                if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function (e, n) {
                    if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), E(n.depthTexture, 0);
                    var r = i.get(n.depthTexture).__webglTexture;
                    if (1026 === n.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                    else {
                        if (1027 !== n.depthTexture.format) throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                    }
                }(n.__webglFramebuffer, e)
            } else if (r) {
                n.__webglDepthbuffer = [];
                for (var o = 0; o < 6; o++) t.bindFramebuffer(36160, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = t.createRenderbuffer(), N(n.__webglDepthbuffer[o], e, !1)
            } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), N(n.__webglDepthbuffer, e, !1);
            t.bindFramebuffer(36160, null)
        }

        function z(t) {
            return l && t.isWebGLMultisampleRenderTarget ? Math.min(d, t.samples) : 0
        }
        var B = !1,
            F = !1;
        this.allocateTextureUnit = function () {
            var t = T;
            return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), T += 1, t
        }, this.resetTextureUnits = function () {
            T = 0
        }, this.setTexture2D = E, this.setTexture2DArray = function (t, e) {
            var r = i.get(t);
            t.version > 0 && r.__version !== t.version ? D(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
        }, this.setTexture3D = function (t, e) {
            var r = i.get(t);
            t.version > 0 && r.__version !== t.version ? D(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
        }, this.setTextureCube = A, this.setTextureCubeDynamic = C, this.setupRenderTarget = function (e) {
            var r = i.get(e),
                s = i.get(e.texture);
            e.addEventListener("dispose", S), s.__webglTexture = t.createTexture(), a.memory.textures++;
            var c = !0 === e.isWebGLCubeRenderTarget,
                h = !0 === e.isWebGLMultisampleRenderTarget,
                u = g(e) || l;
            if (!l || 1022 !== e.texture.format || 1015 !== e.texture.type && 1016 !== e.texture.type || (e.texture.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c) {
                r.__webglFramebuffer = [];
                for (var d = 0; d < 6; d++) r.__webglFramebuffer[d] = t.createFramebuffer()
            } else if (r.__webglFramebuffer = t.createFramebuffer(), h)
                if (l) {
                    r.__webglMultisampledFramebuffer = t.createFramebuffer(), r.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
                    var p = o.convert(e.texture.format),
                        f = o.convert(e.texture.type),
                        m = b(e.texture.internalFormat, p, f),
                        v = z(e);
                    t.renderbufferStorageMultisample(36161, v, m, e.width, e.height), t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(), N(r.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (c) {
                n.bindTexture(34067, s.__webglTexture), R(34067, e.texture, u);
                for (d = 0; d < 6; d++) I(r.__webglFramebuffer[d], e, 36064, 34069 + d);
                _(e.texture, u) && x(34067, e.texture, e.width, e.height), n.bindTexture(34067, null)
            } else n.bindTexture(3553, s.__webglTexture), R(3553, e.texture, u), I(r.__webglFramebuffer, e, 36064, 3553), _(e.texture, u) && x(3553, e.texture, e.width, e.height), n.bindTexture(3553, null);
            e.depthBuffer && k(e)
        }, this.updateRenderTargetMipmap = function (t) {
            var e = t.texture;
            if (_(e, g(t) || l)) {
                var r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                    o = i.get(e).__webglTexture;
                n.bindTexture(r, o), x(r, e, t.width, t.height), n.bindTexture(r, null)
            }
        }, this.updateMultisampleRenderTarget = function (e) {
            if (e.isWebGLMultisampleRenderTarget)
                if (l) {
                    var n = i.get(e);
                    t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                    var r = e.width,
                        o = e.height,
                        a = 16384;
                    e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, a, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function (t, e) {
            t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), E(t, e)
        }, this.safeSetTextureCube = function (t, e) {
            t && t.isWebGLCubeRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), F = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? A(t, e) : C(t, e)
        }
    }

    function or(t, e, n) {
        var i = n.isWebGL2;
        return {
            convert: function (t) {
                var n;
                if (1009 === t) return 5121;
                if (1017 === t) return 32819;
                if (1018 === t) return 32820;
                if (1019 === t) return 33635;
                if (1010 === t) return 5120;
                if (1011 === t) return 5122;
                if (1012 === t) return 5123;
                if (1013 === t) return 5124;
                if (1014 === t) return 5125;
                if (1015 === t) return 5126;
                if (1016 === t) return i ? 5131 : null !== (n = e.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null;
                if (1021 === t) return 6406;
                if (1022 === t) return 6407;
                if (1023 === t) return 6408;
                if (1024 === t) return 6409;
                if (1025 === t) return 6410;
                if (1026 === t) return 6402;
                if (1027 === t) return 34041;
                if (1028 === t) return 6403;
                if (1029 === t) return 36244;
                if (1030 === t) return 33319;
                if (1031 === t) return 33320;
                if (1032 === t) return 36248;
                if (1033 === t) return 36249;
                if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                    if (null === (n = e.get("WEBGL_compressed_texture_s3tc"))) return null;
                    if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                    if (null === (n = e.get("WEBGL_compressed_texture_pvrtc"))) return null;
                    if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === t) return null !== (n = e.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((37492 === t || 37496 === t) && null !== (n = e.get("WEBGL_compressed_texture_etc"))) {
                    if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
                    if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? null !== (n = e.get("WEBGL_compressed_texture_astc")) ? t : null : 36492 === t ? null !== (n = e.get("EXT_texture_compression_bptc")) ? t : null : 1020 === t ? i ? 34042 : null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0
            }
        }
    }

    function ar(t) {
        $e.call(this), this.cameras = t || []
    }

    function sr() {
        nt.call(this), this.type = "Group"
    }

    function lr() {
        this._targetRay = null, this._grip = null
    }

    function cr(t, e) {
        var n = this,
            i = null,
            r = 1,
            o = null,
            a = "local-floor",
            s = null,
            l = [],
            c = new Map,
            h = new $e;
        h.layers.enable(1), h.viewport = new S;
        var u = new $e;
        u.layers.enable(2), u.viewport = new S;
        var d = [h, u],
            p = new ar;
        p.layers.enable(1), p.layers.enable(2);
        var f = null,
            m = null;

        function v(t) {
            var e = c.get(t.inputSource);
            e && e.dispatchEvent({
                type: t.type
            })
        }

        function g() {
            c.forEach((function (t, e) {
                t.disconnect(e)
            })), c.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), T.stop(), n.isPresenting = !1, n.dispatchEvent({
                type: "sessionend"
            })
        }

        function y(t) {
            o = t, T.setContext(i), T.start(), n.isPresenting = !0, n.dispatchEvent({
                type: "sessionstart"
            })
        }

        function _(t) {
            for (var e = i.inputSources, n = 0; n < l.length; n++) c.set(e[n], l[n]);
            for (n = 0; n < t.removed.length; n++) {
                var r = t.removed[n];
                (o = c.get(r)) && (o.dispatchEvent({
                    type: "disconnected",
                    data: r
                }), c.delete(r))
            }
            for (n = 0; n < t.added.length; n++) {
                var o;
                r = t.added[n];
                (o = c.get(r)) && o.dispatchEvent({
                    type: "connected",
                    data: r
                })
            }
        }
        this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
            var e = l[t];
            return void 0 === e && (e = new lr, l[t] = e), e.getTargetRaySpace()
        }, this.getControllerGrip = function (t) {
            var e = l[t];
            return void 0 === e && (e = new lr, l[t] = e), e.getGripSpace()
        }, this.setFramebufferScaleFactor = function (t) {
            r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function (t) {
            a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function () {
            return o
        }, this.getSession = function () {
            return i
        }, this.setSession = function (t) {
            if (null !== (i = t)) {
                i.addEventListener("select", v), i.addEventListener("selectstart", v), i.addEventListener("selectend", v), i.addEventListener("squeeze", v), i.addEventListener("squeezestart", v), i.addEventListener("squeezeend", v), i.addEventListener("end", g);
                var n = e.getContextAttributes(),
                    o = {
                        antialias: n.antialias,
                        alpha: n.alpha,
                        depth: n.depth,
                        stencil: n.stencil,
                        framebufferScaleFactor: r
                    },
                    s = new XRWebGLLayer(i, e, o);
                i.updateRenderState({
                    baseLayer: s
                }), i.requestReferenceSpace(a).then(y), i.addEventListener("inputsourceschange", _)
            }
        };
        var x = new P,
            b = new P;

        function w(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
        }
        this.getCamera = function (t) {
            p.near = u.near = h.near = t.near, p.far = u.far = h.far = t.far, f === p.near && m === p.far || (i.updateRenderState({
                depthNear: p.near,
                depthFar: p.far
            }), f = p.near, m = p.far);
            var e = t.parent,
                n = p.cameras;
            w(p, e);
            for (var r = 0; r < n.length; r++) w(n[r], e);
            t.matrixWorld.copy(p.matrixWorld);
            for (var o = t.children, a = (r = 0, o.length); r < a; r++) o[r].updateMatrixWorld(!0);
            return 2 === n.length ? function (t, e, n) {
                x.setFromMatrixPosition(e.matrixWorld), b.setFromMatrixPosition(n.matrixWorld);
                var i = x.distanceTo(b),
                    r = e.projectionMatrix.elements,
                    o = n.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    h = (r[8] - 1) / r[0],
                    u = (o[8] + 1) / o[0],
                    d = a * h,
                    p = a * u,
                    f = i / (-h + u),
                    m = f * -h;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                var v = a + f,
                    g = s + f,
                    y = d - m,
                    _ = p + (i - m),
                    w = l * s / g * v,
                    M = c * s / g * v;
                t.projectionMatrix.makePerspective(y, _, w, M, v, g)
            }(p, h, u) : p.projectionMatrix.copy(h.projectionMatrix), p
        };
        var M = null;
        var T = new ln;
        T.setAnimationLoop((function (e, n) {
            if (null !== (s = n.getViewerPose(o))) {
                var r = s.views,
                    a = i.renderState.baseLayer;
                t.setFramebuffer(a.framebuffer);
                var c = !1;
                r.length !== p.cameras.length && (p.cameras.length = 0, c = !0);
                for (var h = 0; h < r.length; h++) {
                    var u = r[h],
                        f = a.getViewport(u),
                        m = d[h];
                    m.matrix.fromArray(u.transform.matrix), m.projectionMatrix.fromArray(u.projectionMatrix), m.viewport.set(f.x, f.y, f.width, f.height), 0 === h && p.matrix.copy(m.matrix), !0 === c && p.cameras.push(m)
                }
            }
            var v = i.inputSources;
            for (h = 0; h < l.length; h++) {
                var g = l[h],
                    y = v[h];
                g.update(y, n, o)
            }
            M && M(e, n)
        })), this.setAnimationLoop = function (t) {
            M = t
        }, this.dispose = function () {}
    }

    function hr(t) {
        var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            n = void 0 !== t.context ? t.context : null,
            i = void 0 !== t.alpha && t.alpha,
            r = void 0 === t.depth || t.depth,
            o = void 0 === t.stencil || t.stencil,
            a = void 0 !== t.antialias && t.antialias,
            s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            c = void 0 !== t.powerPreference ? t.powerPreference : "default",
            h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
            u = null,
            d = null;
        this.domElement = e, this.debug = {
            checkShaderErrors: !0
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var p, f, m, v, g, x, b, w, M, T, E, A, C, L, R, O, D, I, N = this,
            k = !1,
            z = null,
            F = 0,
            U = 0,
            H = null,
            G = null,
            V = -1,
            j = {
                geometry: null,
                program: null,
                wireframe: !1
            },
            W = null,
            q = null,
            X = new S,
            Y = new S,
            J = null,
            Z = e.width,
            Q = e.height,
            K = 1,
            $ = null,
            tt = null,
            et = new S(0, 0, Z, Q),
            nt = new S(0, 0, Z, Q),
            rt = !1,
            ot = new an,
            at = new gn,
            st = !1,
            lt = !1,
            ct = new B,
            ht = new P;

        function ut() {
            return null === H ? K : 1
        }
        try {
            var dt = {
                alpha: i,
                depth: r,
                stencil: o,
                antialias: a,
                premultipliedAlpha: s,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: h,
                xrCompatible: !0
            };
            if (e.addEventListener("webglcontextlost", vt, !1), e.addEventListener("webglcontextrestored", gt, !1), null === (p = n || e.getContext("webgl", dt) || e.getContext("experimental-webgl", dt))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === p.getShaderPrecisionFormat && (p.getShaderPrecisionFormat = function () {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (t) {
            throw console.error("THREE.WebGLRenderer: " + t.message), t
        }

        function pt() {
            f = new yn(p), !1 === (m = new vn(p, f, t)).isWebGL2 && (f.get("WEBGL_depth_texture"), f.get("OES_texture_float"), f.get("OES_texture_half_float"), f.get("OES_texture_half_float_linear"), f.get("OES_standard_derivatives"), f.get("OES_element_index_uint"), f.get("ANGLE_instanced_arrays")), f.get("OES_texture_float_linear"), I = new or(p, f, m), (v = new ir(p, f, m)).scissor(Y.copy(nt).multiplyScalar(K).floor()), v.viewport(X.copy(et).multiplyScalar(K).floor()), g = new bn(p), x = new Vi, b = new rr(p, f, v, x, m, I, g), w = new cn(p, m), M = new _n(p, w, g), T = new Sn(p, M, w, g), R = new Mn(p), E = new Gi(N, f, m), A = new Xi, C = new $i, L = new fn(N, v, T, s), O = new mn(p, f, g, m), D = new xn(p, f, g, m), g.programs = E.programs, N.capabilities = m, N.extensions = f, N.properties = x, N.renderLists = A, N.state = v, N.info = g
        }
        pt();
        var ft = new cr(N, p);
        this.xr = ft;
        var mt = new nr(N, T, m.maxTextureSize);

        function vt(t) {
            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), k = !0
        }

        function gt() {
            console.log("THREE.WebGLRenderer: Context Restored."), k = !1, pt()
        }

        function yt(t) {
            var e = t.target;
            e.removeEventListener("dispose", yt),
                function (t) {
                    _t(t), x.remove(t)
                }(e)
        }

        function _t(t) {
            var e = x.get(t).program;
            t.program = void 0, void 0 !== e && E.releaseProgram(e)
        }
        this.shadowMap = mt, this.getContext = function () {
            return p
        }, this.getContextAttributes = function () {
            return p.getContextAttributes()
        }, this.forceContextLoss = function () {
            var t = f.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function () {
            var t = f.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function () {
            return K
        }, this.setPixelRatio = function (t) {
            void 0 !== t && (K = t, this.setSize(Z, Q, !1))
        }, this.getSize = function (t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new _), t.set(Z, Q)
        }, this.setSize = function (t, n, i) {
            ft.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Z = t, Q = n, e.width = Math.floor(t * K), e.height = Math.floor(n * K), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
        }, this.getDrawingBufferSize = function (t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new _), t.set(Z * K, Q * K).floor()
        }, this.setDrawingBufferSize = function (t, n, i) {
            Z = t, Q = n, K = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
        }, this.getCurrentViewport = function (t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new S), t.copy(X)
        }, this.getViewport = function (t) {
            return t.copy(et)
        }, this.setViewport = function (t, e, n, i) {
            t.isVector4 ? et.set(t.x, t.y, t.z, t.w) : et.set(t, e, n, i), v.viewport(X.copy(et).multiplyScalar(K).floor())
        }, this.getScissor = function (t) {
            return t.copy(nt)
        }, this.setScissor = function (t, e, n, i) {
            t.isVector4 ? nt.set(t.x, t.y, t.z, t.w) : nt.set(t, e, n, i), v.scissor(Y.copy(nt).multiplyScalar(K).floor())
        }, this.getScissorTest = function () {
            return rt
        }, this.setScissorTest = function (t) {
            v.setScissorTest(rt = t)
        }, this.setOpaqueSort = function (t) {
            $ = t
        }, this.setTransparentSort = function (t) {
            tt = t
        }, this.getClearColor = function () {
            return L.getClearColor()
        }, this.setClearColor = function () {
            L.setClearColor.apply(L, arguments)
        }, this.getClearAlpha = function () {
            return L.getClearAlpha()
        }, this.setClearAlpha = function () {
            L.setClearAlpha.apply(L, arguments)
        }, this.clear = function (t, e, n) {
            var i = 0;
            (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), p.clear(i)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            e.removeEventListener("webglcontextlost", vt, !1), e.removeEventListener("webglcontextrestored", gt, !1), A.dispose(), C.dispose(), x.dispose(), T.dispose(), ft.dispose(), wt.stop()
        }, this.renderBufferImmediate = function (t, e) {
            v.initAttributes();
            var n = x.get(t);
            t.hasPositions && !n.position && (n.position = p.createBuffer()), t.hasNormals && !n.normal && (n.normal = p.createBuffer()), t.hasUvs && !n.uv && (n.uv = p.createBuffer()), t.hasColors && !n.color && (n.color = p.createBuffer());
            var i = e.getAttributes();
            t.hasPositions && (p.bindBuffer(34962, n.position), p.bufferData(34962, t.positionArray, 35048), v.enableAttribute(i.position), p.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (p.bindBuffer(34962, n.normal), p.bufferData(34962, t.normalArray, 35048), v.enableAttribute(i.normal), p.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (p.bindBuffer(34962, n.uv), p.bufferData(34962, t.uvArray, 35048), v.enableAttribute(i.uv), p.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (p.bindBuffer(34962, n.color), p.bufferData(34962, t.colorArray, 35048), v.enableAttribute(i.color), p.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), v.disableUnusedAttributes(), p.drawArrays(4, 0, t.count), t.count = 0
        };
        var xt = new it;
        this.renderBufferDirect = function (t, e, n, i, r, o) {
            null === e && (e = xt);
            var a = r.isMesh && r.matrixWorld.determinant() < 0,
                s = At(t, e, i, r);
            v.setMaterial(i, a);
            var l = !1;
            j.geometry === n.id && j.program === s.id && j.wireframe === (!0 === i.wireframe) || (j.geometry = n.id, j.program = s.id, j.wireframe = !0 === i.wireframe, l = !0), (i.morphTargets || i.morphNormals) && (R.update(r, n, i, s), l = !0), !0 === r.isInstancedMesh && (l = !0);
            var c = n.index,
                h = n.attributes.position;
            if (null === c) {
                if (void 0 === h || 0 === h.count) return
            } else if (0 === c.count) return;
            var u, d = 1;
            !0 === i.wireframe && (c = M.getWireframeAttribute(n), d = 2);
            var g = O;
            null !== c && (u = w.get(c), (g = D).setIndex(u)), l && (! function (t, e, n, i) {
                if (!1 === m.isWebGL2 && (t.isInstancedMesh || e.isInstancedBufferGeometry) && null === f.get("ANGLE_instanced_arrays")) return;
                v.initAttributes();
                var r = e.attributes,
                    o = i.getAttributes(),
                    a = n.defaultAttributeValues;
                for (var s in o) {
                    var l = o[s];
                    if (l >= 0) {
                        var c = r[s];
                        if (void 0 !== c) {
                            var h = c.normalized,
                                u = c.itemSize;
                            if (void 0 === (M = w.get(c))) continue;
                            var d = M.buffer,
                                g = M.type,
                                y = M.bytesPerElement;
                            if (c.isInterleavedBufferAttribute) {
                                var _ = c.data,
                                    x = _.stride,
                                    b = c.offset;
                                _ && _.isInstancedInterleavedBuffer ? (v.enableAttributeAndDivisor(l, _.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = _.meshPerAttribute * _.count)) : v.enableAttribute(l), p.bindBuffer(34962, d), v.vertexAttribPointer(l, u, g, h, x * y, b * y)
                            } else c.isInstancedBufferAttribute ? (v.enableAttributeAndDivisor(l, c.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = c.meshPerAttribute * c.count)) : v.enableAttribute(l), p.bindBuffer(34962, d), v.vertexAttribPointer(l, u, g, h, 0, 0)
                        } else if ("instanceMatrix" === s) {
                            var M;
                            if (void 0 === (M = w.get(t.instanceMatrix))) continue;
                            d = M.buffer, g = M.type;
                            v.enableAttributeAndDivisor(l + 0, 1), v.enableAttributeAndDivisor(l + 1, 1), v.enableAttributeAndDivisor(l + 2, 1), v.enableAttributeAndDivisor(l + 3, 1), p.bindBuffer(34962, d), p.vertexAttribPointer(l + 0, 4, g, !1, 64, 0), p.vertexAttribPointer(l + 1, 4, g, !1, 64, 16), p.vertexAttribPointer(l + 2, 4, g, !1, 64, 32), p.vertexAttribPointer(l + 3, 4, g, !1, 64, 48)
                        } else if (void 0 !== a) {
                            var S = a[s];
                            if (void 0 !== S) switch (S.length) {
                                case 2:
                                    p.vertexAttrib2fv(l, S);
                                    break;
                                case 3:
                                    p.vertexAttrib3fv(l, S);
                                    break;
                                case 4:
                                    p.vertexAttrib4fv(l, S);
                                    break;
                                default:
                                    p.vertexAttrib1fv(l, S)
                            }
                        }
                    }
                }
                v.disableUnusedAttributes()
            }(r, n, i, s), null !== c && p.bindBuffer(34963, u.buffer));
            var y = null !== c ? c.count : h.count,
                _ = n.drawRange.start * d,
                x = n.drawRange.count * d,
                b = null !== o ? o.start * d : 0,
                S = null !== o ? o.count * d : 1 / 0,
                T = Math.max(_, b),
                E = Math.min(y, _ + x, b + S) - 1,
                A = Math.max(0, E - T + 1);
            if (0 !== A) {
                if (r.isMesh) !0 === i.wireframe ? (v.setLineWidth(i.wireframeLinewidth * ut()), g.setMode(1)) : g.setMode(4);
                else if (r.isLine) {
                    var C = i.linewidth;
                    void 0 === C && (C = 1), v.setLineWidth(C * ut()), r.isLineSegments ? g.setMode(1) : r.isLineLoop ? g.setMode(2) : g.setMode(3)
                } else r.isPoints ? g.setMode(0) : r.isSprite && g.setMode(4);
                r.isInstancedMesh ? g.renderInstances(n, T, A, r.count) : n.isInstancedBufferGeometry ? g.renderInstances(n, T, A, n.maxInstancedCount) : g.render(T, A)
            }
        }, this.compile = function (t, e) {
            (d = C.get(t, e)).init(), t.traverse((function (t) {
                t.isLight && (d.pushLight(t), t.castShadow && d.pushShadow(t))
            })), d.setupLights(e);
            var n = {};
            t.traverse((function (e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var i = 0; i < e.material.length; i++) e.material[i].uuid in n == !1 && (Et(e.material[i], t, e), n[e.material[i].uuid] = !0);
                    else e.material.uuid in n == !1 && (Et(e.material, t, e), n[e.material.uuid] = !0)
            }))
        };
        var bt = null;
        var wt = new ln;

        function Mt(t, e, n, i) {
            if (!1 !== t.visible) {
                if (t.layers.test(e.layers))
                    if (t.isGroup) n = t.renderOrder;
                    else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                else if (t.isSprite) {
                    if (!t.frustumCulled || ot.intersectsSprite(t)) {
                        i && ht.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ct);
                        var r = T.update(t);
                        (o = t.material).visible && u.push(t, r, o, n, ht.z, null)
                    }
                } else if (t.isImmediateRenderObject) i && ht.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ct), u.push(t, null, t.material, n, ht.z, null);
                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== g.render.frame && (t.skeleton.update(), t.skeleton.frame = g.render.frame), !t.frustumCulled || ot.intersectsObject(t))) {
                    i && ht.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ct);
                    r = T.update(t);
                    var o = t.material;
                    if (Array.isArray(o))
                        for (var a = r.groups, s = 0, l = a.length; s < l; s++) {
                            var c = a[s],
                                h = o[c.materialIndex];
                            h && h.visible && u.push(t, r, h, n, ht.z, c)
                        } else o.visible && u.push(t, r, o, n, ht.z, null)
                }
                var p = t.children;
                for (s = 0, l = p.length; s < l; s++) Mt(p[s], e, n, i)
            }
        }

        function St(t, e, n, i) {
            for (var r = 0, o = t.length; r < o; r++) {
                var a = t[r],
                    s = a.object,
                    l = a.geometry,
                    c = void 0 === i ? a.material : i,
                    h = a.group;
                if (n.isArrayCamera) {
                    q = n;
                    for (var u = n.cameras, p = 0, f = u.length; p < f; p++) {
                        var m = u[p];
                        s.layers.test(m.layers) && (v.viewport(X.copy(m.viewport)), d.setupLights(m), Tt(s, e, m, l, c, h))
                    }
                } else q = null, Tt(s, e, n, l, c, h)
            }
        }

        function Tt(t, e, n, i, r, o) {
            if (t.onBeforeRender(N, e, n, i, r, o), d = C.get(e, q || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                var a = At(n, e, r, t);
                v.setMaterial(r), j.geometry = null, j.program = null, j.wireframe = !1,
                    function (t, e) {
                        t.render((function (t) {
                            N.renderBufferImmediate(t, e)
                        }))
                    }(t, a)
            } else N.renderBufferDirect(n, e, i, r, t, o);
            t.onAfterRender(N, e, n, i, r, o), d = C.get(e, q || n)
        }

        function Et(t, e, n) {
            var i = x.get(t),
                r = d.state.lights,
                o = d.state.shadowsArray,
                a = r.state.version,
                s = E.getParameters(t, r.state, o, e, at.numPlanes, at.numIntersection, n),
                l = E.getProgramCacheKey(s),
                c = i.program,
                h = !0;
            if (void 0 === c) t.addEventListener("dispose", yt);
            else if (c.cacheKey !== l) _t(t);
            else if (i.lightsStateVersion !== a) i.lightsStateVersion = a, h = !1;
            else {
                if (void 0 !== s.shaderID) return;
                h = !1
            }
            h && (c = E.acquireProgram(s, l), i.program = c, i.uniforms = s.uniforms, i.outputEncoding = s.outputEncoding, t.program = c);
            var u = c.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (var p = 0; p < N.maxMorphTargets; p++) u["morphTarget" + p] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals) {
                t.numSupportedMorphNormals = 0;
                for (p = 0; p < N.maxMorphNormals; p++) u["morphNormal" + p] >= 0 && t.numSupportedMorphNormals++
            }
            var f = i.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = at.numPlanes, i.numIntersection = at.numIntersection, f.clippingPlanes = at.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.needsLights = function (t) {
                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }(t), i.lightsStateVersion = a, i.needsLights && (f.ambientLightColor.value = r.state.ambient, f.lightProbe.value = r.state.probe, f.directionalLights.value = r.state.directional, f.directionalLightShadows.value = r.state.directionalShadow, f.spotLights.value = r.state.spot, f.spotLightShadows.value = r.state.spotShadow, f.rectAreaLights.value = r.state.rectArea, f.pointLights.value = r.state.point, f.pointLightShadows.value = r.state.pointShadow, f.hemisphereLights.value = r.state.hemi, f.directionalShadowMap.value = r.state.directionalShadowMap, f.directionalShadowMatrix.value = r.state.directionalShadowMatrix, f.spotShadowMap.value = r.state.spotShadowMap, f.spotShadowMatrix.value = r.state.spotShadowMatrix, f.pointShadowMap.value = r.state.pointShadowMap, f.pointShadowMatrix.value = r.state.pointShadowMatrix);
            var m = i.program.getUniforms(),
                v = wi.seqWithValue(m.seq, f);
            i.uniformsList = v
        }

        function At(t, e, n, i) {
            b.resetTextureUnits();
            var r = e.fog,
                o = n.isMeshStandardMaterial ? e.environment : null,
                a = null === H ? N.outputEncoding : H.texture.encoding,
                s = x.get(n),
                l = d.state.lights;
            if (st && (lt || t !== W)) {
                var c = t === W && n.id === V;
                at.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, s, c)
            }
            n.version === s.__version ? void 0 === s.program || n.fog && s.fog !== r || s.environment !== o || s.needsLights && s.lightsStateVersion !== l.state.version ? Et(n, e, i) : void 0 === s.numClippingPlanes || s.numClippingPlanes === at.numPlanes && s.numIntersection === at.numIntersection ? s.outputEncoding !== a && Et(n, e, i) : Et(n, e, i) : (Et(n, e, i), s.__version = n.version);
            var h, u, f = !1,
                g = !1,
                _ = !1,
                w = s.program,
                M = w.getUniforms(),
                S = s.uniforms;
            if (v.useProgram(w.program) && (f = !0, g = !0, _ = !0), n.id !== V && (V = n.id, g = !0), f || W !== t) {
                if (M.setValue(p, "projectionMatrix", t.projectionMatrix), m.logarithmicDepthBuffer && M.setValue(p, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), W !== t && (W = t, g = !0, _ = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var T = M.map.cameraPosition;
                    void 0 !== T && T.setValue(p, ht.setFromMatrixPosition(t.matrixWorld))
                }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && M.setValue(p, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && M.setValue(p, "viewMatrix", t.matrixWorldInverse)
            }
            if (n.skinning) {
                M.setOptional(p, i, "bindMatrix"), M.setOptional(p, i, "bindMatrixInverse");
                var E = i.skeleton;
                if (E) {
                    var A = E.bones;
                    if (m.floatVertexTextures) {
                        if (void 0 === E.boneTexture) {
                            var C = Math.sqrt(4 * A.length);
                            C = y.ceilPowerOfTwo(C), C = Math.max(C, 4);
                            var L = new Float32Array(C * C * 4);
                            L.set(E.boneMatrices);
                            var P = new nn(L, C, C, 1023, 1015);
                            E.boneMatrices = L, E.boneTexture = P, E.boneTextureSize = C
                        }
                        M.setValue(p, "boneTexture", E.boneTexture, b), M.setValue(p, "boneTextureSize", E.boneTextureSize)
                    } else M.setOptional(p, E, "boneMatrices")
                }
            }
            return (g || s.receiveShadow !== i.receiveShadow) && (s.receiveShadow = i.receiveShadow, M.setValue(p, "receiveShadow", i.receiveShadow)), g && (M.setValue(p, "toneMappingExposure", N.toneMappingExposure), M.setValue(p, "toneMappingWhitePoint", N.toneMappingWhitePoint), s.needsLights && (u = _, (h = S).ambientLightColor.needsUpdate = u, h.lightProbe.needsUpdate = u, h.directionalLights.needsUpdate = u, h.directionalLightShadows.needsUpdate = u, h.pointLights.needsUpdate = u, h.pointLightShadows.needsUpdate = u, h.spotLights.needsUpdate = u, h.spotLightShadows.needsUpdate = u, h.rectAreaLights.needsUpdate = u, h.hemisphereLights.needsUpdate = u), r && n.fog && function (t, e) {
                t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }(S, r), n.isMeshBasicMaterial ? Ct(S, n) : n.isMeshLambertMaterial ? (Ct(S, n), function (t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }(S, n)) : n.isMeshToonMaterial ? (Ct(S, n), function (t, e) {
                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.gradientMap && (t.gradientMap.value = e.gradientMap);
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(S, n)) : n.isMeshPhongMaterial ? (Ct(S, n), function (t, e) {
                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(S, n)) : n.isMeshStandardMaterial ? (Ct(S, n, o), n.isMeshPhysicalMaterial ? function (t, e, n) {
                Lt(t, e, n), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
                t.transparency.value = e.transparency
            }(S, n, o) : Lt(S, n, o)) : n.isMeshMatcapMaterial ? (Ct(S, n), function (t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(S, n)) : n.isMeshDepthMaterial ? (Ct(S, n), function (t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(S, n)) : n.isMeshDistanceMaterial ? (Ct(S, n), function (t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
            }(S, n)) : n.isMeshNormalMaterial ? (Ct(S, n), function (t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(S, n)) : n.isLineBasicMaterial ? (function (t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
            }(S, n), n.isLineDashedMaterial && function (t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }(S, n)) : n.isPointsMaterial ? function (t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * K, t.scale.value = .5 * Q, e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                var n;
                e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
            }(S, n) : n.isSpriteMaterial ? function (t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                var n;
                e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
            }(S, n) : n.isShadowMaterial && (S.color.value.copy(n.color), S.opacity.value = n.opacity), void 0 !== S.ltc_1 && (S.ltc_1.value = sn.LTC_1), void 0 !== S.ltc_2 && (S.ltc_2.value = sn.LTC_2), wi.upload(p, s.uniformsList, S, b), n.isShaderMaterial && (n.uniformsNeedUpdate = !1)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (wi.upload(p, s.uniformsList, S, b), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && M.setValue(p, "center", i.center), M.setValue(p, "modelViewMatrix", i.modelViewMatrix), M.setValue(p, "normalMatrix", i.normalMatrix), M.setValue(p, "modelMatrix", i.matrixWorld), w
        }

        function Ct(t, e, n) {
            t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap);
            var i, r, o = e.envMap || n;
            o && (t.envMap.value = o, t.flipEnvMap.value = o.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = x.get(o).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)), e.aoMap ? r = e.aoMap : e.lightMap && (r = e.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uv2Transform.value.copy(r.matrix))
        }

        function Lt(t, e, n) {
            t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity)
        }
        wt.setAnimationLoop((function (t) {
            ft.isPresenting || bt && bt(t)
        })), "undefined" != typeof window && wt.setContext(window), this.setAnimationLoop = function (t) {
            bt = t, ft.setAnimationLoop(t), wt.start()
        }, this.render = function (t, e) {
            var n, i;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), e && e.isCamera) {
                if (!k) {
                    j.geometry = null, j.program = null, j.wireframe = !1, V = -1, W = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), ft.enabled && ft.isPresenting && (e = ft.getCamera(e)), t.onBeforeRender(N, t, e, n || H), (d = C.get(t, e)).init(), ct.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), ot.setFromProjectionMatrix(ct), lt = this.localClippingEnabled, st = at.init(this.clippingPlanes, lt, e), (u = A.get(t, e)).init(), Mt(t, e, 0, N.sortObjects), u.finish(), !0 === N.sortObjects && u.sort($, tt), st && at.beginShadows();
                    var r = d.state.shadowsArray;
                    mt.render(r, t, e), d.setupLights(e), st && at.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), L.render(u, t, e, i);
                    var o = u.opaque,
                        a = u.transparent;
                    if (t.overrideMaterial) {
                        var s = t.overrideMaterial;
                        o.length && St(o, t, e, s), a.length && St(a, t, e, s)
                    } else o.length && St(o, t, e), a.length && St(a, t, e);
                    t.onAfterRender(N, t, e), null !== H && (b.updateRenderTargetMipmap(H), b.updateMultisampleRenderTarget(H)), v.buffers.depth.setTest(!0), v.buffers.depth.setMask(!0), v.buffers.color.setMask(!0), v.setPolygonOffset(!1), u = null, d = null
                }
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.setFramebuffer = function (t) {
            z !== t && null === H && p.bindFramebuffer(36160, t), z = t
        }, this.getActiveCubeFace = function () {
            return F
        }, this.getActiveMipmapLevel = function () {
            return U
        }, this.getRenderTarget = function () {
            return H
        }, this.setRenderTarget = function (t, e, n) {
            H = t, F = e, U = n, t && void 0 === x.get(t).__webglFramebuffer && b.setupRenderTarget(t);
            var i = z,
                r = !1;
            if (t) {
                var o = x.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget ? (i = o[e || 0], r = !0) : i = t.isWebGLMultisampleRenderTarget ? x.get(t).__webglMultisampledFramebuffer : o, X.copy(t.viewport), Y.copy(t.scissor), J = t.scissorTest
            } else X.copy(et).multiplyScalar(K).floor(), Y.copy(nt).multiplyScalar(K).floor(), J = rt;
            if (G !== i && (p.bindFramebuffer(36160, i), G = i), v.viewport(X), v.scissor(Y), v.setScissorTest(J), r) {
                var a = x.get(t.texture);
                p.framebufferTexture2D(36160, 36064, 34069 + (e || 0), a.__webglTexture, n || 0)
            }
        }, this.readRenderTargetPixels = function (t, e, n, i, r, o, a) {
            if (t && t.isWebGLRenderTarget) {
                var s = x.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s) {
                    var l = !1;
                    s !== G && (p.bindFramebuffer(36160, s), l = !0);
                    try {
                        var c = t.texture,
                            h = c.format,
                            u = c.type;
                        if (1023 !== h && I.convert(h) !== p.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(1009 === u || I.convert(u) === p.getParameter(35738) || 1015 === u && (m.isWebGL2 || f.get("OES_texture_float") || f.get("WEBGL_color_buffer_float")) || 1016 === u && (m.isWebGL2 ? f.get("EXT_color_buffer_float") : f.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === p.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && p.readPixels(e, n, i, r, I.convert(h), I.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        l && p.bindFramebuffer(36160, G)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function (t, e, n) {
            void 0 === n && (n = 0);
            var i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                o = Math.floor(e.image.height * i),
                a = I.convert(e.format);
            b.setTexture2D(e, 0), p.copyTexImage2D(3553, n, a, t.x, t.y, r, o, 0), v.unbindTexture()
        }, this.copyTextureToTexture = function (t, e, n, i) {
            void 0 === i && (i = 0);
            var r = e.image.width,
                o = e.image.height,
                a = I.convert(n.format),
                s = I.convert(n.type);
            b.setTexture2D(n, 0), e.isDataTexture ? p.texSubImage2D(3553, i, t.x, t.y, r, o, a, s, e.image.data) : e.isCompressedTexture ? p.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : p.texSubImage2D(3553, i, t.x, t.y, a, s, e.image), 0 === i && n.generateMipmaps && p.generateMipmap(3553), v.unbindTexture()
        }, this.initTexture = function (t) {
            b.setTexture2D(t, 0), v.unbindTexture()
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }

    function ur(t, e) {
        this.name = "", this.color = new Xt(t), this.density = void 0 !== e ? e : 25e-5
    }

    function dr(t, e, n) {
        this.name = "", this.color = new Xt(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
    }

    function pr(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }
    ar.prototype = Object.assign(Object.create($e.prototype), {
        constructor: ar,
        isArrayCamera: !0
    }), sr.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: sr,
        isGroup: !0
    }), Object.assign(lr.prototype, {
        constructor: lr,
        getTargetRaySpace: function () {
            return null === this._targetRay && (this._targetRay = new sr, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
        },
        getGripSpace: function () {
            return null === this._grip && (this._grip = new sr, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
        },
        dispatchEvent: function (t) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), this
        },
        disconnect: function (t) {
            return this.dispatchEvent({
                type: "disconnected",
                data: t
            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), this
        },
        update: function (t, e, n) {
            var i = null,
                r = null,
                o = this._targetRay,
                a = this._grip;
            return t && (null !== o && null !== (i = e.getPose(t.targetRaySpace, n)) && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale)), null !== a && t.gripSpace && null !== (r = e.getPose(t.gripSpace, n)) && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale))), null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), this
        }
    }), Object.assign(cr.prototype, f.prototype), Object.assign(ur.prototype, {
        isFogExp2: !0,
        clone: function () {
            return new ur(this.color, this.density)
        },
        toJSON: function () {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }), Object.assign(dr.prototype, {
        isFog: !0,
        clone: function () {
            return new dr(this.color, this.near, this.far)
        },
        toJSON: function () {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }), Object.defineProperty(pr.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), Object.assign(pr.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function () {},
        setUsage: function (t) {
            return this.usage = t, this
        },
        copy: function (t) {
            return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
        },
        copyAt: function (t, e, n) {
            t *= this.stride, n *= e.stride;
            for (var i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        },
        set: function (t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        onUpload: function (t) {
            return this.onUploadCallback = t, this
        }
    });
    var fr, mr = new P;

    function vr(t, e, n, i) {
        this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
    }

    function gr(t) {
        $t.call(this), this.type = "SpriteMaterial", this.color = new Xt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
    }
    Object.defineProperties(vr.prototype, {
        count: {
            get: function () {
                return this.data.count
            }
        },
        array: {
            get: function () {
                return this.data.array
            }
        }
    }), Object.assign(vr.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function (t) {
            for (var e = 0, n = this.data.count; e < n; e++) mr.x = this.getX(e), mr.y = this.getY(e), mr.z = this.getZ(e), mr.applyMatrix4(t), this.setXYZ(e, mr.x, mr.y, mr.z);
            return this
        },
        setX: function (t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e, this
        },
        setY: function (t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e, this
        },
        setZ: function (t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e, this
        },
        setW: function (t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e, this
        },
        getX: function (t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function (t, e, n) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
        },
        setXYZ: function (t, e, n, i) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
        },
        setXYZW: function (t, e, n, i, r) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
        }
    }), gr.prototype = Object.create($t.prototype), gr.prototype.constructor = gr, gr.prototype.isSpriteMaterial = !0, gr.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
    };
    var yr = new P,
        _r = new P,
        xr = new P,
        br = new _,
        wr = new _,
        Mr = new B,
        Sr = new P,
        Tr = new P,
        Er = new P,
        Ar = new _,
        Cr = new _,
        Lr = new _;

    function Pr(t) {
        if (nt.call(this), this.type = "Sprite", void 0 === fr) {
            fr = new be;
            var e = new pr(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
            fr.setIndex([0, 1, 2, 0, 2, 3]), fr.setAttribute("position", new vr(e, 3, 0, !1)), fr.setAttribute("uv", new vr(e, 2, 3, !1))
        }
        this.geometry = fr, this.material = void 0 !== t ? t : new gr, this.center = new _(.5, .5)
    }

    function Rr(t, e, n, i, r, o) {
        br.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (wr.x = o * br.x - r * br.y, wr.y = r * br.x + o * br.y) : wr.copy(br), t.copy(e), t.x += wr.x, t.y += wr.y, t.applyMatrix4(Mr)
    }
    Pr.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: Pr,
        isSprite: !0,
        raycast: function (t, e) {
            null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _r.setFromMatrixScale(this.matrixWorld), Mr.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), xr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && _r.multiplyScalar(-xr.z);
            var n, i, r = this.material.rotation;
            0 !== r && (i = Math.cos(r), n = Math.sin(r));
            var o = this.center;
            Rr(Sr.set(-.5, -.5, 0), xr, o, _r, n, i), Rr(Tr.set(.5, -.5, 0), xr, o, _r, n, i), Rr(Er.set(.5, .5, 0), xr, o, _r, n, i), Ar.set(0, 0), Cr.set(1, 0), Lr.set(1, 1);
            var a = t.ray.intersectTriangle(Sr, Tr, Er, !1, yr);
            if (null !== a || (Rr(Tr.set(-.5, .5, 0), xr, o, _r, n, i), Cr.set(0, 1), null !== (a = t.ray.intersectTriangle(Sr, Er, Tr, !1, yr)))) {
                var s = t.ray.origin.distanceTo(yr);
                s < t.near || s > t.far || e.push({
                    distance: s,
                    point: yr.clone(),
                    uv: Vt.getUV(yr, Sr, Tr, Er, Ar, Cr, Lr, new _),
                    face: null,
                    object: this
                })
            }
        },
        clone: function () {
            return new this.constructor(this.material).copy(this)
        },
        copy: function (t) {
            return nt.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
        }
    });
    var Or, Dr, Ir, Nr, kr, zr = new P,
        Br = new P;

    function Fr() {
        nt.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }), this.autoUpdate = !0
    }

    function Ur(t, e) {
        t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Fe.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new B, this.bindMatrixInverse = new B
    }
    Fr.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: Fr,
        isLOD: !0,
        copy: function (t) {
            nt.prototype.copy.call(this, t, !1);
            for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
                var r = e[n];
                this.addLevel(r.object.clone(), r.distance)
            }
            return this.autoUpdate = t.autoUpdate, this
        },
        addLevel: function (t, e) {
            void 0 === e && (e = 0), e = Math.abs(e);
            for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++);
            return n.splice(i, 0, {
                distance: e,
                object: t
            }), this.add(t), this
        },
        getCurrentLevel: function () {
            return this._currentLevel
        },
        getObjectForDistance: function (t) {
            var e = this.levels;
            if (e.length > 0) {
                for (var n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                return e[n - 1].object
            }
            return null
        },
        raycast: function (t, e) {
            if (this.levels.length > 0) {
                zr.setFromMatrixPosition(this.matrixWorld);
                var n = t.ray.origin.distanceTo(zr);
                this.getObjectForDistance(n).raycast(t, e)
            }
        },
        update: function (t) {
            var e = this.levels;
            if (e.length > 1) {
                zr.setFromMatrixPosition(t.matrixWorld), Br.setFromMatrixPosition(this.matrixWorld);
                var n = zr.distanceTo(Br) / t.zoom;
                e[0].object.visible = !0;
                for (var i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
            }
        },
        toJSON: function (t) {
            var e = nt.prototype.toJSON.call(this, t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
            for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                var o = n[i];
                e.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return e
        }
    }), Ur.prototype = Object.assign(Object.create(Fe.prototype), {
        constructor: Ur,
        isSkinnedMesh: !0,
        bind: function (t, e) {
            this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
        },
        pose: function () {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function () {
            for (var t = new S, e = this.geometry.attributes.skinWeight, n = 0, i = e.count; n < i; n++) {
                t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                var r = 1 / t.manhattanLength();
                r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
            }
        },
        updateMatrixWorld: function (t) {
            Fe.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        },
        boneTransform: (Or = new P, Dr = new S, Ir = new S, Nr = new P, kr = new B, function (t, e) {
            var n = this.skeleton,
                i = this.geometry;
            Dr.fromBufferAttribute(i.attributes.skinIndex, t), Ir.fromBufferAttribute(i.attributes.skinWeight, t), Or.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
            for (var r = 0; r < 4; r++) {
                var o = Ir.getComponent(r);
                if (0 !== o) {
                    var a = Dr.getComponent(r);
                    kr.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), e.addScaledVector(Nr.copy(Or).applyMatrix4(kr), o)
                }
            }
            return e.applyMatrix4(this.bindMatrixInverse)
        })
    });
    var Hr = new B,
        Gr = new B;

    function Vr(t, e) {
        if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new B)
        }
    }

    function jr() {
        nt.call(this), this.type = "Bone"
    }
    Object.assign(Vr.prototype, {
        calculateInverses: function () {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var n = new B;
                this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
            }
        },
        pose: function () {
            var t, e, n;
            for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: function () {
            for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, o = t.length; r < o; r++) {
                var a = t[r] ? t[r].matrixWorld : Gr;
                Hr.multiplyMatrices(a, e[r]), Hr.toArray(n, 16 * r)
            }
            void 0 !== i && (i.needsUpdate = !0)
        },
        clone: function () {
            return new Vr(this.bones, this.boneInverses)
        },
        getBoneByName: function (t) {
            for (var e = 0, n = this.bones.length; e < n; e++) {
                var i = this.bones[e];
                if (i.name === t) return i
            }
        },
        dispose: function () {
            this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0)
        }
    }), jr.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: jr,
        isBone: !0
    });
    var Wr = new B,
        qr = new B,
        Xr = [],
        Yr = new Fe;

    function Jr(t, e, n) {
        Fe.call(this, t, e), this.instanceMatrix = new ne(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1
    }

    function Zr(t) {
        $t.call(this), this.type = "LineBasicMaterial", this.color = new Xt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
    }
    Jr.prototype = Object.assign(Object.create(Fe.prototype), {
        constructor: Jr,
        isInstancedMesh: !0,
        getMatrixAt: function (t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t)
        },
        raycast: function (t, e) {
            var n = this.matrixWorld,
                i = this.count;
            if (Yr.geometry = this.geometry, Yr.material = this.material, void 0 !== Yr.material)
                for (var r = 0; r < i; r++) {
                    this.getMatrixAt(r, Wr), qr.multiplyMatrices(n, Wr), Yr.matrixWorld = qr, Yr.raycast(t, Xr);
                    for (var o = 0, a = Xr.length; o < a; o++) {
                        var s = Xr[o];
                        s.instanceId = r, s.object = this, e.push(s)
                    }
                    Xr.length = 0
                }
        },
        setMatrixAt: function (t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t)
        },
        updateMorphTargets: function () {}
    }), Zr.prototype = Object.create($t.prototype), Zr.prototype.constructor = Zr, Zr.prototype.isLineBasicMaterial = !0, Zr.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
    };
    var Qr = new P,
        Kr = new P,
        $r = new B,
        to = new Ct,
        eo = new xt;

    function no(t, e, n) {
        1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), nt.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new be, this.material = void 0 !== e ? e : new Zr
    }
    no.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: no,
        isLine: !0,
        computeLineDistances: function () {
            var t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    for (var e = t.attributes.position, n = [0], i = 1, r = e.count; i < r; i++) Qr.fromBufferAttribute(e, i - 1), Kr.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += Qr.distanceTo(Kr);
                    t.setAttribute("lineDistance", new he(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry) {
                var o = t.vertices;
                (n = t.lineDistances)[0] = 0;
                for (i = 1, r = o.length; i < r; i++) n[i] = n[i - 1], n[i] += o[i - 1].distanceTo(o[i])
            }
            return this
        },
        raycast: function (t, e) {
            var n = this.geometry,
                i = this.matrixWorld,
                r = t.params.Line.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), eo.copy(n.boundingSphere), eo.applyMatrix4(i), eo.radius += r, !1 !== t.ray.intersectsSphere(eo)) {
                $r.getInverse(i), to.copy(t.ray).applyMatrix4($r);
                var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = o * o,
                    s = new P,
                    l = new P,
                    c = new P,
                    h = new P,
                    u = this && this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    var d = n.index,
                        p = n.attributes.position.array;
                    if (null !== d)
                        for (var f = d.array, m = 0, v = f.length - 1; m < v; m += u) {
                            var g = f[m],
                                y = f[m + 1];
                            if (s.fromArray(p, 3 * g), l.fromArray(p, 3 * y), !(to.distanceSqToSegment(s, l, h, c) > a)) h.applyMatrix4(this.matrixWorld), (b = t.ray.origin.distanceTo(h)) < t.near || b > t.far || e.push({
                                distance: b,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: m,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        } else
                            for (m = 0, v = p.length / 3 - 1; m < v; m += u) {
                                if (s.fromArray(p, 3 * m), l.fromArray(p, 3 * m + 3), !(to.distanceSqToSegment(s, l, h, c) > a)) h.applyMatrix4(this.matrixWorld), (b = t.ray.origin.distanceTo(h)) < t.near || b > t.far || e.push({
                                    distance: b,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                } else if (n.isGeometry) {
                    var _ = n.vertices,
                        x = _.length;
                    for (m = 0; m < x - 1; m += u) {
                        var b;
                        if (!(to.distanceSqToSegment(_[m], _[m + 1], h, c) > a)) h.applyMatrix4(this.matrixWorld), (b = t.ray.origin.distanceTo(h)) < t.near || b > t.far || e.push({
                            distance: b,
                            point: c.clone().applyMatrix4(this.matrixWorld),
                            index: m,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var io = new P,
        ro = new P;

    function oo(t, e) {
        no.call(this, t, e), this.type = "LineSegments"
    }

    function ao(t, e) {
        no.call(this, t, e), this.type = "LineLoop"
    }

    function so(t) {
        $t.call(this), this.type = "PointsMaterial", this.color = new Xt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
    }
    oo.prototype = Object.assign(Object.create(no.prototype), {
        constructor: oo,
        isLineSegments: !0,
        computeLineDistances: function () {
            var t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    for (var e = t.attributes.position, n = [], i = 0, r = e.count; i < r; i += 2) io.fromBufferAttribute(e, i), ro.fromBufferAttribute(e, i + 1), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + io.distanceTo(ro);
                    t.setAttribute("lineDistance", new he(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry) {
                var o = t.vertices;
                for (n = t.lineDistances, i = 0, r = o.length; i < r; i += 2) io.copy(o[i]), ro.copy(o[i + 1]), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + io.distanceTo(ro)
            }
            return this
        }
    }), ao.prototype = Object.assign(Object.create(no.prototype), {
        constructor: ao,
        isLineLoop: !0
    }), so.prototype = Object.create($t.prototype), so.prototype.constructor = so, so.prototype.isPointsMaterial = !0, so.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
    };
    var lo = new B,
        co = new Ct,
        ho = new xt,
        uo = new P;

    function po(t, e) {
        nt.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new be, this.material = void 0 !== e ? e : new so, this.updateMorphTargets()
    }

    function fo(t, e, n, i, r, o, a) {
        var s = co.distanceSqToPoint(t);
        if (s < n) {
            var l = new P;
            co.closestPointToPoint(t, l), l.applyMatrix4(i);
            var c = r.ray.origin.distanceTo(l);
            if (c < r.near || c > r.far) return;
            o.push({
                distance: c,
                distanceToRay: Math.sqrt(s),
                point: l,
                index: e,
                face: null,
                object: a
            })
        }
    }

    function mo(t, e, n, i, r, o, a, s, l) {
        M.call(this, t, e, n, i, r, o, a, s, l), this.format = void 0 !== a ? a : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1
    }

    function vo(t, e, n, i, r, o, a, s, l, c, h, u) {
        M.call(this, null, o, a, s, l, c, i, r, h, u), this.image = {
            width: e,
            height: n
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
    }

    function go(t, e, n, i, r, o, a, s, l) {
        M.call(this, t, e, n, i, r, o, a, s, l), this.needsUpdate = !0
    }

    function yo(t, e, n, i, r, o, a, s, l, c) {
        if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && 1026 === c && (n = 1012), void 0 === n && 1027 === c && (n = 1020), M.call(this, null, i, r, o, a, s, c, n, l), this.image = {
            width: t,
            height: e
        }, this.magFilter = void 0 !== a ? a : 1003, this.minFilter = void 0 !== s ? s : 1003, this.flipY = !1, this.generateMipmaps = !1
    }

    function _o(t) {
        be.call(this), this.type = "WireframeGeometry";
        var e, n, i, r, o, a, s, l, c, h, u = [],
            d = [0, 0],
            p = {},
            f = ["a", "b", "c"];
        if (t && t.isGeometry) {
            var m = t.faces;
            for (e = 0, i = m.length; e < i; e++) {
                var v = m[e];
                for (n = 0; n < 3; n++) s = v[f[n]], l = v[f[(n + 1) % 3]], d[0] = Math.min(s, l), d[1] = Math.max(s, l), void 0 === p[c = d[0] + "," + d[1]] && (p[c] = {
                    index1: d[0],
                    index2: d[1]
                })
            }
            for (c in p) a = p[c], h = t.vertices[a.index1], u.push(h.x, h.y, h.z), h = t.vertices[a.index2], u.push(h.x, h.y, h.z)
        } else if (t && t.isBufferGeometry) {
            var g, y, _, x, b, w, M;
            if (h = new P, null !== t.index) {
                for (g = t.attributes.position, y = t.index, 0 === (_ = t.groups).length && (_ = [{
                        start: 0,
                        count: y.count,
                        materialIndex: 0
                    }]), r = 0, o = _.length; r < o; ++r)
                    for (e = b = (x = _[r]).start, i = b + x.count; e < i; e += 3)
                        for (n = 0; n < 3; n++) s = y.getX(e + n), l = y.getX(e + (n + 1) % 3), d[0] = Math.min(s, l), d[1] = Math.max(s, l), void 0 === p[c = d[0] + "," + d[1]] && (p[c] = {
                            index1: d[0],
                            index2: d[1]
                        });
                for (c in p) a = p[c], h.fromBufferAttribute(g, a.index1), u.push(h.x, h.y, h.z), h.fromBufferAttribute(g, a.index2), u.push(h.x, h.y, h.z)
            } else
                for (e = 0, i = (g = t.attributes.position).count / 3; e < i; e++)
                    for (n = 0; n < 3; n++) w = 3 * e + n, h.fromBufferAttribute(g, w), u.push(h.x, h.y, h.z), M = 3 * e + (n + 1) % 3, h.fromBufferAttribute(g, M), u.push(h.x, h.y, h.z)
        }
        this.setAttribute("position", new he(u, 3))
    }

    function xo(t, e, n) {
        qe.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: n
        }, this.fromBufferGeometry(new bo(t, e, n)), this.mergeVertices()
    }

    function bo(t, e, n) {
        be.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: n
        };
        var i, r, o = [],
            a = [],
            s = [],
            l = [],
            c = 1e-5,
            h = new P,
            u = new P,
            d = new P,
            p = new P,
            f = new P;
        t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var m = e + 1;
        for (i = 0; i <= n; i++) {
            var v = i / n;
            for (r = 0; r <= e; r++) {
                var g = r / e;
                t(g, v, u), a.push(u.x, u.y, u.z), g - c >= 0 ? (t(g - c, v, d), p.subVectors(u, d)) : (t(g + c, v, d), p.subVectors(d, u)), v - c >= 0 ? (t(g, v - c, d), f.subVectors(u, d)) : (t(g, v + c, d), f.subVectors(d, u)), h.crossVectors(p, f).normalize(), s.push(h.x, h.y, h.z), l.push(g, v)
            }
        }
        for (i = 0; i < n; i++)
            for (r = 0; r < e; r++) {
                var y = i * m + r,
                    _ = i * m + r + 1,
                    x = (i + 1) * m + r + 1,
                    b = (i + 1) * m + r;
                o.push(y, _, b), o.push(_, x, b)
            }
        this.setIndex(o), this.setAttribute("position", new he(a, 3)), this.setAttribute("normal", new he(s, 3)), this.setAttribute("uv", new he(l, 2))
    }

    function wo(t, e, n, i) {
        qe.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: i
        }, this.fromBufferGeometry(new Mo(t, e, n, i)), this.mergeVertices()
    }

    function Mo(t, e, n, i) {
        be.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: i
        }, n = n || 1;
        var r = [],
            o = [];

        function a(t, e, n, i) {
            var r, o, a = Math.pow(2, i),
                l = [];
            for (r = 0; r <= a; r++) {
                l[r] = [];
                var c = t.clone().lerp(n, r / a),
                    h = e.clone().lerp(n, r / a),
                    u = a - r;
                for (o = 0; o <= u; o++) l[r][o] = 0 === o && r === a ? c : c.clone().lerp(h, o / u)
            }
            for (r = 0; r < a; r++)
                for (o = 0; o < 2 * (a - r) - 1; o++) {
                    var d = Math.floor(o / 2);
                    o % 2 == 0 ? (s(l[r][d + 1]), s(l[r + 1][d]), s(l[r][d])) : (s(l[r][d + 1]), s(l[r + 1][d + 1]), s(l[r + 1][d]))
                }
        }

        function s(t) {
            r.push(t.x, t.y, t.z)
        }

        function l(e, n) {
            var i = 3 * e;
            n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
        }

        function c(t, e, n, i) {
            i < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5)
        }

        function h(t) {
            return Math.atan2(t.z, -t.x)
        }

        function u(t) {
            return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
        }! function (t) {
            for (var n = new P, i = new P, r = new P, o = 0; o < e.length; o += 3) l(e[o + 0], n), l(e[o + 1], i), l(e[o + 2], r), a(n, i, r, t)
        }(i = i || 0),
        function (t) {
            for (var e = new P, n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z
        }(n),
        function () {
            for (var t = new P, e = 0; e < r.length; e += 3) {
                t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                var n = h(t) / 2 / Math.PI + .5,
                    i = u(t) / Math.PI + .5;
                o.push(n, 1 - i)
            }(function () {
                for (var t = new P, e = new P, n = new P, i = new P, a = new _, s = new _, l = new _, u = 0, d = 0; u < r.length; u += 9, d += 6) {
                    t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), a.set(o[d + 0], o[d + 1]), s.set(o[d + 2], o[d + 3]), l.set(o[d + 4], o[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                    var p = h(i);
                    c(a, d + 0, t, p), c(s, d + 2, e, p), c(l, d + 4, n, p)
                }
            })(),
            function () {
                for (var t = 0; t < o.length; t += 6) {
                    var e = o[t + 0],
                        n = o[t + 2],
                        i = o[t + 4],
                        r = Math.max(e, n, i),
                        a = Math.min(e, n, i);
                    r > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), i < .2 && (o[t + 4] += 1))
                }
            }()
        }(), this.setAttribute("position", new he(r, 3)), this.setAttribute("normal", new he(r.slice(), 3)), this.setAttribute("uv", new he(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function So(t, e) {
        qe.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new To(t, e)), this.mergeVertices()
    }

    function To(t, e) {
        Mo.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function Eo(t, e) {
        qe.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new Ao(t, e)), this.mergeVertices()
    }

    function Ao(t, e) {
        Mo.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function Co(t, e) {
        qe.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new Lo(t, e)), this.mergeVertices()
    }

    function Lo(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
            i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
        Mo.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function Po(t, e) {
        qe.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new Ro(t, e)), this.mergeVertices()
    }

    function Ro(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
            i = 1 / n,
            r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
        Mo.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function Oo(t, e, n, i, r, o) {
        qe.call(this), this.type = "TubeGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new Do(t, e, n, i, r);
        this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
    }

    function Do(t, e, n, i, r) {
        be.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r
        }, e = e || 64, n = n || 1, i = i || 8, r = r || !1;
        var o = t.computeFrenetFrames(e, r);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        var a, s, l = new P,
            c = new P,
            h = new _,
            u = new P,
            d = [],
            p = [],
            f = [],
            m = [];

        function v(r) {
            u = t.getPointAt(r / e, u);
            var a = o.normals[r],
                h = o.binormals[r];
            for (s = 0; s <= i; s++) {
                var f = s / i * Math.PI * 2,
                    m = Math.sin(f),
                    v = -Math.cos(f);
                c.x = v * a.x + m * h.x, c.y = v * a.y + m * h.y, c.z = v * a.z + m * h.z, c.normalize(), p.push(c.x, c.y, c.z), l.x = u.x + n * c.x, l.y = u.y + n * c.y, l.z = u.z + n * c.z, d.push(l.x, l.y, l.z)
            }
        }! function () {
            for (a = 0; a < e; a++) v(a);
            v(!1 === r ? e : 0),
                function () {
                    for (a = 0; a <= e; a++)
                        for (s = 0; s <= i; s++) h.x = a / e, h.y = s / i, f.push(h.x, h.y)
                }(),
                function () {
                    for (s = 1; s <= e; s++)
                        for (a = 1; a <= i; a++) {
                            var t = (i + 1) * (s - 1) + (a - 1),
                                n = (i + 1) * s + (a - 1),
                                r = (i + 1) * s + a,
                                o = (i + 1) * (s - 1) + a;
                            m.push(t, n, o), m.push(n, r, o)
                        }
                }()
        }(), this.setIndex(m), this.setAttribute("position", new he(d, 3)), this.setAttribute("normal", new he(p, 3)), this.setAttribute("uv", new he(f, 2))
    }

    function Io(t, e, n, i, r, o, a) {
        qe.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: o
        }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new No(t, e, n, i, r, o)), this.mergeVertices()
    }

    function No(t, e, n, i, r, o) {
        be.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: o
        }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3;
        var a, s, l = [],
            c = [],
            h = [],
            u = [],
            d = new P,
            p = new P,
            f = new P,
            m = new P,
            v = new P,
            g = new P,
            y = new P;
        for (a = 0; a <= n; ++a) {
            var _ = a / n * r * Math.PI * 2;
            for (A(_, r, o, t, f), A(_ + .01, r, o, t, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= i; ++s) {
                var x = s / i * Math.PI * 2,
                    b = -e * Math.cos(x),
                    w = e * Math.sin(x);
                d.x = f.x + (b * y.x + w * v.x), d.y = f.y + (b * y.y + w * v.y), d.z = f.z + (b * y.z + w * v.z), c.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), h.push(p.x, p.y, p.z), u.push(a / n), u.push(s / i)
            }
        }
        for (s = 1; s <= n; s++)
            for (a = 1; a <= i; a++) {
                var M = (i + 1) * (s - 1) + (a - 1),
                    S = (i + 1) * s + (a - 1),
                    T = (i + 1) * s + a,
                    E = (i + 1) * (s - 1) + a;
                l.push(M, S, E), l.push(S, T, E)
            }

        function A(t, e, n, i, r) {
            var o = Math.cos(t),
                a = Math.sin(t),
                s = n / e * t,
                l = Math.cos(s);
            r.x = i * (2 + l) * .5 * o, r.y = i * (2 + l) * a * .5, r.z = i * Math.sin(s) * .5
        }
        this.setIndex(l), this.setAttribute("position", new he(c, 3)), this.setAttribute("normal", new he(h, 3)), this.setAttribute("uv", new he(u, 2))
    }

    function ko(t, e, n, i, r) {
        qe.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        }, this.fromBufferGeometry(new zo(t, e, n, i, r)), this.mergeVertices()
    }

    function zo(t, e, n, i, r) {
        be.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
        var o, a, s = [],
            l = [],
            c = [],
            h = [],
            u = new P,
            d = new P,
            p = new P;
        for (o = 0; o <= n; o++)
            for (a = 0; a <= i; a++) {
                var f = a / i * r,
                    m = o / n * Math.PI * 2;
                d.x = (t + e * Math.cos(m)) * Math.cos(f), d.y = (t + e * Math.cos(m)) * Math.sin(f), d.z = e * Math.sin(m), l.push(d.x, d.y, d.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), p.subVectors(d, u).normalize(), c.push(p.x, p.y, p.z), h.push(a / i), h.push(o / n)
            }
        for (o = 1; o <= n; o++)
            for (a = 1; a <= i; a++) {
                var v = (i + 1) * o + a - 1,
                    g = (i + 1) * (o - 1) + a - 1,
                    y = (i + 1) * (o - 1) + a,
                    _ = (i + 1) * o + a;
                s.push(v, g, _), s.push(g, y, _)
            }
        this.setIndex(s), this.setAttribute("position", new he(l, 3)), this.setAttribute("normal", new he(c, 3)), this.setAttribute("uv", new he(h, 2))
    }
    po.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: po,
        isPoints: !0,
        raycast: function (t, e) {
            var n = this.geometry,
                i = this.matrixWorld,
                r = t.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), ho.copy(n.boundingSphere), ho.applyMatrix4(i), ho.radius += r, !1 !== t.ray.intersectsSphere(ho)) {
                lo.getInverse(i), co.copy(t.ray).applyMatrix4(lo);
                var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = o * o;
                if (n.isBufferGeometry) {
                    var s = n.index,
                        l = n.attributes.position.array;
                    if (null !== s)
                        for (var c = s.array, h = 0, u = c.length; h < u; h++) {
                            var d = c[h];
                            uo.fromArray(l, 3 * d), fo(uo, d, a, i, t, e, this)
                        } else {
                            h = 0;
                            for (var p = l.length / 3; h < p; h++) uo.fromArray(l, 3 * h), fo(uo, h, a, i, t, e, this)
                        }
                } else {
                    var f = n.vertices;
                    for (h = 0, p = f.length; h < p; h++) fo(f[h], h, a, i, t, e, this)
                }
            }
        },
        updateMorphTargets: function () {
            var t, e, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes,
                    o = Object.keys(r);
                if (o.length > 0) {
                    var a = r[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) n = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                }
            } else {
                var s = i.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), mo.prototype = Object.assign(Object.create(M.prototype), {
        constructor: mo,
        isVideoTexture: !0,
        update: function () {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), vo.prototype = Object.create(M.prototype), vo.prototype.constructor = vo, vo.prototype.isCompressedTexture = !0, go.prototype = Object.create(M.prototype), go.prototype.constructor = go, go.prototype.isCanvasTexture = !0, yo.prototype = Object.create(M.prototype), yo.prototype.constructor = yo, yo.prototype.isDepthTexture = !0, _o.prototype = Object.create(be.prototype), _o.prototype.constructor = _o, xo.prototype = Object.create(qe.prototype), xo.prototype.constructor = xo, bo.prototype = Object.create(be.prototype), bo.prototype.constructor = bo, wo.prototype = Object.create(qe.prototype), wo.prototype.constructor = wo, Mo.prototype = Object.create(be.prototype), Mo.prototype.constructor = Mo, So.prototype = Object.create(qe.prototype), So.prototype.constructor = So, To.prototype = Object.create(Mo.prototype), To.prototype.constructor = To, Eo.prototype = Object.create(qe.prototype), Eo.prototype.constructor = Eo, Ao.prototype = Object.create(Mo.prototype), Ao.prototype.constructor = Ao, Co.prototype = Object.create(qe.prototype), Co.prototype.constructor = Co, Lo.prototype = Object.create(Mo.prototype), Lo.prototype.constructor = Lo, Po.prototype = Object.create(qe.prototype), Po.prototype.constructor = Po, Ro.prototype = Object.create(Mo.prototype), Ro.prototype.constructor = Ro, Oo.prototype = Object.create(qe.prototype), Oo.prototype.constructor = Oo, Do.prototype = Object.create(be.prototype), Do.prototype.constructor = Do, Do.prototype.toJSON = function () {
        var t = be.prototype.toJSON.call(this);
        return t.path = this.parameters.path.toJSON(), t
    }, Io.prototype = Object.create(qe.prototype), Io.prototype.constructor = Io, No.prototype = Object.create(be.prototype), No.prototype.constructor = No, ko.prototype = Object.create(qe.prototype), ko.prototype.constructor = ko, zo.prototype = Object.create(be.prototype), zo.prototype.constructor = zo;
    var Bo = function (t, e, n) {
        n = n || 2;
        var i, r, o, a, s, l, c, h = e && e.length,
            u = h ? e[0] * n : t.length,
            d = Fo(t, 0, u, n, !0),
            p = [];
        if (!d || d.next === d.prev) return p;
        if (h && (d = function (t, e, n, i) {
                var r, o, a, s, l, c = [];
                for (r = 0, o = e.length; r < o; r++) a = e[r] * i, s = r < o - 1 ? e[r + 1] * i : t.length, (l = Fo(t, a, s, i, !1)) === l.next && (l.steiner = !0), c.push(Zo(l));
                for (c.sort(qo), r = 0; r < c.length; r++) Xo(c[r], n), n = Uo(n, n.next);
                return n
            }(t, e, d, n)), t.length > 80 * n) {
            i = o = t[0], r = a = t[1];
            for (var f = n; f < u; f += n)(s = t[f]) < i && (i = s), (l = t[f + 1]) < r && (r = l), s > o && (o = s), l > a && (a = l);
            c = 0 !== (c = Math.max(o - i, a - r)) ? 1 / c : 0
        }
        return Ho(d, p, n, i, r, c), p
    };

    function Fo(t, e, n, i, r) {
        var o, a;
        if (r === function (t, e, n, i) {
                for (var r = 0, o = e, a = n - i; o < n; o += i) r += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                return r
            }(t, e, n, i) > 0)
            for (o = e; o < n; o += i) a = aa(o, t[o], t[o + 1], a);
        else
            for (o = n - i; o >= e; o -= i) a = aa(o, t[o], t[o + 1], a);
        return a && ta(a, a.next) && (sa(a), a = a.next), a
    }

    function Uo(t, e) {
        if (!t) return t;
        e || (e = t);
        var n, i = t;
        do {
            if (n = !1, i.steiner || !ta(i, i.next) && 0 !== $o(i.prev, i, i.next)) i = i.next;
            else {
                if (sa(i), (i = e = i.prev) === i.next) break;
                n = !0
            }
        } while (n || i !== e);
        return e
    }

    function Ho(t, e, n, i, r, o, a) {
        if (t) {
            !a && o && function (t, e, n, i) {
                var r = t;
                do {
                    null === r.z && (r.z = Jo(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                } while (r !== t);
                r.prevZ.nextZ = null, r.prevZ = null,
                    function (t) {
                        var e, n, i, r, o, a, s, l, c = 1;
                        do {
                            for (n = t, t = null, o = null, a = 0; n;) {
                                for (a++, i = n, s = 0, e = 0; e < c && (s++, i = i.nextZ); e++);
                                for (l = c; s > 0 || l > 0 && i;) 0 !== s && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, l--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                                n = i
                            }
                            o.nextZ = null, c *= 2
                        } while (a > 1)
                    }(r)
            }(t, i, r, o);
            for (var s, l, c = t; t.prev !== t.next;)
                if (s = t.prev, l = t.next, o ? Vo(t, i, r, o) : Go(t)) e.push(s.i / n), e.push(t.i / n), e.push(l.i / n), sa(t), t = l.next, c = l.next;
                else if ((t = l) === c) {
                a ? 1 === a ? Ho(t = jo(Uo(t), e, n), e, n, i, r, o, 2) : 2 === a && Wo(t, e, n, i, r, o) : Ho(Uo(t), e, n, i, r, o, 1);
                break
            }
        }
    }

    function Go(t) {
        var e = t.prev,
            n = t,
            i = t.next;
        if ($o(e, n, i) >= 0) return !1;
        for (var r = t.next.next; r !== t.prev;) {
            if (Qo(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && $o(r.prev, r, r.next) >= 0) return !1;
            r = r.next
        }
        return !0
    }

    function Vo(t, e, n, i) {
        var r = t.prev,
            o = t,
            a = t.next;
        if ($o(r, o, a) >= 0) return !1;
        for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, l = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, c = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, h = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, u = Jo(s, l, e, n, i), d = Jo(c, h, e, n, i), p = t.prevZ, f = t.nextZ; p && p.z >= u && f && f.z <= d;) {
            if (p !== t.prev && p !== t.next && Qo(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && $o(p.prev, p, p.next) >= 0) return !1;
            if (p = p.prevZ, f !== t.prev && f !== t.next && Qo(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && $o(f.prev, f, f.next) >= 0) return !1;
            f = f.nextZ
        }
        for (; p && p.z >= u;) {
            if (p !== t.prev && p !== t.next && Qo(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && $o(p.prev, p, p.next) >= 0) return !1;
            p = p.prevZ
        }
        for (; f && f.z <= d;) {
            if (f !== t.prev && f !== t.next && Qo(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && $o(f.prev, f, f.next) >= 0) return !1;
            f = f.nextZ
        }
        return !0
    }

    function jo(t, e, n) {
        var i = t;
        do {
            var r = i.prev,
                o = i.next.next;
            !ta(r, o) && ea(r, i, i.next, o) && ra(r, o) && ra(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), sa(i), sa(i.next), i = t = o), i = i.next
        } while (i !== t);
        return Uo(i)
    }

    function Wo(t, e, n, i, r, o) {
        var a = t;
        do {
            for (var s = a.next.next; s !== a.prev;) {
                if (a.i !== s.i && Ko(a, s)) {
                    var l = oa(a, s);
                    return a = Uo(a, a.next), l = Uo(l, l.next), Ho(a, e, n, i, r, o), void Ho(l, e, n, i, r, o)
                }
                s = s.next
            }
            a = a.next
        } while (a !== t)
    }

    function qo(t, e) {
        return t.x - e.x
    }

    function Xo(t, e) {
        if (e = function (t, e) {
                var n, i = e,
                    r = t.x,
                    o = t.y,
                    a = -1 / 0;
                do {
                    if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
                        var s = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (s <= r && s > a) {
                            if (a = s, s === r) {
                                if (o === i.y) return i;
                                if (o === i.next.y) return i.next
                            }
                            n = i.x < i.next.x ? i : i.next
                        }
                    }
                    i = i.next
                } while (i !== e);
                if (!n) return null;
                if (r === a) return n;
                var l, c = n,
                    h = n.x,
                    u = n.y,
                    d = 1 / 0;
                i = n;
                do {
                    r >= i.x && i.x >= h && r !== i.x && Qo(o < u ? r : a, o, h, u, o < u ? a : r, o, i.x, i.y) && (l = Math.abs(o - i.y) / (r - i.x), ra(i, t) && (l < d || l === d && (i.x > n.x || i.x === n.x && Yo(n, i))) && (n = i, d = l)), i = i.next
                } while (i !== c);
                return n
            }(t, e)) {
            var n = oa(e, t);
            Uo(e, e.next), Uo(n, n.next)
        }
    }

    function Yo(t, e) {
        return $o(t.prev, t, e.prev) < 0 && $o(e.next, t, t.next) < 0
    }

    function Jo(t, e, n, i, r) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }

    function Zo(t) {
        var e = t,
            n = t;
        do {
            (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
        } while (e !== t);
        return n
    }

    function Qo(t, e, n, i, r, o, a, s) {
        return (r - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (i - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0
    }

    function Ko(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && ! function (t, e) {
            var n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && ea(n, n.next, t, e)) return !0;
                n = n.next
            } while (n !== t);
            return !1
        }(t, e) && (ra(t, e) && ra(e, t) && function (t, e) {
            var n = t,
                i = !1,
                r = (t.x + e.x) / 2,
                o = (t.y + e.y) / 2;
            do {
                n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
            } while (n !== t);
            return i
        }(t, e) && ($o(t.prev, t, e.prev) || $o(t, e.prev, e)) || ta(t, e) && $o(t.prev, t, t.next) > 0 && $o(e.prev, e, e.next) > 0)
    }

    function $o(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }

    function ta(t, e) {
        return t.x === e.x && t.y === e.y
    }

    function ea(t, e, n, i) {
        var r = ia($o(t, e, n)),
            o = ia($o(t, e, i)),
            a = ia($o(n, i, t)),
            s = ia($o(n, i, e));
        return r !== o && a !== s || (!(0 !== r || !na(t, n, e)) || (!(0 !== o || !na(t, i, e)) || (!(0 !== a || !na(n, t, i)) || !(0 !== s || !na(n, e, i)))))
    }

    function na(t, e, n) {
        return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
    }

    function ia(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
    }

    function ra(t, e) {
        return $o(t.prev, t, t.next) < 0 ? $o(t, e, t.next) >= 0 && $o(t, t.prev, e) >= 0 : $o(t, e, t.prev) < 0 || $o(t, t.next, e) < 0
    }

    function oa(t, e) {
        var n = new la(t.i, t.x, t.y),
            i = new la(e.i, e.x, e.y),
            r = t.next,
            o = e.prev;
        return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
    }

    function aa(t, e, n, i) {
        var r = new la(t, e, n);
        return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
    }

    function sa(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function la(t, e, n) {
        this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
    var ca = {
        area: function (t) {
            for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
            return .5 * n
        },
        isClockWise: function (t) {
            return ca.area(t) < 0
        },
        triangulateShape: function (t, e) {
            var n = [],
                i = [],
                r = [];
            ha(t), ua(n, t);
            var o = t.length;
            e.forEach(ha);
            for (var a = 0; a < e.length; a++) i.push(o), o += e[a].length, ua(n, e[a]);
            var s = Bo(n, i);
            for (a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
            return r
        }
    };

    function ha(t) {
        var e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }

    function ua(t, e) {
        for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
    }

    function da(t, e) {
        qe.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t,
            options: e
        }, this.fromBufferGeometry(new pa(t, e)), this.mergeVertices()
    }

    function pa(t, e) {
        be.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: t,
            options: e
        }, t = Array.isArray(t) ? t : [t];
        for (var n = this, i = [], r = [], o = 0, a = t.length; o < a; o++) {
            s(t[o])
        }

        function s(t) {
            var o = [],
                a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                s = void 0 !== e.steps ? e.steps : 1,
                l = void 0 !== e.depth ? e.depth : 100,
                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                f = e.extrudePath,
                m = void 0 !== e.UVGenerator ? e.UVGenerator : fa;
            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
            var v, g, y, x, b, w, M, S, T = !1;
            f && (v = f.getSpacedPoints(s), T = !0, c = !1, g = f.computeFrenetFrames(s, !1), y = new P, x = new P, b = new P), c || (p = 0, h = 0, u = 0, d = 0);
            var E = t.extractPoints(a),
                A = E.shape,
                C = E.holes;
            if (!ca.isClockWise(A))
                for (A = A.reverse(), M = 0, S = C.length; M < S; M++) w = C[M], ca.isClockWise(w) && (C[M] = w.reverse());
            var L = ca.triangulateShape(A, C),
                R = A;
            for (M = 0, S = C.length; M < S; M++) w = C[M], A = A.concat(w);

            function O(t, e, n) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
            }
            var D, I, N, k, z, B, F = A.length,
                U = L.length;

            function H(t, e, n) {
                var i, r, o, a = t.x - e.x,
                    s = t.y - e.y,
                    l = n.x - t.x,
                    c = n.y - t.y,
                    h = a * a + s * s,
                    u = a * c - s * l;
                if (Math.abs(u) > Number.EPSILON) {
                    var d = Math.sqrt(h),
                        p = Math.sqrt(l * l + c * c),
                        f = e.x - s / d,
                        m = e.y + a / d,
                        v = ((n.x - c / p - f) * c - (n.y + l / p - m) * l) / (a * c - s * l),
                        g = (i = f + a * v - t.x) * i + (r = m + s * v - t.y) * r;
                    if (g <= 2) return new _(i, r);
                    o = Math.sqrt(g / 2)
                } else {
                    var y = !1;
                    a > Number.EPSILON ? l > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(c) && (y = !0), y ? (i = -s, r = a, o = Math.sqrt(h)) : (i = a, r = s, o = Math.sqrt(h / 2))
                }
                return new _(i / o, r / o)
            }
            for (var G = [], V = 0, j = R.length, W = j - 1, q = V + 1; V < j; V++, W++, q++) W === j && (W = 0), q === j && (q = 0), G[V] = H(R[V], R[W], R[q]);
            var X, Y, J = [],
                Z = G.concat();
            for (M = 0, S = C.length; M < S; M++) {
                for (w = C[M], X = [], V = 0, W = (j = w.length) - 1, q = V + 1; V < j; V++, W++, q++) W === j && (W = 0), q === j && (q = 0), X[V] = H(w[V], w[W], w[q]);
                J.push(X), Z = Z.concat(X)
            }
            for (D = 0; D < p; D++) {
                for (N = D / p, k = h * Math.cos(N * Math.PI / 2), I = u * Math.sin(N * Math.PI / 2) + d, V = 0, j = R.length; V < j; V++) K((z = O(R[V], G[V], I)).x, z.y, -k);
                for (M = 0, S = C.length; M < S; M++)
                    for (w = C[M], X = J[M], V = 0, j = w.length; V < j; V++) K((z = O(w[V], X[V], I)).x, z.y, -k)
            }
            for (I = u + d, V = 0; V < F; V++) z = c ? O(A[V], Z[V], I) : A[V], T ? (x.copy(g.normals[0]).multiplyScalar(z.x), y.copy(g.binormals[0]).multiplyScalar(z.y), b.copy(v[0]).add(x).add(y), K(b.x, b.y, b.z)) : K(z.x, z.y, 0);
            for (Y = 1; Y <= s; Y++)
                for (V = 0; V < F; V++) z = c ? O(A[V], Z[V], I) : A[V], T ? (x.copy(g.normals[Y]).multiplyScalar(z.x), y.copy(g.binormals[Y]).multiplyScalar(z.y), b.copy(v[Y]).add(x).add(y), K(b.x, b.y, b.z)) : K(z.x, z.y, l / s * Y);
            for (D = p - 1; D >= 0; D--) {
                for (N = D / p, k = h * Math.cos(N * Math.PI / 2), I = u * Math.sin(N * Math.PI / 2) + d, V = 0, j = R.length; V < j; V++) K((z = O(R[V], G[V], I)).x, z.y, l + k);
                for (M = 0, S = C.length; M < S; M++)
                    for (w = C[M], X = J[M], V = 0, j = w.length; V < j; V++) z = O(w[V], X[V], I), T ? K(z.x, z.y + v[s - 1].y, v[s - 1].x + k) : K(z.x, z.y, l + k)
            }

            function Q(t, e) {
                var n, i;
                for (V = t.length; --V >= 0;) {
                    n = V, (i = V - 1) < 0 && (i = t.length - 1);
                    var r = 0,
                        o = s + 2 * p;
                    for (r = 0; r < o; r++) {
                        var a = F * r,
                            l = F * (r + 1);
                        tt(e + n + a, e + i + a, e + i + l, e + n + l)
                    }
                }
            }

            function K(t, e, n) {
                o.push(t), o.push(e), o.push(n)
            }

            function $(t, e, r) {
                et(t), et(e), et(r);
                var o = i.length / 3,
                    a = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                nt(a[0]), nt(a[1]), nt(a[2])
            }

            function tt(t, e, r, o) {
                et(t), et(e), et(o), et(e), et(r), et(o);
                var a = i.length / 3,
                    s = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                nt(s[0]), nt(s[1]), nt(s[3]), nt(s[1]), nt(s[2]), nt(s[3])
            }

            function et(t) {
                i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2])
            }

            function nt(t) {
                r.push(t.x), r.push(t.y)
            }! function () {
                var t = i.length / 3;
                if (c) {
                    var e = 0,
                        r = F * e;
                    for (V = 0; V < U; V++) $((B = L[V])[2] + r, B[1] + r, B[0] + r);
                    for (r = F * (e = s + 2 * p), V = 0; V < U; V++) $((B = L[V])[0] + r, B[1] + r, B[2] + r)
                } else {
                    for (V = 0; V < U; V++) $((B = L[V])[2], B[1], B[0]);
                    for (V = 0; V < U; V++) $((B = L[V])[0] + F * s, B[1] + F * s, B[2] + F * s)
                }
                n.addGroup(t, i.length / 3 - t, 0)
            }(),
            function () {
                var t = i.length / 3,
                    e = 0;
                for (Q(R, e), e += R.length, M = 0, S = C.length; M < S; M++) Q(w = C[M], e), e += w.length;
                n.addGroup(t, i.length / 3 - t, 1)
            }()
        }
        this.setAttribute("position", new he(i, 3)), this.setAttribute("uv", new he(r, 2)), this.computeVertexNormals()
    }
    da.prototype = Object.create(qe.prototype), da.prototype.constructor = da, da.prototype.toJSON = function () {
        var t = qe.prototype.toJSON.call(this);
        return ma(this.parameters.shapes, this.parameters.options, t)
    }, pa.prototype = Object.create(be.prototype), pa.prototype.constructor = pa, pa.prototype.toJSON = function () {
        var t = be.prototype.toJSON.call(this);
        return ma(this.parameters.shapes, this.parameters.options, t)
    };
    var fa = {
        generateTopUV: function (t, e, n, i, r) {
            var o = e[3 * n],
                a = e[3 * n + 1],
                s = e[3 * i],
                l = e[3 * i + 1],
                c = e[3 * r],
                h = e[3 * r + 1];
            return [new _(o, a), new _(s, l), new _(c, h)]
        },
        generateSideWallUV: function (t, e, n, i, r, o) {
            var a = e[3 * n],
                s = e[3 * n + 1],
                l = e[3 * n + 2],
                c = e[3 * i],
                h = e[3 * i + 1],
                u = e[3 * i + 2],
                d = e[3 * r],
                p = e[3 * r + 1],
                f = e[3 * r + 2],
                m = e[3 * o],
                v = e[3 * o + 1],
                g = e[3 * o + 2];
            return Math.abs(s - h) < .01 ? [new _(a, 1 - l), new _(c, 1 - u), new _(d, 1 - f), new _(m, 1 - g)] : [new _(s, 1 - l), new _(h, 1 - u), new _(p, 1 - f), new _(v, 1 - g)]
        }
    };

    function ma(t, e, n) {
        if (n.shapes = [], Array.isArray(t))
            for (var i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                n.shapes.push(o.uuid)
            } else n.shapes.push(t.uuid);
        return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
    }

    function va(t, e) {
        qe.call(this), this.type = "TextGeometry", this.parameters = {
            text: t,
            parameters: e
        }, this.fromBufferGeometry(new ga(t, e)), this.mergeVertices()
    }

    function ga(t, e) {
        var n = (e = e || {}).font;
        if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new qe;
        var i = n.generateShapes(t, e.size);
        e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), pa.call(this, i, e), this.type = "TextBufferGeometry"
    }

    function ya(t, e, n, i, r, o, a) {
        qe.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        }, this.fromBufferGeometry(new _a(t, e, n, i, r, o, a)), this.mergeVertices()
    }

    function _a(t, e, n, i, r, o, a) {
        be.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
        var s, l, c = Math.min(o + a, Math.PI),
            h = 0,
            u = [],
            d = new P,
            p = new P,
            f = [],
            m = [],
            v = [],
            g = [];
        for (l = 0; l <= n; l++) {
            var y = [],
                _ = l / n,
                x = 0;
            for (0 == l && 0 == o ? x = .5 / e : l == n && c == Math.PI && (x = -.5 / e), s = 0; s <= e; s++) {
                var b = s / e;
                d.x = -t * Math.cos(i + b * r) * Math.sin(o + _ * a), d.y = t * Math.cos(o + _ * a), d.z = t * Math.sin(i + b * r) * Math.sin(o + _ * a), m.push(d.x, d.y, d.z), p.copy(d).normalize(), v.push(p.x, p.y, p.z), g.push(b + x, 1 - _), y.push(h++)
            }
            u.push(y)
        }
        for (l = 0; l < n; l++)
            for (s = 0; s < e; s++) {
                var w = u[l][s + 1],
                    M = u[l][s],
                    S = u[l + 1][s],
                    T = u[l + 1][s + 1];
                (0 !== l || o > 0) && f.push(w, M, T), (l !== n - 1 || c < Math.PI) && f.push(M, S, T)
            }
        this.setIndex(f), this.setAttribute("position", new he(m, 3)), this.setAttribute("normal", new he(v, 3)), this.setAttribute("uv", new he(g, 2))
    }

    function xa(t, e, n, i, r, o) {
        qe.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: o
        }, this.fromBufferGeometry(new ba(t, e, n, i, r, o)), this.mergeVertices()
    }

    function ba(t, e, n, i, r, o) {
        be.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: o
        }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        var a, s, l, c = [],
            h = [],
            u = [],
            d = [],
            p = t,
            f = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
            m = new P,
            v = new _;
        for (s = 0; s <= i; s++) {
            for (l = 0; l <= n; l++) a = r + l / n * o, m.x = p * Math.cos(a), m.y = p * Math.sin(a), h.push(m.x, m.y, m.z), u.push(0, 0, 1), v.x = (m.x / e + 1) / 2, v.y = (m.y / e + 1) / 2, d.push(v.x, v.y);
            p += f
        }
        for (s = 0; s < i; s++) {
            var g = s * (n + 1);
            for (l = 0; l < n; l++) {
                var y = a = l + g,
                    x = a + n + 1,
                    b = a + n + 2,
                    w = a + 1;
                c.push(y, x, w), c.push(x, b, w)
            }
        }
        this.setIndex(c), this.setAttribute("position", new he(h, 3)), this.setAttribute("normal", new he(u, 3)), this.setAttribute("uv", new he(d, 2))
    }

    function wa(t, e, n, i) {
        qe.call(this), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        }, this.fromBufferGeometry(new Ma(t, e, n, i)), this.mergeVertices()
    }

    function Ma(t, e, n, i) {
        be.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = y.clamp(i, 0, 2 * Math.PI);
        var r, o, a, s = [],
            l = [],
            c = [],
            h = 1 / e,
            u = new P,
            d = new _;
        for (o = 0; o <= e; o++) {
            var p = n + o * h * i,
                f = Math.sin(p),
                m = Math.cos(p);
            for (a = 0; a <= t.length - 1; a++) u.x = t[a].x * f, u.y = t[a].y, u.z = t[a].x * m, l.push(u.x, u.y, u.z), d.x = o / e, d.y = a / (t.length - 1), c.push(d.x, d.y)
        }
        for (o = 0; o < e; o++)
            for (a = 0; a < t.length - 1; a++) {
                var v = r = a + o * t.length,
                    g = r + t.length,
                    x = r + t.length + 1,
                    b = r + 1;
                s.push(v, g, b), s.push(g, x, b)
            }
        if (this.setIndex(s), this.setAttribute("position", new he(l, 3)), this.setAttribute("uv", new he(c, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
            var w = this.attributes.normal.array,
                M = new P,
                S = new P,
                T = new P;
            for (r = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3) M.x = w[a + 0], M.y = w[a + 1], M.z = w[a + 2], S.x = w[r + a + 0], S.y = w[r + a + 1], S.z = w[r + a + 2], T.addVectors(M, S).normalize(), w[a + 0] = w[r + a + 0] = T.x, w[a + 1] = w[r + a + 1] = T.y, w[a + 2] = w[r + a + 2] = T.z
        }
    }

    function Sa(t, e) {
        qe.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
            shapes: t,
            curveSegments: e
        }, this.fromBufferGeometry(new Ta(t, e)), this.mergeVertices()
    }

    function Ta(t, e) {
        be.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: t,
            curveSegments: e
        }, e = e || 12;
        var n = [],
            i = [],
            r = [],
            o = [],
            a = 0,
            s = 0;
        if (!1 === Array.isArray(t)) c(t);
        else
            for (var l = 0; l < t.length; l++) c(t[l]), this.addGroup(a, s, l), a += s, s = 0;

        function c(t) {
            var a, l, c, h = i.length / 3,
                u = t.extractPoints(e),
                d = u.shape,
                p = u.holes;
            for (!1 === ca.isClockWise(d) && (d = d.reverse()), a = 0, l = p.length; a < l; a++) c = p[a], !0 === ca.isClockWise(c) && (p[a] = c.reverse());
            var f = ca.triangulateShape(d, p);
            for (a = 0, l = p.length; a < l; a++) c = p[a], d = d.concat(c);
            for (a = 0, l = d.length; a < l; a++) {
                var m = d[a];
                i.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y)
            }
            for (a = 0, l = f.length; a < l; a++) {
                var v = f[a],
                    g = v[0] + h,
                    y = v[1] + h,
                    _ = v[2] + h;
                n.push(g, y, _), s += 3
            }
        }
        this.setIndex(n), this.setAttribute("position", new he(i, 3)), this.setAttribute("normal", new he(r, 3)), this.setAttribute("uv", new he(o, 2))
    }

    function Ea(t, e) {
        if (e.shapes = [], Array.isArray(t))
            for (var n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.shapes.push(r.uuid)
            } else e.shapes.push(t.uuid);
        return e
    }

    function Aa(t, e) {
        be.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: e
        }, e = void 0 !== e ? e : 1;
        var n, i, r, o, a = [],
            s = Math.cos(y.DEG2RAD * e),
            l = [0, 0],
            c = {},
            h = ["a", "b", "c"];
        t.isBufferGeometry ? (o = new qe).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
        for (var u = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
            for (var m = d[p], v = 0; v < 3; v++) n = m[h[v]], i = m[h[(v + 1) % 3]], l[0] = Math.min(n, i), l[1] = Math.max(n, i), void 0 === c[r = l[0] + "," + l[1]] ? c[r] = {
                index1: l[0],
                index2: l[1],
                face1: p,
                face2: void 0
            } : c[r].face2 = p;
        for (r in c) {
            var g = c[r];
            if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
                var _ = u[g.index1];
                a.push(_.x, _.y, _.z), _ = u[g.index2], a.push(_.x, _.y, _.z)
            }
        }
        this.setAttribute("position", new he(a, 3))
    }

    function Ca(t, e, n, i, r, o, a, s) {
        qe.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, this.fromBufferGeometry(new La(t, e, n, i, r, o, a, s)), this.mergeVertices()
    }

    function La(t, e, n, i, r, o, a, s) {
        be.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        };
        var l = this;
        t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
        var c = [],
            h = [],
            u = [],
            d = [],
            p = 0,
            f = [],
            m = n / 2,
            v = 0;

        function g(n) {
            var r, o, f, g = new _,
                y = new P,
                x = 0,
                b = !0 === n ? t : e,
                w = !0 === n ? 1 : -1;
            for (o = p, r = 1; r <= i; r++) h.push(0, m * w, 0), u.push(0, w, 0), d.push(.5, .5), p++;
            for (f = p, r = 0; r <= i; r++) {
                var M = r / i * s + a,
                    S = Math.cos(M),
                    T = Math.sin(M);
                y.x = b * T, y.y = m * w, y.z = b * S, h.push(y.x, y.y, y.z), u.push(0, w, 0), g.x = .5 * S + .5, g.y = .5 * T * w + .5, d.push(g.x, g.y), p++
            }
            for (r = 0; r < i; r++) {
                var E = o + r,
                    A = f + r;
                !0 === n ? c.push(A, A + 1, E) : c.push(A + 1, A, E), x += 3
            }
            l.addGroup(v, x, !0 === n ? 1 : 2), v += x
        }! function () {
            var o, g, y = new P,
                _ = new P,
                x = 0,
                b = (e - t) / n;
            for (g = 0; g <= r; g++) {
                var w = [],
                    M = g / r,
                    S = M * (e - t) + t;
                for (o = 0; o <= i; o++) {
                    var T = o / i,
                        E = T * s + a,
                        A = Math.sin(E),
                        C = Math.cos(E);
                    _.x = S * A, _.y = -M * n + m, _.z = S * C, h.push(_.x, _.y, _.z), y.set(A, b, C).normalize(), u.push(y.x, y.y, y.z), d.push(T, 1 - M), w.push(p++)
                }
                f.push(w)
            }
            for (o = 0; o < i; o++)
                for (g = 0; g < r; g++) {
                    var L = f[g][o],
                        R = f[g + 1][o],
                        O = f[g + 1][o + 1],
                        D = f[g][o + 1];
                    c.push(L, R, D), c.push(R, O, D), x += 6
                }
            l.addGroup(v, x, 0), v += x
        }(), !1 === o && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(c), this.setAttribute("position", new he(h, 3)), this.setAttribute("normal", new he(u, 3)), this.setAttribute("uv", new he(d, 2))
    }

    function Pa(t, e, n, i, r, o, a) {
        Ca.call(this, 0, t, e, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    function Ra(t, e, n, i, r, o, a) {
        La.call(this, 0, t, e, n, i, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    function Oa(t, e, n, i) {
        qe.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        }, this.fromBufferGeometry(new Da(t, e, n, i)), this.mergeVertices()
    }

    function Da(t, e, n, i) {
        be.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI;
        var r, o, a = [],
            s = [],
            l = [],
            c = [],
            h = new P,
            u = new _;
        for (s.push(0, 0, 0), l.push(0, 0, 1), c.push(.5, .5), o = 0, r = 3; o <= e; o++, r += 3) {
            var d = n + o / e * i;
            h.x = t * Math.cos(d), h.y = t * Math.sin(d), s.push(h.x, h.y, h.z), l.push(0, 0, 1), u.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, c.push(u.x, u.y)
        }
        for (r = 1; r <= e; r++) a.push(r, r + 1, 0);
        this.setIndex(a), this.setAttribute("position", new he(s, 3)), this.setAttribute("normal", new he(l, 3)), this.setAttribute("uv", new he(c, 2))
    }
    va.prototype = Object.create(qe.prototype), va.prototype.constructor = va, ga.prototype = Object.create(pa.prototype), ga.prototype.constructor = ga, ya.prototype = Object.create(qe.prototype), ya.prototype.constructor = ya, _a.prototype = Object.create(be.prototype), _a.prototype.constructor = _a, xa.prototype = Object.create(qe.prototype), xa.prototype.constructor = xa, ba.prototype = Object.create(be.prototype), ba.prototype.constructor = ba, wa.prototype = Object.create(qe.prototype), wa.prototype.constructor = wa, Ma.prototype = Object.create(be.prototype), Ma.prototype.constructor = Ma, Sa.prototype = Object.create(qe.prototype), Sa.prototype.constructor = Sa, Sa.prototype.toJSON = function () {
        var t = qe.prototype.toJSON.call(this);
        return Ea(this.parameters.shapes, t)
    }, Ta.prototype = Object.create(be.prototype), Ta.prototype.constructor = Ta, Ta.prototype.toJSON = function () {
        var t = be.prototype.toJSON.call(this);
        return Ea(this.parameters.shapes, t)
    }, Aa.prototype = Object.create(be.prototype), Aa.prototype.constructor = Aa, Ca.prototype = Object.create(qe.prototype), Ca.prototype.constructor = Ca, La.prototype = Object.create(be.prototype), La.prototype.constructor = La, Pa.prototype = Object.create(Ca.prototype), Pa.prototype.constructor = Pa, Ra.prototype = Object.create(La.prototype), Ra.prototype.constructor = Ra, Oa.prototype = Object.create(qe.prototype), Oa.prototype.constructor = Oa, Da.prototype = Object.create(be.prototype), Da.prototype.constructor = Da;
    var Ia = Object.freeze({
        __proto__: null,
        WireframeGeometry: _o,
        ParametricGeometry: xo,
        ParametricBufferGeometry: bo,
        TetrahedronGeometry: So,
        TetrahedronBufferGeometry: To,
        OctahedronGeometry: Eo,
        OctahedronBufferGeometry: Ao,
        IcosahedronGeometry: Co,
        IcosahedronBufferGeometry: Lo,
        DodecahedronGeometry: Po,
        DodecahedronBufferGeometry: Ro,
        PolyhedronGeometry: wo,
        PolyhedronBufferGeometry: Mo,
        TubeGeometry: Oo,
        TubeBufferGeometry: Do,
        TorusKnotGeometry: Io,
        TorusKnotBufferGeometry: No,
        TorusGeometry: ko,
        TorusBufferGeometry: zo,
        TextGeometry: va,
        TextBufferGeometry: ga,
        SphereGeometry: ya,
        SphereBufferGeometry: _a,
        RingGeometry: xa,
        RingBufferGeometry: ba,
        PlaneGeometry: hn,
        PlaneBufferGeometry: un,
        LatheGeometry: wa,
        LatheBufferGeometry: Ma,
        ShapeGeometry: Sa,
        ShapeBufferGeometry: Ta,
        ExtrudeGeometry: da,
        ExtrudeBufferGeometry: pa,
        EdgesGeometry: Aa,
        ConeGeometry: Pa,
        ConeBufferGeometry: Ra,
        CylinderGeometry: Ca,
        CylinderBufferGeometry: La,
        CircleGeometry: Oa,
        CircleBufferGeometry: Da,
        BoxGeometry: class extends qe {
            constructor(t, e, n, i, r, o) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: o
                }, this.fromBufferGeometry(new Xe(t, e, n, i, r, o)), this.mergeVertices()
            }
        },
        BoxBufferGeometry: Xe
    });

    function Na(t) {
        $t.call(this), this.type = "ShadowMaterial", this.color = new Xt(0), this.transparent = !0, this.setValues(t)
    }

    function ka(t) {
        Qe.call(this, t), this.type = "RawShaderMaterial"
    }

    function za(t) {
        $t.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Xt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new _(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t)
    }

    function Ba(t) {
        za.call(this), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new _(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transparency = 0, this.setValues(t)
    }

    function Fa(t) {
        $t.call(this), this.type = "MeshPhongMaterial", this.color = new Xt(16777215), this.specular = new Xt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new _(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Ua(t) {
        $t.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new Xt(16777215), this.specular = new Xt(1118481), this.shininess = 30, this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new _(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Ha(t) {
        $t.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new _(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Ga(t) {
        $t.call(this), this.type = "MeshLambertMaterial", this.color = new Xt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Va(t) {
        $t.call(this), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Xt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new _(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function ja(t) {
        Zr.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }
    Na.prototype = Object.create($t.prototype), Na.prototype.constructor = Na, Na.prototype.isShadowMaterial = !0, Na.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.color.copy(t.color), this
    }, ka.prototype = Object.create(Qe.prototype), ka.prototype.constructor = ka, ka.prototype.isRawShaderMaterial = !0, za.prototype = Object.create($t.prototype), za.prototype.constructor = za, za.prototype.isMeshStandardMaterial = !0, za.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this
    }, Ba.prototype = Object.create(za.prototype), Ba.prototype.constructor = Ba, Ba.prototype.isMeshPhysicalMaterial = !0, Ba.prototype.copy = function (t) {
        return za.prototype.copy.call(this, t), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Xt).copy(t.sheen) : this.sheen = null, this.transparency = t.transparency, this
    }, Fa.prototype = Object.create($t.prototype), Fa.prototype.constructor = Fa, Fa.prototype.isMeshPhongMaterial = !0, Fa.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Ua.prototype = Object.create($t.prototype), Ua.prototype.constructor = Ua, Ua.prototype.isMeshToonMaterial = !0, Ua.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Ha.prototype = Object.create($t.prototype), Ha.prototype.constructor = Ha, Ha.prototype.isMeshNormalMaterial = !0, Ha.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Ga.prototype = Object.create($t.prototype), Ga.prototype.constructor = Ga, Ga.prototype.isMeshLambertMaterial = !0, Ga.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Va.prototype = Object.create($t.prototype), Va.prototype.constructor = Va, Va.prototype.isMeshMatcapMaterial = !0, Va.prototype.copy = function (t) {
        return $t.prototype.copy.call(this, t), this.defines = {
            MATCAP: ""
        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, ja.prototype = Object.create(Zr.prototype), ja.prototype.constructor = ja, ja.prototype.isLineDashedMaterial = !0, ja.prototype.copy = function (t) {
        return Zr.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    };
    var Wa = Object.freeze({
            __proto__: null,
            ShadowMaterial: Na,
            SpriteMaterial: gr,
            RawShaderMaterial: ka,
            ShaderMaterial: Qe,
            PointsMaterial: so,
            MeshPhysicalMaterial: Ba,
            MeshStandardMaterial: za,
            MeshPhongMaterial: Fa,
            MeshToonMaterial: Ua,
            MeshNormalMaterial: Ha,
            MeshLambertMaterial: Ga,
            MeshDepthMaterial: tr,
            MeshDistanceMaterial: er,
            MeshBasicMaterial: te,
            MeshMatcapMaterial: Va,
            LineDashedMaterial: ja,
            LineBasicMaterial: Zr,
            Material: $t
        }),
        qa = {
            arraySlice: function (t, e, n) {
                return qa.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            },
            convertArray: function (t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function (t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function (t) {
                for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i) n[i] = i;
                return n.sort((function (e, n) {
                    return t[e] - t[n]
                })), n
            },
            sortedArray: function (t, e, n) {
                for (var i = t.length, r = new t.constructor(i), o = 0, a = 0; a !== i; ++o)
                    for (var s = n[o] * e, l = 0; l !== e; ++l) r[a++] = t[s + l];
                return r
            },
            flattenJSON: function (t, e, n, i) {
                for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[i];) o = t[r++];
                if (void 0 !== o) {
                    var a = o[i];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                void 0 !== (a = o[i]) && (e.push(o.time), n.push.apply(n, a)), o = t[r++]
                            } while (void 0 !== o);
                        else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = o[i]) && (e.push(o.time), a.toArray(n, n.length)), o = t[r++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (a = o[i]) && (e.push(o.time), n.push(a)), o = t[r++]
                        } while (void 0 !== o)
                }
            },
            subclip: function (t, e, n, i, r) {
                r = r || 30;
                var o = t.clone();
                o.name = e;
                for (var a = [], s = 0; s < o.tracks.length; ++s) {
                    for (var l = o.tracks[s], c = l.getValueSize(), h = [], u = [], d = 0; d < l.times.length; ++d) {
                        var p = l.times[d] * r;
                        if (!(p < n || p >= i)) {
                            h.push(l.times[d]);
                            for (var f = 0; f < c; ++f) u.push(l.values[d * c + f])
                        }
                    }
                    0 !== h.length && (l.times = qa.convertArray(h, l.times.constructor), l.values = qa.convertArray(u, l.values.constructor), a.push(l))
                }
                o.tracks = a;
                var m = 1 / 0;
                for (s = 0; s < o.tracks.length; ++s) m > o.tracks[s].times[0] && (m = o.tracks[s].times[0]);
                for (s = 0; s < o.tracks.length; ++s) o.tracks[s].shift(-1 * m);
                return o.resetDuration(), o
            },
            makeClipAdditive: function (t, e, n, i) {
                void 0 === e && (e = 0), void 0 === n && (n = t), (void 0 === i || i <= 0) && (i = 30);
                for (var r = t.tracks.length, o = e / i, a = 0; a < r; ++a) {
                    var s = n.tracks[a],
                        l = s.ValueTypeName;
                    if ("bool" !== l && "string" !== l) {
                        var c = t.tracks.find((function (t) {
                            return t.name === s.name && t.ValueTypeName === l
                        }));
                        if (void 0 !== c) {
                            var h, u = s.getValueSize(),
                                d = s.times.length - 1;
                            if (o <= s.times[0]) h = qa.arraySlice(s.values, 0, s.valueSize);
                            else if (o >= s.times[d]) {
                                var p = d * u;
                                h = qa.arraySlice(s.values, p)
                            } else {
                                var f = s.createInterpolant();
                                f.evaluate(o), h = f.resultBuffer
                            }
                            if ("quaternion" === l) new A(h[0], h[1], h[2], h[3]).normalize().conjugate().toArray(h);
                            for (var m = c.times.length, v = 0; v < m; ++v) {
                                var g = v * u;
                                if ("quaternion" === l) A.multiplyQuaternionsFlat(c.values, g, h, 0, c.values, g);
                                else
                                    for (var y = 0; y < u; ++y) c.values[g + y] -= h[y]
                            }
                        }
                    }
                }
                return t.blendMode = 2501, t
            }
        };

    function Xa(t, e, n, i) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
    }

    function Ya(t, e, n, i) {
        Xa.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function Ja(t, e, n, i) {
        Xa.call(this, t, e, n, i)
    }

    function Za(t, e, n, i) {
        Xa.call(this, t, e, n, i)
    }

    function Qa(t, e, n, i) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = qa.convertArray(e, this.TimeBufferType), this.values = qa.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
    }

    function Ka(t, e, n) {
        Qa.call(this, t, e, n)
    }

    function $a(t, e, n, i) {
        Qa.call(this, t, e, n, i)
    }

    function ts(t, e, n, i) {
        Qa.call(this, t, e, n, i)
    }

    function es(t, e, n, i) {
        Xa.call(this, t, e, n, i)
    }

    function ns(t, e, n, i) {
        Qa.call(this, t, e, n, i)
    }

    function is(t, e, n, i) {
        Qa.call(this, t, e, n, i)
    }

    function rs(t, e, n, i) {
        Qa.call(this, t, e, n, i)
    }

    function os(t, e, n, i) {
        this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== i ? i : 2500, this.uuid = y.generateUUID(), this.duration < 0 && this.resetDuration()
    }

    function as(t) {
        if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var e = function (t) {
            switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return ts;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return rs;
                case "color":
                    return $a;
                case "quaternion":
                    return ns;
                case "bool":
                case "boolean":
                    return Ka;
                case "string":
                    return is
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }(t.type);
        if (void 0 === t.times) {
            var n = [],
                i = [];
            qa.flattenJSON(t.keys, n, i, "value"), t.times = n, t.values = i
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
    }
    Object.assign(Xa.prototype, {
        evaluate: function (t) {
            var e = this.parameterPositions,
                n = this._cachedIndex,
                i = e[n],
                r = e[n - 1];
            t: {
                e: {
                    var o;n: {
                        i: if (!(t < i)) {
                            for (var a = n + 2;;) {
                                if (void 0 === i) {
                                    if (t < r) break i;
                                    return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                }
                                if (n === a) break;
                                if (r = i, t < (i = e[++n])) break e
                            }
                            o = e.length;
                            break n
                        }if (t >= r) break t;
                        var s = e[1];t < s && (n = 2, r = s);
                        for (a = n - 2;;) {
                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                            if (n === a) break;
                            if (i = r, t >= (r = e[--n - 1])) break e
                        }
                        o = n,
                        n = 0
                    }
                    for (; n < o;) {
                        var l = n + o >>> 1;
                        t < e[l] ? o = l : n = l + 1
                    }
                    if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0,
                    this.beforeStart_(0, t, i);
                    if (void 0 === i) return n = e.length,
                    this._cachedIndex = n,
                    this.afterEnd_(n - 1, r, t)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function (t) {
            for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, o = 0; o !== i; ++o) e[o] = n[r + o];
            return e
        },
        interpolate_: function () {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function () {}
    }), Object.assign(Xa.prototype, {
        beforeStart_: Xa.prototype.copySampleValue_,
        afterEnd_: Xa.prototype.copySampleValue_
    }), Ya.prototype = Object.assign(Object.create(Xa.prototype), {
        constructor: Ya,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function (t, e, n) {
            var i = this.parameterPositions,
                r = t - 2,
                o = t + 1,
                a = i[r],
                s = i[o];
            if (void 0 === a) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = t, a = 2 * e - n;
                    break;
                case 2402:
                    a = e + i[r = i.length - 2] - i[r + 1];
                    break;
                default:
                    r = t, a = n
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = t, s = 2 * n - e;
                    break;
                case 2402:
                    o = 1, s = n + i[1] - i[0];
                    break;
                default:
                    o = t - 1, s = e
            }
            var l = .5 * (n - e),
                c = this.valueSize;
            this._weightPrev = l / (e - a), this._weightNext = l / (s - n), this._offsetPrev = r * c, this._offsetNext = o * c
        },
        interpolate_: function (t, e, n, i) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (n - e) / (i - e), f = p * p, m = f * p, v = -u * m + 2 * u * f - u * p, g = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f, x = 0; x !== a; ++x) r[x] = v * o[c + x] + g * o[l + x] + y * o[s + x] + _ * o[h + x];
            return r
        }
    }), Ja.prototype = Object.assign(Object.create(Xa.prototype), {
        constructor: Ja,
        interpolate_: function (t, e, n, i) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, c = (n - e) / (i - e), h = 1 - c, u = 0; u !== a; ++u) r[u] = o[l + u] * h + o[s + u] * c;
            return r
        }
    }), Za.prototype = Object.assign(Object.create(Xa.prototype), {
        constructor: Za,
        interpolate_: function (t) {
            return this.copySampleValue_(t - 1)
        }
    }), Object.assign(Qa, {
        toJSON: function (t) {
            var e, n = t.constructor;
            if (void 0 !== n.toJSON) e = n.toJSON(t);
            else {
                e = {
                    name: t.name,
                    times: qa.convertArray(t.times, Array),
                    values: qa.convertArray(t.values, Array)
                };
                var i = t.getInterpolation();
                i !== t.DefaultInterpolation && (e.interpolation = i)
            }
            return e.type = t.ValueTypeName, e
        }
    }), Object.assign(Qa.prototype, {
        constructor: Qa,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (t) {
            return new Za(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodLinear: function (t) {
            return new Ja(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: function (t) {
            return new Ya(this.times, this.values, this.getValueSize(), t)
        },
        setInterpolation: function (t) {
            var e;
            switch (t) {
                case 2300:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation) throw new Error(n);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", n), this
            }
            return this.createInterpolant = e, this
        },
        getInterpolation: function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function () {
            return this.values.length / this.times.length
        },
        shift: function (t) {
            if (0 !== t)
                for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] += t;
            return this
        },
        scale: function (t) {
            if (1 !== t)
                for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] *= t;
            return this
        },
        trim: function (t, e) {
            for (var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < t;) ++r;
            for (; - 1 !== o && n[o] > e;) --o;
            if (++o, 0 !== r || o !== i) {
                r >= o && (r = (o = Math.max(o, 1)) - 1);
                var a = this.getValueSize();
                this.times = qa.arraySlice(n, r, o), this.values = qa.arraySlice(this.values, r * a, o * a)
            }
            return this
        },
        validate: function () {
            var t = !0,
                e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
            var n = this.times,
                i = this.values,
                r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
            for (var o = null, a = 0; a !== r; a++) {
                var s = n[a];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                    break
                }
                if (null !== o && o > s) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                    break
                }
                o = s
            }
            if (void 0 !== i && qa.isTypedArray(i)) {
                a = 0;
                for (var l = i.length; a !== l; ++a) {
                    var c = i[a];
                    if (isNaN(c)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), t = !1;
                        break
                    }
                }
            }
            return t
        },
        optimize: function () {
            for (var t = qa.arraySlice(this.times), e = qa.arraySlice(this.values), n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                var s = !1,
                    l = t[a];
                if (l !== t[a + 1] && (1 !== a || l !== l[0]))
                    if (i) s = !0;
                    else
                        for (var c = a * n, h = c - n, u = c + n, d = 0; d !== n; ++d) {
                            var p = e[c + d];
                            if (p !== e[h + d] || p !== e[u + d]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (a !== r) {
                        t[r] = t[a];
                        var f = a * n,
                            m = r * n;
                        for (d = 0; d !== n; ++d) e[m + d] = e[f + d]
                    }++r
                }
            }
            if (o > 0) {
                t[r] = t[o];
                for (f = o * n, m = r * n, d = 0; d !== n; ++d) e[m + d] = e[f + d];
                ++r
            }
            return r !== t.length ? (this.times = qa.arraySlice(t, 0, r), this.values = qa.arraySlice(e, 0, r * n)) : (this.times = t, this.values = e), this
        },
        clone: function () {
            var t = qa.arraySlice(this.times, 0),
                e = qa.arraySlice(this.values, 0),
                n = new(0, this.constructor)(this.name, t, e);
            return n.createInterpolant = this.createInterpolant, n
        }
    }), Ka.prototype = Object.assign(Object.create(Qa.prototype), {
        constructor: Ka,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), $a.prototype = Object.assign(Object.create(Qa.prototype), {
        constructor: $a,
        ValueTypeName: "color"
    }), ts.prototype = Object.assign(Object.create(Qa.prototype), {
        constructor: ts,
        ValueTypeName: "number"
    }), es.prototype = Object.assign(Object.create(Xa.prototype), {
        constructor: es,
        interpolate_: function (t, e, n, i) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = (n - e) / (i - e), c = s + a; s !== c; s += 4) A.slerpFlat(r, 0, o, s - a, o, s, l);
            return r
        }
    }), ns.prototype = Object.assign(Object.create(Qa.prototype), {
        constructor: ns,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (t) {
            return new es(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), is.prototype = Object.assign(Object.create(Qa.prototype), {
        constructor: is,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), rs.prototype = Object.assign(Object.create(Qa.prototype), {
        constructor: rs,
        ValueTypeName: "vector"
    }), Object.assign(os, {
        parse: function (t) {
            for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, o = n.length; r !== o; ++r) e.push(as(n[r]).scale(i));
            return new os(t.name, t.duration, e, t.blendMode)
        },
        toJSON: function (t) {
            for (var e = [], n = t.tracks, i = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid,
                    blendMode: t.blendMode
                }, r = 0, o = n.length; r !== o; ++r) e.push(Qa.toJSON(n[r]));
            return i
        },
        CreateFromMorphTargetSequence: function (t, e, n, i) {
            for (var r = e.length, o = [], a = 0; a < r; a++) {
                var s = [],
                    l = [];
                s.push((a + r - 1) % r, a, (a + 1) % r), l.push(0, 1, 0);
                var c = qa.getKeyframeOrder(s);
                s = qa.sortedArray(s, 1, c), l = qa.sortedArray(l, 1, c), i || 0 !== s[0] || (s.push(r), l.push(l[0])), o.push(new ts(".morphTargetInfluences[" + e[a].name + "]", s, l).scale(1 / n))
            }
            return new os(t, -1, o)
        },
        findByName: function (t, e) {
            var n = t;
            if (!Array.isArray(t)) {
                var i = t;
                n = i.geometry && i.geometry.animations || i.animations
            }
            for (var r = 0; r < n.length; r++)
                if (n[r].name === e) return n[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function (t, e, n) {
            for (var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                var s = t[o],
                    l = s.name.match(r);
                if (l && l.length > 1) {
                    var c = i[u = l[1]];
                    c || (i[u] = c = []), c.push(s)
                }
            }
            var h = [];
            for (var u in i) h.push(os.CreateFromMorphTargetSequence(u, i[u], e, n));
            return h
        },
        parseAnimation: function (t, e) {
            if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            for (var n = function (t, e, n, i, r) {
                    if (0 !== n.length) {
                        var o = [],
                            a = [];
                        qa.flattenJSON(n, o, a, i), 0 !== o.length && r.push(new t(e, o, a))
                    }
                }, i = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.blendMode, l = t.hierarchy || [], c = 0; c < l.length; c++) {
                var h = l[c].keys;
                if (h && 0 !== h.length)
                    if (h[0].morphTargets) {
                        for (var u = {}, d = 0; d < h.length; d++)
                            if (h[d].morphTargets)
                                for (var p = 0; p < h[d].morphTargets.length; p++) u[h[d].morphTargets[p]] = -1;
                        for (var f in u) {
                            var m = [],
                                v = [];
                            for (p = 0; p !== h[d].morphTargets.length; ++p) {
                                var g = h[d];
                                m.push(g.time), v.push(g.morphTarget === f ? 1 : 0)
                            }
                            i.push(new ts(".morphTargetInfluence[" + f + "]", m, v))
                        }
                        o = u.length * (a || 1)
                    } else {
                        var y = ".bones[" + e[c].name + "]";
                        n(rs, y + ".position", h, "pos", i), n(ns, y + ".quaternion", h, "rot", i), n(rs, y + ".scale", h, "scl", i)
                    }
            }
            return 0 === i.length ? null : new os(r, o, i, s)
        }
    }), Object.assign(os.prototype, {
        resetDuration: function () {
            for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
                var i = this.tracks[e];
                t = Math.max(t, i.times[i.times.length - 1])
            }
            return this.duration = t, this
        },
        trim: function () {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
            return this
        },
        validate: function () {
            for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
            return t
        },
        optimize: function () {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
            return this
        },
        clone: function () {
            for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
            return new os(this.name, this.duration, t, this.blendMode)
        }
    });
    var ss = {
        enabled: !1,
        files: {},
        add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function (t) {
            if (!1 !== this.enabled) return this.files[t]
        },
        remove: function (t) {
            delete this.files[t]
        },
        clear: function () {
            this.files = {}
        }
    };

    function ls(t, e, n) {
        var i = this,
            r = !1,
            o = 0,
            a = 0,
            s = void 0,
            l = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
            a++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, a), r = !0
        }, this.itemEnd = function (t) {
            o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (r = !1, void 0 !== i.onLoad && i.onLoad())
        }, this.itemError = function (t) {
            void 0 !== i.onError && i.onError(t)
        }, this.resolveURL = function (t) {
            return s ? s(t) : t
        }, this.setURLModifier = function (t) {
            return s = t, this
        }, this.addHandler = function (t, e) {
            return l.push(t, e), this
        }, this.removeHandler = function (t) {
            var e = l.indexOf(t);
            return -1 !== e && l.splice(e, 2), this
        }, this.getHandler = function (t) {
            for (var e = 0, n = l.length; e < n; e += 2) {
                var i = l[e],
                    r = l[e + 1];
                if (i.global && (i.lastIndex = 0), i.test(t)) return r
            }
            return null
        }
    }
    var cs = new ls;

    function hs(t) {
        this.manager = void 0 !== t ? t : cs, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = ""
    }
    Object.assign(hs.prototype, {
        load: function () {},
        loadAsync: function (t, e) {
            var n = this;
            return new Promise((function (i, r) {
                n.load(t, i, e, r)
            }))
        },
        parse: function () {},
        setCrossOrigin: function (t) {
            return this.crossOrigin = t, this
        },
        setPath: function (t) {
            return this.path = t, this
        },
        setResourcePath: function (t) {
            return this.resourcePath = t, this
        }
    });
    var us = {};

    function ds(t) {
        hs.call(this, t)
    }

    function ps(t) {
        hs.call(this, t)
    }

    function fs(t) {
        hs.call(this, t)
    }

    function ms(t) {
        hs.call(this, t)
    }

    function vs(t) {
        hs.call(this, t)
    }

    function gs(t) {
        hs.call(this, t)
    }

    function ys(t) {
        hs.call(this, t)
    }

    function _s() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function xs(t, e, n, i, r, o, a, s) {
        _s.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
    }

    function bs(t, e, n, i, r, o) {
        xs.call(this, t, e, n, n, i, r, o), this.type = "ArcCurve"
    }

    function ws() {
        var t = 0,
            e = 0,
            n = 0,
            i = 0;

        function r(r, o, a, s) {
            t = r, e = a, n = -3 * r + 3 * o - 2 * a - s, i = 2 * r - 2 * o + a + s
        }
        return {
            initCatmullRom: function (t, e, n, i, o) {
                r(e, n, o * (n - t), o * (i - e))
            },
            initNonuniformCatmullRom: function (t, e, n, i, o, a, s) {
                var l = (e - t) / o - (n - t) / (o + a) + (n - e) / a,
                    c = (n - e) / a - (i - e) / (a + s) + (i - n) / s;
                r(e, n, l *= a, c *= a)
            },
            calc: function (r) {
                var o = r * r;
                return t + e * r + n * o + i * (o * r)
            }
        }
    }
    ds.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: ds,
        load: function (t, e, n, i) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var r = this,
                o = ss.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () {
                e && e(o), r.manager.itemEnd(t)
            }), 0), o;
            if (void 0 === us[t]) {
                var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var s = a[1],
                        l = !!a[2],
                        c = a[3];
                    c = decodeURIComponent(c), l && (c = atob(c));
                    try {
                        var h, u = (this.responseType || "").toLowerCase();
                        switch (u) {
                            case "arraybuffer":
                            case "blob":
                                for (var d = new Uint8Array(c.length), p = 0; p < c.length; p++) d[p] = c.charCodeAt(p);
                                h = "blob" === u ? new Blob([d.buffer], {
                                    type: s
                                }) : d.buffer;
                                break;
                            case "document":
                                var f = new DOMParser;
                                h = f.parseFromString(c, s);
                                break;
                            case "json":
                                h = JSON.parse(c);
                                break;
                            default:
                                h = c
                        }
                        setTimeout((function () {
                            e && e(h), r.manager.itemEnd(t)
                        }), 0)
                    } catch (e) {
                        setTimeout((function () {
                            i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                        }), 0)
                    }
                } else {
                    us[t] = [], us[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                    var m = new XMLHttpRequest;
                    for (var v in m.open("GET", t, !0), m.addEventListener("load", (function (e) {
                            var n = this.response,
                                i = us[t];
                            if (delete us[t], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), ss.add(t, n);
                                for (var o = 0, a = i.length; o < a; o++) {
                                    (s = i[o]).onLoad && s.onLoad(n)
                                }
                                r.manager.itemEnd(t)
                            } else {
                                for (o = 0, a = i.length; o < a; o++) {
                                    var s;
                                    (s = i[o]).onError && s.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }
                        }), !1), m.addEventListener("progress", (function (e) {
                            for (var n = us[t], i = 0, r = n.length; i < r; i++) {
                                var o = n[i];
                                o.onProgress && o.onProgress(e)
                            }
                        }), !1), m.addEventListener("error", (function (e) {
                            var n = us[t];
                            delete us[t];
                            for (var i = 0, o = n.length; i < o; i++) {
                                var a = n[i];
                                a.onError && a.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }), !1), m.addEventListener("abort", (function (e) {
                            var n = us[t];
                            delete us[t];
                            for (var i = 0, o = n.length; i < o; i++) {
                                var a = n[i];
                                a.onError && a.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }), !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                    m.send(null)
                }
                return r.manager.itemStart(t), m
            }
            us[t].push({
                onLoad: e,
                onProgress: n,
                onError: i
            })
        },
        setResponseType: function (t) {
            return this.responseType = t, this
        },
        setWithCredentials: function (t) {
            return this.withCredentials = t, this
        },
        setMimeType: function (t) {
            return this.mimeType = t, this
        },
        setRequestHeader: function (t) {
            return this.requestHeader = t, this
        }
    }), ps.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: ps,
        load: function (t, e, n, i) {
            var r = this,
                o = new ds(r.manager);
            o.setPath(r.path), o.load(t, (function (t) {
                e(r.parse(JSON.parse(t)))
            }), n, i)
        },
        parse: function (t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var i = os.parse(t[n]);
                e.push(i)
            }
            return e
        }
    }), fs.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: fs,
        load: function (t, e, n, i) {
            var r = this,
                o = [],
                a = new vo;
            a.image = o;
            var s = new ds(this.manager);

            function l(l) {
                s.load(t[l], (function (t) {
                    var n = r.parse(t, !0);
                    o[l] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    }, 6 === (c += 1) && (1 === n.mipmapCount && (a.minFilter = 1006), a.format = n.format, a.needsUpdate = !0, e && e(a))
                }), n, i)
            }
            if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                for (var c = 0, h = 0, u = t.length; h < u; ++h) l(h);
            else s.load(t, (function (t) {
                var n = r.parse(t, !0);
                if (n.isCubemap)
                    for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                        o[s] = {
                            mipmaps: []
                        };
                        for (var l = 0; l < n.mipmapCount; l++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + l]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
                    } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                1 === n.mipmapCount && (a.minFilter = 1006), a.format = n.format, a.needsUpdate = !0, e && e(a)
            }), n, i);
            return a
        }
    }), ms.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: ms,
        load: function (t, e, n, i) {
            var r = this,
                o = new nn,
                a = new ds(this.manager);
            return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(t, (function (t) {
                var n = r.parse(t);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001, o.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001, o.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006, o.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = 1008), 1 === n.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, e && e(o, n))
            }), n, i), o
        }
    }), vs.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: vs,
        load: function (t, e, n, i) {
            void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var r = this,
                o = ss.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () {
                e && e(o), r.manager.itemEnd(t)
            }), 0), o;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

            function s() {
                a.removeEventListener("load", s, !1), a.removeEventListener("error", l, !1), ss.add(t, this), e && e(this), r.manager.itemEnd(t)
            }

            function l(e) {
                a.removeEventListener("load", s, !1), a.removeEventListener("error", l, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
            }
            return a.addEventListener("load", s, !1), a.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
        }
    }), gs.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: gs,
        load: function (t, e, n, i) {
            var r = new Tn,
                o = new vs(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            var a = 0;

            function s(n) {
                o.load(t[n], (function (t) {
                    r.images[n] = t, 6 === ++a && (r.needsUpdate = !0, e && e(r))
                }), void 0, i)
            }
            for (var l = 0; l < t.length; ++l) s(l);
            return r
        }
    }), ys.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: ys,
        load: function (t, e, n, i) {
            var r = new M,
                o = new vs(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (n) {
                r.image = n;
                var i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== e && e(r)
            }), n, i), r
        }
    }), Object.assign(_s.prototype, {
        getPoint: function () {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function (t, e) {
            var n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        },
        getPoints: function (t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e
        },
        getSpacedPoints: function (t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e
        },
        getLength: function () {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function (t) {
            if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, n, i = [],
                r = this.getPoint(0),
                o = 0;
            for (i.push(0), n = 1; n <= t; n++) o += (e = this.getPoint(n / t)).distanceTo(r), i.push(o), r = e;
            return this.cacheArcLengths = i, i
        },
        updateArcLengths: function () {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function (t, e) {
            var n, i = this.getLengths(),
                r = 0,
                o = i.length;
            n = e || t * i[o - 1];
            for (var a, s = 0, l = o - 1; s <= l;)
                if ((a = i[r = Math.floor(s + (l - s) / 2)] - n) < 0) s = r + 1;
                else {
                    if (!(a > 0)) {
                        l = r;
                        break
                    }
                    l = r - 1
                } if (i[r = l] === n) return r / (o - 1);
            var c = i[r];
            return (r + (n - c) / (i[r + 1] - c)) / (o - 1)
        },
        getTangent: function (t, e) {
            var n = t - 1e-4,
                i = t + 1e-4;
            n < 0 && (n = 0), i > 1 && (i = 1);
            var r = this.getPoint(n),
                o = this.getPoint(i),
                a = e || (r.isVector2 ? new _ : new P);
            return a.copy(o).sub(r).normalize(), a
        },
        getTangentAt: function (t, e) {
            var n = this.getUtoTmapping(t);
            return this.getTangent(n, e)
        },
        computeFrenetFrames: function (t, e) {
            var n, i, r, o = new P,
                a = [],
                s = [],
                l = [],
                c = new P,
                h = new B;
            for (n = 0; n <= t; n++) i = n / t, a[n] = this.getTangentAt(i, new P), a[n].normalize();
            s[0] = new P, l[0] = new P;
            var u = Number.MAX_VALUE,
                d = Math.abs(a[0].x),
                p = Math.abs(a[0].y),
                f = Math.abs(a[0].z);
            for (d <= u && (u = d, o.set(1, 0, 0)), p <= u && (u = p, o.set(0, 1, 0)), f <= u && o.set(0, 0, 1), c.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], c), l[0].crossVectors(a[0], s[0]), n = 1; n <= t; n++) s[n] = s[n - 1].clone(), l[n] = l[n - 1].clone(), c.crossVectors(a[n - 1], a[n]), c.length() > Number.EPSILON && (c.normalize(), r = Math.acos(y.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(h.makeRotationAxis(c, r))), l[n].crossVectors(a[n], s[n]);
            if (!0 === e)
                for (r = Math.acos(y.clamp(s[0].dot(s[t]), -1, 1)), r /= t, a[0].dot(c.crossVectors(s[0], s[t])) > 0 && (r = -r), n = 1; n <= t; n++) s[n].applyMatrix4(h.makeRotationAxis(a[n], r * n)), l[n].crossVectors(a[n], s[n]);
            return {
                tangents: a,
                normals: s,
                binormals: l
            }
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        },
        toJSON: function () {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
        },
        fromJSON: function (t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
    }), xs.prototype = Object.create(_s.prototype), xs.prototype.constructor = xs, xs.prototype.isEllipseCurve = !0, xs.prototype.getPoint = function (t, e) {
        for (var n = e || new _, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0;) r += i;
        for (; r > i;) r -= i;
        r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
        var a = this.aStartAngle + t * r,
            s = this.aX + this.xRadius * Math.cos(a),
            l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var c = Math.cos(this.aRotation),
                h = Math.sin(this.aRotation),
                u = s - this.aX,
                d = l - this.aY;
            s = u * c - d * h + this.aX, l = u * h + d * c + this.aY
        }
        return n.set(s, l)
    }, xs.prototype.copy = function (t) {
        return _s.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, xs.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }, xs.prototype.fromJSON = function (t) {
        return _s.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, bs.prototype = Object.create(xs.prototype), bs.prototype.constructor = bs, bs.prototype.isArcCurve = !0;
    var Ms = new P,
        Ss = new ws,
        Ts = new ws,
        Es = new ws;

    function As(t, e, n, i) {
        _s.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = i || .5
    }

    function Cs(t, e, n, i, r) {
        var o = .5 * (i - e),
            a = .5 * (r - n),
            s = t * t;
        return (2 * n - 2 * i + o + a) * (t * s) + (-3 * n + 3 * i - 2 * o - a) * s + o * t + n
    }

    function Ls(t, e, n, i) {
        return function (t, e) {
            var n = 1 - t;
            return n * n * e
        }(t, e) + function (t, e) {
            return 2 * (1 - t) * t * e
        }(t, n) + function (t, e) {
            return t * t * e
        }(t, i)
    }

    function Ps(t, e, n, i, r) {
        return function (t, e) {
            var n = 1 - t;
            return n * n * n * e
        }(t, e) + function (t, e) {
            var n = 1 - t;
            return 3 * n * n * t * e
        }(t, n) + function (t, e) {
            return 3 * (1 - t) * t * t * e
        }(t, i) + function (t, e) {
            return t * t * t * e
        }(t, r)
    }

    function Rs(t, e, n, i) {
        _s.call(this), this.type = "CubicBezierCurve", this.v0 = t || new _, this.v1 = e || new _, this.v2 = n || new _, this.v3 = i || new _
    }

    function Os(t, e, n, i) {
        _s.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new P, this.v1 = e || new P, this.v2 = n || new P, this.v3 = i || new P
    }

    function Ds(t, e) {
        _s.call(this), this.type = "LineCurve", this.v1 = t || new _, this.v2 = e || new _
    }

    function Is(t, e) {
        _s.call(this), this.type = "LineCurve3", this.v1 = t || new P, this.v2 = e || new P
    }

    function Ns(t, e, n) {
        _s.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new _, this.v1 = e || new _, this.v2 = n || new _
    }

    function ks(t, e, n) {
        _s.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new P, this.v1 = e || new P, this.v2 = n || new P
    }

    function zs(t) {
        _s.call(this), this.type = "SplineCurve", this.points = t || []
    }
    As.prototype = Object.create(_s.prototype), As.prototype.constructor = As, As.prototype.isCatmullRomCurve3 = !0, As.prototype.getPoint = function (t, e) {
        var n, i, r, o, a = e || new P,
            s = this.points,
            l = s.length,
            c = (l - (this.closed ? 0 : 1)) * t,
            h = Math.floor(c),
            u = c - h;
        if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / l) + 1) * l : 0 === u && h === l - 1 && (h = l - 2, u = 1), this.closed || h > 0 ? n = s[(h - 1) % l] : (Ms.subVectors(s[0], s[1]).add(s[0]), n = Ms), i = s[h % l], r = s[(h + 1) % l], this.closed || h + 2 < l ? o = s[(h + 2) % l] : (Ms.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]), o = Ms), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var d = "chordal" === this.curveType ? .5 : .25,
                p = Math.pow(n.distanceToSquared(i), d),
                f = Math.pow(i.distanceToSquared(r), d),
                m = Math.pow(r.distanceToSquared(o), d);
            f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), Ss.initNonuniformCatmullRom(n.x, i.x, r.x, o.x, p, f, m), Ts.initNonuniformCatmullRom(n.y, i.y, r.y, o.y, p, f, m), Es.initNonuniformCatmullRom(n.z, i.z, r.z, o.z, p, f, m)
        } else "catmullrom" === this.curveType && (Ss.initCatmullRom(n.x, i.x, r.x, o.x, this.tension), Ts.initCatmullRom(n.y, i.y, r.y, o.y, this.tension), Es.initCatmullRom(n.z, i.z, r.z, o.z, this.tension));
        return a.set(Ss.calc(u), Ts.calc(u), Es.calc(u)), a
    }, As.prototype.copy = function (t) {
        _s.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push(i.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, As.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var i = this.points[e];
            t.points.push(i.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }, As.prototype.fromJSON = function (t) {
        _s.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push((new P).fromArray(i))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, Rs.prototype = Object.create(_s.prototype), Rs.prototype.constructor = Rs, Rs.prototype.isCubicBezierCurve = !0, Rs.prototype.getPoint = function (t, e) {
        var n = e || new _,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(Ps(t, i.x, r.x, o.x, a.x), Ps(t, i.y, r.y, o.y, a.y)), n
    }, Rs.prototype.copy = function (t) {
        return _s.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, Rs.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, Rs.prototype.fromJSON = function (t) {
        return _s.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, Os.prototype = Object.create(_s.prototype), Os.prototype.constructor = Os, Os.prototype.isCubicBezierCurve3 = !0, Os.prototype.getPoint = function (t, e) {
        var n = e || new P,
            i = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(Ps(t, i.x, r.x, o.x, a.x), Ps(t, i.y, r.y, o.y, a.y), Ps(t, i.z, r.z, o.z, a.z)), n
    }, Os.prototype.copy = function (t) {
        return _s.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, Os.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, Os.prototype.fromJSON = function (t) {
        return _s.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, Ds.prototype = Object.create(_s.prototype), Ds.prototype.constructor = Ds, Ds.prototype.isLineCurve = !0, Ds.prototype.getPoint = function (t, e) {
        var n = e || new _;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }, Ds.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e)
    }, Ds.prototype.getTangent = function (t, e) {
        return (e || new _).copy(this.v2).sub(this.v1).normalize()
    }, Ds.prototype.copy = function (t) {
        return _s.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Ds.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Ds.prototype.fromJSON = function (t) {
        return _s.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Is.prototype = Object.create(_s.prototype), Is.prototype.constructor = Is, Is.prototype.isLineCurve3 = !0, Is.prototype.getPoint = function (t, e) {
        var n = e || new P;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }, Is.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e)
    }, Is.prototype.copy = function (t) {
        return _s.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Is.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Is.prototype.fromJSON = function (t) {
        return _s.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Ns.prototype = Object.create(_s.prototype), Ns.prototype.constructor = Ns, Ns.prototype.isQuadraticBezierCurve = !0, Ns.prototype.getPoint = function (t, e) {
        var n = e || new _,
            i = this.v0,
            r = this.v1,
            o = this.v2;
        return n.set(Ls(t, i.x, r.x, o.x), Ls(t, i.y, r.y, o.y)), n
    }, Ns.prototype.copy = function (t) {
        return _s.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Ns.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Ns.prototype.fromJSON = function (t) {
        return _s.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, ks.prototype = Object.create(_s.prototype), ks.prototype.constructor = ks, ks.prototype.isQuadraticBezierCurve3 = !0, ks.prototype.getPoint = function (t, e) {
        var n = e || new P,
            i = this.v0,
            r = this.v1,
            o = this.v2;
        return n.set(Ls(t, i.x, r.x, o.x), Ls(t, i.y, r.y, o.y), Ls(t, i.z, r.z, o.z)), n
    }, ks.prototype.copy = function (t) {
        return _s.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, ks.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, ks.prototype.fromJSON = function (t) {
        return _s.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, zs.prototype = Object.create(_s.prototype), zs.prototype.constructor = zs, zs.prototype.isSplineCurve = !0, zs.prototype.getPoint = function (t, e) {
        var n = e || new _,
            i = this.points,
            r = (i.length - 1) * t,
            o = Math.floor(r),
            a = r - o,
            s = i[0 === o ? o : o - 1],
            l = i[o],
            c = i[o > i.length - 2 ? i.length - 1 : o + 1],
            h = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set(Cs(a, s.x, l.x, c.x, h.x), Cs(a, s.y, l.y, c.y, h.y)), n
    }, zs.prototype.copy = function (t) {
        _s.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push(i.clone())
        }
        return this
    }, zs.prototype.toJSON = function () {
        var t = _s.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var i = this.points[e];
            t.points.push(i.toArray())
        }
        return t
    }, zs.prototype.fromJSON = function (t) {
        _s.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push((new _).fromArray(i))
        }
        return this
    };
    var Bs = Object.freeze({
        __proto__: null,
        ArcCurve: bs,
        CatmullRomCurve3: As,
        CubicBezierCurve: Rs,
        CubicBezierCurve3: Os,
        EllipseCurve: xs,
        LineCurve: Ds,
        LineCurve3: Is,
        QuadraticBezierCurve: Ns,
        QuadraticBezierCurve3: ks,
        SplineCurve: zs
    });

    function Fs() {
        _s.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function Us(t) {
        Fs.call(this), this.type = "Path", this.currentPoint = new _, t && this.setFromPoints(t)
    }

    function Hs(t) {
        Us.call(this, t), this.uuid = y.generateUUID(), this.type = "Shape", this.holes = []
    }

    function Gs(t, e) {
        nt.call(this), this.type = "Light", this.color = new Xt(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
    }

    function Vs(t, e, n) {
        Gs.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(nt.DefaultUp), this.updateMatrix(), this.groundColor = new Xt(e)
    }

    function js(t) {
        this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new _(512, 512), this.map = null, this.mapPass = null, this.matrix = new B, this._frustum = new an, this._frameExtents = new _(1, 1), this._viewportCount = 1, this._viewports = [new S(0, 0, 1, 1)]
    }

    function Ws() {
        js.call(this, new $e(50, 1, .5, 500))
    }

    function qs(t, e, n, i, r, o) {
        Gs.call(this, t, e), this.type = "SpotLight", this.position.copy(nt.DefaultUp), this.updateMatrix(), this.target = new nt, Object.defineProperty(this, "power", {
            get: function () {
                return this.intensity * Math.PI
            },
            set: function (t) {
                this.intensity = t / Math.PI
            }
        }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Ws
    }

    function Xs() {
        js.call(this, new $e(90, 1, .5, 500)), this._frameExtents = new _(4, 2), this._viewportCount = 6, this._viewports = [new S(2, 1, 1, 1), new S(0, 1, 1, 1), new S(3, 1, 1, 1), new S(1, 1, 1, 1), new S(3, 0, 1, 1), new S(1, 0, 1, 1)], this._cubeDirections = [new P(1, 0, 0), new P(-1, 0, 0), new P(0, 0, 1), new P(0, 0, -1), new P(0, 1, 0), new P(0, -1, 0)], this._cubeUps = [new P(0, 1, 0), new P(0, 1, 0), new P(0, 1, 0), new P(0, 1, 0), new P(0, 0, 1), new P(0, 0, -1)]
    }

    function Ys(t, e, n, i) {
        Gs.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function () {
                return 4 * this.intensity * Math.PI
            },
            set: function (t) {
                this.intensity = t / (4 * Math.PI)
            }
        }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Xs
    }

    function Js(t, e, n, i, r, o) {
        Ke.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function Zs() {
        js.call(this, new Js(-5, 5, 5, -5, .5, 500))
    }

    function Qs(t, e) {
        Gs.call(this, t, e), this.type = "DirectionalLight", this.position.copy(nt.DefaultUp), this.updateMatrix(), this.target = new nt, this.shadow = new Zs
    }

    function Ks(t, e) {
        Gs.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
    }

    function $s(t, e, n, i) {
        Gs.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
    }

    function tl() {
        this.coefficients = [];
        for (var t = 0; t < 9; t++) this.coefficients.push(new P)
    }

    function el(t, e) {
        Gs.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new tl
    }

    function nl(t) {
        hs.call(this, t), this.textures = {}
    }
    Fs.prototype = Object.assign(Object.create(_s.prototype), {
        constructor: Fs,
        add: function (t) {
            this.curves.push(t)
        },
        closePath: function () {
            var t = this.curves[0].getPoint(0),
                e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new Ds(e, t))
        },
        getPoint: function (t) {
            for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                if (n[i] >= e) {
                    var r = n[i] - e,
                        o = this.curves[i],
                        a = o.getLength(),
                        s = 0 === a ? 0 : 1 - r / a;
                    return o.getPointAt(s)
                }
                i++
            }
            return null
        },
        getLength: function () {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function () {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
            return this.cacheLengths = t, t
        },
        getSpacedPoints: function (t) {
            void 0 === t && (t = 40);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]), e
        },
        getPoints: function (t) {
            t = t || 12;
            for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
                for (var o = r[i], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), l = 0; l < s.length; l++) {
                    var c = s[l];
                    e && e.equals(c) || (n.push(c), e = c)
                }
            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
        },
        copy: function (t) {
            _s.prototype.copy.call(this, t), this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var i = t.curves[e];
                this.curves.push(i.clone())
            }
            return this.autoClose = t.autoClose, this
        },
        toJSON: function () {
            var t = _s.prototype.toJSON.call(this);
            t.autoClose = this.autoClose, t.curves = [];
            for (var e = 0, n = this.curves.length; e < n; e++) {
                var i = this.curves[e];
                t.curves.push(i.toJSON())
            }
            return t
        },
        fromJSON: function (t) {
            _s.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var i = t.curves[e];
                this.curves.push((new Bs[i.type]).fromJSON(i))
            }
            return this
        }
    }), Us.prototype = Object.assign(Object.create(Fs.prototype), {
        constructor: Us,
        setFromPoints: function (t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
            return this
        },
        moveTo: function (t, e) {
            return this.currentPoint.set(t, e), this
        },
        lineTo: function (t, e) {
            var n = new Ds(this.currentPoint.clone(), new _(t, e));
            return this.curves.push(n), this.currentPoint.set(t, e), this
        },
        quadraticCurveTo: function (t, e, n, i) {
            var r = new Ns(this.currentPoint.clone(), new _(t, e), new _(n, i));
            return this.curves.push(r), this.currentPoint.set(n, i), this
        },
        bezierCurveTo: function (t, e, n, i, r, o) {
            var a = new Rs(this.currentPoint.clone(), new _(t, e), new _(n, i), new _(r, o));
            return this.curves.push(a), this.currentPoint.set(r, o), this
        },
        splineThru: function (t) {
            var e = new zs([this.currentPoint.clone()].concat(t));
            return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
        },
        arc: function (t, e, n, i, r, o) {
            var a = this.currentPoint.x,
                s = this.currentPoint.y;
            return this.absarc(t + a, e + s, n, i, r, o), this
        },
        absarc: function (t, e, n, i, r, o) {
            return this.absellipse(t, e, n, n, i, r, o), this
        },
        ellipse: function (t, e, n, i, r, o, a, s) {
            var l = this.currentPoint.x,
                c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, n, i, r, o, a, s), this
        },
        absellipse: function (t, e, n, i, r, o, a, s) {
            var l = new xs(t, e, n, i, r, o, a, s);
            if (this.curves.length > 0) {
                var c = l.getPoint(0);
                c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
            }
            this.curves.push(l);
            var h = l.getPoint(1);
            return this.currentPoint.copy(h), this
        },
        copy: function (t) {
            return Fs.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
        },
        toJSON: function () {
            var t = Fs.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(), t
        },
        fromJSON: function (t) {
            return Fs.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
        }
    }), Hs.prototype = Object.assign(Object.create(Us.prototype), {
        constructor: Hs,
        getPointsHoles: function (t) {
            for (var e = [], n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
            return e
        },
        extractPoints: function (t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function (t) {
            Us.prototype.copy.call(this, t), this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var i = t.holes[e];
                this.holes.push(i.clone())
            }
            return this
        },
        toJSON: function () {
            var t = Us.prototype.toJSON.call(this);
            t.uuid = this.uuid, t.holes = [];
            for (var e = 0, n = this.holes.length; e < n; e++) {
                var i = this.holes[e];
                t.holes.push(i.toJSON())
            }
            return t
        },
        fromJSON: function (t) {
            Us.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var i = t.holes[e];
                this.holes.push((new Us).fromJSON(i))
            }
            return this
        }
    }), Gs.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: Gs,
        isLight: !0,
        copy: function (t) {
            return nt.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
        },
        toJSON: function (t) {
            var e = nt.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), Vs.prototype = Object.assign(Object.create(Gs.prototype), {
        constructor: Vs,
        isHemisphereLight: !0,
        copy: function (t) {
            return Gs.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
        }
    }), Object.assign(js.prototype, {
        _projScreenMatrix: new B,
        _lightPositionWorld: new P,
        _lookTarget: new P,
        getViewportCount: function () {
            return this._viewportCount
        },
        getFrustum: function () {
            return this._frustum
        },
        updateMatrices: function (t) {
            var e = this.camera,
                n = this.matrix,
                i = this._projScreenMatrix,
                r = this._lookTarget,
                o = this._lightPositionWorld;
            o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
        },
        getViewport: function (t) {
            return this._viewports[t]
        },
        getFrameExtents: function () {
            return this._frameExtents
        },
        copy: function (t) {
            return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        toJSON: function () {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
        }
    }), Ws.prototype = Object.assign(Object.create(js.prototype), {
        constructor: Ws,
        isSpotLightShadow: !0,
        updateMatrices: function (t) {
            var e = this.camera,
                n = 2 * y.RAD2DEG * t.angle,
                i = this.mapSize.width / this.mapSize.height,
                r = t.distance || e.far;
            n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), js.prototype.updateMatrices.call(this, t)
        }
    }), qs.prototype = Object.assign(Object.create(Gs.prototype), {
        constructor: qs,
        isSpotLight: !0,
        copy: function (t) {
            return Gs.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), Xs.prototype = Object.assign(Object.create(js.prototype), {
        constructor: Xs,
        isPointLightShadow: !0,
        updateMatrices: function (t, e) {
            void 0 === e && (e = 0);
            var n = this.camera,
                i = this.matrix,
                r = this._lightPositionWorld,
                o = this._lookTarget,
                a = this._projScreenMatrix;
            r.setFromMatrixPosition(t.matrixWorld), n.position.copy(r), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(a)
        }
    }), Ys.prototype = Object.assign(Object.create(Gs.prototype), {
        constructor: Ys,
        isPointLight: !0,
        copy: function (t) {
            return Gs.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
        }
    }), Js.prototype = Object.assign(Object.create(Ke.prototype), {
        constructor: Js,
        isOrthographicCamera: !0,
        copy: function (t, e) {
            return Ke.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
        },
        setViewOffset: function (t, e, n, i, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2,
                r = n - t,
                o = n + t,
                a = i + e,
                s = i - e;
            if (null !== this.view && this.view.enabled) {
                var l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                o = (r += l * this.view.offsetX) + l * this.view.width, s = (a -= c * this.view.offsetY) - c * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function (t) {
            var e = nt.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), Zs.prototype = Object.assign(Object.create(js.prototype), {
        constructor: Zs,
        isDirectionalLightShadow: !0,
        updateMatrices: function (t) {
            js.prototype.updateMatrices.call(this, t)
        }
    }), Qs.prototype = Object.assign(Object.create(Gs.prototype), {
        constructor: Qs,
        isDirectionalLight: !0,
        copy: function (t) {
            return Gs.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), Ks.prototype = Object.assign(Object.create(Gs.prototype), {
        constructor: Ks,
        isAmbientLight: !0
    }), $s.prototype = Object.assign(Object.create(Gs.prototype), {
        constructor: $s,
        isRectAreaLight: !0,
        copy: function (t) {
            return Gs.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
        },
        toJSON: function (t) {
            var e = Gs.prototype.toJSON.call(this, t);
            return e.object.width = this.width, e.object.height = this.height, e
        }
    }), Object.assign(tl.prototype, {
        isSphericalHarmonics3: !0,
        set: function (t) {
            for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
            return this
        },
        zero: function () {
            for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
            return this
        },
        getAt: function (t, e) {
            var n = t.x,
                i = t.y,
                r = t.z,
                o = this.coefficients;
            return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * i), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * i * 1.092548), e.addScaledVector(o[5], i * r * 1.092548), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], n * r * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - i * i)), e
        },
        getIrradianceAt: function (t, e) {
            var n = t.x,
                i = t.y,
                r = t.z,
                o = this.coefficients;
            return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * i), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * i), e.addScaledVector(o[5], .858086 * i * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], .858086 * n * r), e.addScaledVector(o[8], .429043 * (n * n - i * i)), e
        },
        add: function (t) {
            for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
            return this
        },
        addScaledSH: function (t, e) {
            for (var n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this
        },
        scale: function (t) {
            for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
            return this
        },
        lerp: function (t, e) {
            for (var n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
            return this
        },
        equals: function (t) {
            for (var e = 0; e < 9; e++)
                if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
            return !0
        },
        copy: function (t) {
            return this.set(t.coefficients)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var n = this.coefficients, i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
            return this
        },
        toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            for (var n = this.coefficients, i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
            return t
        }
    }), Object.assign(tl, {
        getBasisAt: function (t, e) {
            var n = t.x,
                i = t.y,
                r = t.z;
            e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
        }
    }), el.prototype = Object.assign(Object.create(Gs.prototype), {
        constructor: el,
        isLightProbe: !0,
        copy: function (t) {
            return Gs.prototype.copy.call(this, t), this.sh.copy(t.sh), this
        },
        fromJSON: function (t) {
            return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
        },
        toJSON: function (t) {
            var e = Gs.prototype.toJSON.call(this, t);
            return e.object.sh = this.sh.toArray(), e
        }
    }), nl.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: nl,
        load: function (t, e, n, i) {
            var r = this,
                o = new ds(r.manager);
            o.setPath(r.path), o.load(t, (function (t) {
                e(r.parse(JSON.parse(t)))
            }), n, i)
        },
        parse: function (t) {
            var e = this.textures;

            function n(t) {
                return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
            }
            var i = new Wa[t.type];
            if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new Xt).setHex(t.sheen)), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                for (var r in t.uniforms) {
                    var o = t.uniforms[r];
                    switch (i.uniforms[r] = {}, o.type) {
                        case "t":
                            i.uniforms[r].value = n(o.value);
                            break;
                        case "c":
                            i.uniforms[r].value = (new Xt).setHex(o.value);
                            break;
                        case "v2":
                            i.uniforms[r].value = (new _).fromArray(o.value);
                            break;
                        case "v3":
                            i.uniforms[r].value = (new P).fromArray(o.value);
                            break;
                        case "v4":
                            i.uniforms[r].value = (new S).fromArray(o.value);
                            break;
                        case "m3":
                            i.uniforms[r].value = (new x).fromArray(o.value);
                        case "m4":
                            i.uniforms[r].value = (new B).fromArray(o.value);
                            break;
                        default:
                            i.uniforms[r].value = o.value
                    }
                }
            if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                for (var a in t.extensions) i.extensions[a] = t.extensions[a];
            if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                var s = t.normalScale;
                !1 === Array.isArray(s) && (s = [s, s]), i.normalScale = (new _).fromArray(s)
            }
            return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new _).fromArray(t.clearcoatNormalScale)), i
        },
        setTextures: function (t) {
            return this.textures = t, this
        }
    });
    var il = function (t) {
        var e = t.lastIndexOf("/");
        return -1 === e ? "./" : t.substr(0, e + 1)
    };

    function rl() {
        be.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function ol(t, e, n, i) {
        "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), ne.call(this, t, e, n), this.meshPerAttribute = i || 1
    }

    function al(t) {
        hs.call(this, t)
    }
    rl.prototype = Object.assign(Object.create(be.prototype), {
        constructor: rl,
        isInstancedBufferGeometry: !0,
        copy: function (t) {
            return be.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        toJSON: function () {
            var t = be.prototype.toJSON.call(this);
            return t.maxInstancedCount = this.maxInstancedCount, t.isInstancedBufferGeometry = !0, t
        }
    }), ol.prototype = Object.assign(Object.create(ne.prototype), {
        constructor: ol,
        isInstancedBufferAttribute: !0,
        copy: function (t) {
            return ne.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        },
        toJSON: function () {
            var t = ne.prototype.toJSON.call(this);
            return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
        }
    }), al.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: al,
        load: function (t, e, n, i) {
            var r = this,
                o = new ds(r.manager);
            o.setPath(r.path), o.load(t, (function (t) {
                e(r.parse(JSON.parse(t)))
            }), n, i)
        },
        parse: function (t) {
            var e = t.isInstancedBufferGeometry ? new rl : new be,
                n = t.data.index;
            if (void 0 !== n) {
                var i = new sl[n.type](n.array);
                e.setIndex(new ne(i, 1))
            }
            var r = t.data.attributes;
            for (var o in r) {
                var a = r[o],
                    s = (i = new sl[a.type](a.array), new(a.isInstancedBufferAttribute ? ol : ne)(i, a.itemSize, a.normalized));
                void 0 !== a.name && (s.name = a.name), e.setAttribute(o, s)
            }
            var l = t.data.morphAttributes;
            if (l)
                for (var o in l) {
                    for (var c = l[o], h = [], u = 0, d = c.length; u < d; u++) {
                        a = c[u], s = new ne(i = new sl[a.type](a.array), a.itemSize, a.normalized);
                        void 0 !== a.name && (s.name = a.name), h.push(s)
                    }
                    e.morphAttributes[o] = h
                }
            t.data.morphTargetsRelative && (e.morphTargetsRelative = !0);
            var p = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== p) {
                u = 0;
                for (var f = p.length; u !== f; ++u) {
                    var m = p[u];
                    e.addGroup(m.start, m.count, m.materialIndex)
                }
            }
            var v = t.data.boundingSphere;
            if (void 0 !== v) {
                var g = new P;
                void 0 !== v.center && g.fromArray(v.center), e.boundingSphere = new xt(g, v.radius)
            }
            return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
        }
    });
    var sl = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function ll(t) {
        hs.call(this, t)
    }
    ll.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: ll,
        load: function (t, e, n, i) {
            var r = this,
                o = "" === this.path ? il(t) : this.path;
            this.resourcePath = this.resourcePath || o;
            var a = new ds(r.manager);
            a.setPath(this.path), a.load(t, (function (n) {
                var o = null;
                try {
                    o = JSON.parse(n)
                } catch (e) {
                    return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                }
                var a = o.metadata;
                void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t)
            }), n, i)
        },
        parse: function (t, e) {
            var n = this.parseShape(t.shapes),
                i = this.parseGeometries(t.geometries, n),
                r = this.parseImages(t.images, (function () {
                    void 0 !== e && e(s)
                })),
                o = this.parseTextures(t.textures, r),
                a = this.parseMaterials(t.materials, o),
                s = this.parseObject(t.object, i, a);
            return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
        },
        parseShape: function (t) {
            var e = {};
            if (void 0 !== t)
                for (var n = 0, i = t.length; n < i; n++) {
                    var r = (new Hs).fromJSON(t[n]);
                    e[r.uuid] = r
                }
            return e
        },
        parseGeometries: function (t, e) {
            var n = {};
            if (void 0 !== t)
                for (var i = new al, r = 0, o = t.length; r < o; r++) {
                    var a, s = t[r];
                    switch (s.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            a = new Ia[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            a = new Ia[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            a = new Ia[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            a = new Ia[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            a = new Ia[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            a = new Ia[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            a = new Ia[s.type](s.radius, s.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            a = new Ia[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            a = new Ia[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            a = new Ia[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                            break;
                        case "TubeGeometry":
                        case "TubeBufferGeometry":
                            a = new Ia[s.type]((new Bs[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            a = new Ia[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            a = new Ia[s.type](s.vertices, s.indices, s.radius, s.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            for (var l = [], c = 0, h = s.shapes.length; c < h; c++) {
                                var u = e[s.shapes[c]];
                                l.push(u)
                            }
                            a = new Ia[s.type](l, s.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            for (l = [], c = 0, h = s.shapes.length; c < h; c++) {
                                u = e[s.shapes[c]];
                                l.push(u)
                            }
                            var d = s.options.extrudePath;
                            void 0 !== d && (s.options.extrudePath = (new Bs[d.type]).fromJSON(d)), a = new Ia[s.type](l, s.options);
                            break;
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            a = i.parse(s);
                            break;
                        case "Geometry":
                            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                            continue
                    }
                    a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), n[s.uuid] = a
                }
            return n
        },
        parseMaterials: function (t, e) {
            var n = {},
                i = {};
            if (void 0 !== t) {
                var r = new nl;
                r.setTextures(e);
                for (var o = 0, a = t.length; o < a; o++) {
                    var s = t[o];
                    if ("MultiMaterial" === s.type) {
                        for (var l = [], c = 0; c < s.materials.length; c++) {
                            var h = s.materials[c];
                            void 0 === n[h.uuid] && (n[h.uuid] = r.parse(h)), l.push(n[h.uuid])
                        }
                        i[s.uuid] = l
                    } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), i[s.uuid] = n[s.uuid]
                }
            }
            return i
        },
        parseAnimations: function (t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var i = t[n],
                    r = os.parse(i);
                void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r)
            }
            return e
        },
        parseImages: function (t, e) {
            var n = this,
                i = {};

            function r(t) {
                return n.manager.itemStart(t), o.load(t, (function () {
                    n.manager.itemEnd(t)
                }), void 0, (function () {
                    n.manager.itemError(t), n.manager.itemEnd(t)
                }))
            }
            if (void 0 !== t && t.length > 0) {
                var o = new vs(new ls(e));
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = t.length; a < s; a++) {
                    var l = t[a],
                        c = l.url;
                    if (Array.isArray(c)) {
                        i[l.uuid] = [];
                        for (var h = 0, u = c.length; h < u; h++) {
                            var d = c[h],
                                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
                            i[l.uuid].push(r(p))
                        }
                    } else {
                        p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.resourcePath + l.url;
                        i[l.uuid] = r(p)
                    }
                }
            }
            return i
        },
        parseTextures: function (t, e) {
            function n(t, e) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
            }
            var i = {};
            if (void 0 !== t)
                for (var r = 0, o = t.length; r < o; r++) {
                    var a, s = t[r];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(e[s.image]) ? new Tn(e[s.image]) : new M(e[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, hl)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], ul), a.wrapT = n(s.wrap[1], ul)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, dl)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, dl)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), i[s.uuid] = a
                }
            return i
        },
        parseObject: function (t, e, n) {
            var i;

            function r(t) {
                return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
            }

            function o(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], i = 0, r = t.length; i < r; i++) {
                            var o = t[i];
                            void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(n[o])
                        }
                        return e
                    }
                    return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                }
            }
            switch (t.type) {
                case "Scene":
                    i = new it, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new Xt(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new dr(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new ur(t.fog.color, t.fog.density)));
                    break;
                case "PerspectiveCamera":
                    i = new $e(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                    break;
                case "OrthographicCamera":
                    i = new Js(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view));
                    break;
                case "AmbientLight":
                    i = new Ks(t.color, t.intensity);
                    break;
                case "DirectionalLight":
                    i = new Qs(t.color, t.intensity);
                    break;
                case "PointLight":
                    i = new Ys(t.color, t.intensity, t.distance, t.decay);
                    break;
                case "RectAreaLight":
                    i = new $s(t.color, t.intensity, t.width, t.height);
                    break;
                case "SpotLight":
                    i = new qs(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                    break;
                case "HemisphereLight":
                    i = new Vs(t.color, t.groundColor, t.intensity);
                    break;
                case "LightProbe":
                    i = (new el).fromJSON(t);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    i = new Fe(a = r(t.geometry), s = o(t.material));
                    break;
                case "InstancedMesh":
                    var a = r(t.geometry),
                        s = o(t.material),
                        l = t.count,
                        c = t.instanceMatrix;
                    (i = new Jr(a, s, l)).instanceMatrix = new ne(new Float32Array(c.array), 16);
                    break;
                case "LOD":
                    i = new Fr;
                    break;
                case "Line":
                    i = new no(r(t.geometry), o(t.material), t.mode);
                    break;
                case "LineLoop":
                    i = new ao(r(t.geometry), o(t.material));
                    break;
                case "LineSegments":
                    i = new oo(r(t.geometry), o(t.material));
                    break;
                case "PointCloud":
                case "Points":
                    i = new po(r(t.geometry), o(t.material));
                    break;
                case "Sprite":
                    i = new Pr(o(t.material));
                    break;
                case "Group":
                    i = new sr;
                    break;
                default:
                    i = new nt
            }
            if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children)
                for (var h = t.children, u = 0; u < h.length; u++) i.add(this.parseObject(h[u], e, n));
            if ("LOD" === t.type) {
                void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
                for (var d = t.levels, p = 0; p < d.length; p++) {
                    var f = d[p],
                        m = i.getObjectByProperty("uuid", f.object);
                    void 0 !== m && i.addLevel(m, f.distance)
                }
            }
            return i
        }
    });
    var cl, hl = {
            UVMapping: 300,
            CubeReflectionMapping: 301,
            CubeRefractionMapping: 302,
            EquirectangularReflectionMapping: 303,
            EquirectangularRefractionMapping: 304,
            SphericalReflectionMapping: 305,
            CubeUVReflectionMapping: 306,
            CubeUVRefractionMapping: 307
        },
        ul = {
            RepeatWrapping: 1e3,
            ClampToEdgeWrapping: 1001,
            MirroredRepeatWrapping: 1002
        },
        dl = {
            NearestFilter: 1003,
            NearestMipmapNearestFilter: 1004,
            NearestMipmapLinearFilter: 1005,
            LinearFilter: 1006,
            LinearMipmapNearestFilter: 1007,
            LinearMipmapLinearFilter: 1008
        };

    function pl(t) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), hs.call(this, t), this.options = void 0
    }

    function fl() {
        this.type = "ShapePath", this.color = new Xt, this.subPaths = [], this.currentPath = null
    }

    function ml(t) {
        this.type = "Font", this.data = t
    }

    function vl(t, e, n, i, r) {
        var o = r.glyphs[t] || r.glyphs["?"];
        if (o) {
            var a, s, l, c, h, u, d, p, f = new fl;
            if (o.o)
                for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g;) {
                    switch (m[v++]) {
                        case "m":
                            a = m[v++] * e + n, s = m[v++] * e + i, f.moveTo(a, s);
                            break;
                        case "l":
                            a = m[v++] * e + n, s = m[v++] * e + i, f.lineTo(a, s);
                            break;
                        case "q":
                            l = m[v++] * e + n, c = m[v++] * e + i, h = m[v++] * e + n, u = m[v++] * e + i, f.quadraticCurveTo(h, u, l, c);
                            break;
                        case "b":
                            l = m[v++] * e + n, c = m[v++] * e + i, h = m[v++] * e + n, u = m[v++] * e + i, d = m[v++] * e + n, p = m[v++] * e + i, f.bezierCurveTo(h, u, d, p, l, c)
                    }
                }
            return {
                offsetX: o.ha * e,
                path: f
            }
        }
        console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".")
    }

    function gl(t) {
        hs.call(this, t)
    }
    pl.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: pl,
        setOptions: function (t) {
            return this.options = t, this
        },
        load: function (t, e, n, i) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var r = this,
                o = ss.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () {
                e && e(o), r.manager.itemEnd(t)
            }), 0), o;
            fetch(t).then((function (t) {
                return t.blob()
            })).then((function (t) {
                return void 0 === r.options ? createImageBitmap(t) : createImageBitmap(t, r.options)
            })).then((function (n) {
                ss.add(t, n), e && e(n), r.manager.itemEnd(t)
            })).catch((function (e) {
                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
            })), r.manager.itemStart(t)
        }
    }), Object.assign(fl.prototype, {
        moveTo: function (t, e) {
            return this.currentPath = new Us, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
        },
        lineTo: function (t, e) {
            return this.currentPath.lineTo(t, e), this
        },
        quadraticCurveTo: function (t, e, n, i) {
            return this.currentPath.quadraticCurveTo(t, e, n, i), this
        },
        bezierCurveTo: function (t, e, n, i, r, o) {
            return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this
        },
        splineThru: function (t) {
            return this.currentPath.splineThru(t), this
        },
        toShapes: function (t, e) {
            function n(t) {
                for (var e = [], n = 0, i = t.length; n < i; n++) {
                    var r = t[n],
                        o = new Hs;
                    o.curves = r.curves, e.push(o)
                }
                return e
            }

            function i(t, e) {
                for (var n = e.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
                    var a = e[r],
                        s = e[o],
                        l = s.x - a.x,
                        c = s.y - a.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (c < 0 && (a = e[o], l = -l, s = e[r], c = -c), t.y < a.y || t.y > s.y) continue;
                        if (t.y === a.y) {
                            if (t.x === a.x) return !0
                        } else {
                            var h = c * (t.x - a.x) - l * (t.y - a.y);
                            if (0 === h) return !0;
                            if (h < 0) continue;
                            i = !i
                        }
                    } else {
                        if (t.y !== a.y) continue;
                        if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                    }
                }
                return i
            }
            var r = ca.isClockWise,
                o = this.subPaths;
            if (0 === o.length) return [];
            if (!0 === e) return n(o);
            var a, s, l, c = [];
            if (1 === o.length) return s = o[0], (l = new Hs).curves = s.curves, c.push(l), c;
            var h = !r(o[0].getPoints());
            h = t ? !h : h;
            var u, d, p = [],
                f = [],
                m = [],
                v = 0;
            f[v] = void 0, m[v] = [];
            for (var g = 0, y = o.length; g < y; g++) a = r(u = (s = o[g]).getPoints()), (a = t ? !a : a) ? (!h && f[v] && v++, f[v] = {
                s: new Hs,
                p: u
            }, f[v].s.curves = s.curves, h && v++, m[v] = []) : m[v].push({
                h: s,
                p: u[0]
            });
            if (!f[0]) return n(o);
            if (f.length > 1) {
                for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) p[b] = [];
                for (b = 0, w = f.length; b < w; b++)
                    for (var M = m[b], S = 0; S < M.length; S++) {
                        for (var T = M[S], E = !0, A = 0; A < f.length; A++) i(T.p, f[A].p) && (b !== A && x.push({
                            froms: b,
                            tos: A,
                            hole: S
                        }), E ? (E = !1, p[A].push(T)) : _ = !0);
                        E && p[b].push(T)
                    }
                x.length > 0 && (_ || (m = p))
            }
            g = 0;
            for (var C = f.length; g < C; g++) {
                l = f[g].s, c.push(l);
                for (var L = 0, P = (d = m[g]).length; L < P; L++) l.holes.push(d[L].h)
            }
            return c
        }
    }), Object.assign(ml.prototype, {
        isFont: !0,
        generateShapes: function (t, e) {
            void 0 === e && (e = 100);
            for (var n = [], i = function (t, e, n) {
                    for (var i = Array.from ? Array.from(t) : String(t).split(""), r = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, a = [], s = 0, l = 0, c = 0; c < i.length; c++) {
                        var h = i[c];
                        if ("\n" === h) s = 0, l -= o;
                        else {
                            var u = vl(h, r, s, l, n);
                            s += u.offsetX, a.push(u.path)
                        }
                    }
                    return a
                }(t, e, this.data), r = 0, o = i.length; r < o; r++) Array.prototype.push.apply(n, i[r].toShapes());
            return n
        }
    }), gl.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: gl,
        load: function (t, e, n, i) {
            var r = this,
                o = new ds(this.manager);
            o.setPath(this.path), o.load(t, (function (t) {
                var n;
                try {
                    n = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                }
                var i = r.parse(n);
                e && e(i)
            }), n, i)
        },
        parse: function (t) {
            return new ml(t)
        }
    });
    var yl = function () {
        return void 0 === cl && (cl = new(window.AudioContext || window.webkitAudioContext)), cl
    };

    function _l(t) {
        hs.call(this, t)
    }

    function xl(t, e, n) {
        el.call(this, void 0, n);
        var i = (new Xt).set(t),
            r = (new Xt).set(e),
            o = new P(i.r, i.g, i.b),
            a = new P(r.r, r.g, r.b),
            s = Math.sqrt(Math.PI),
            l = s * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(l)
    }

    function bl(t, e) {
        el.call(this, void 0, e);
        var n = (new Xt).set(t);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    _l.prototype = Object.assign(Object.create(hs.prototype), {
        constructor: _l,
        load: function (t, e, n, i) {
            var r = new ds(this.manager);
            r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, (function (t) {
                var n = t.slice(0);
                yl().decodeAudioData(n, (function (t) {
                    e(t)
                }))
            }), n, i)
        }
    }), xl.prototype = Object.assign(Object.create(el.prototype), {
        constructor: xl,
        isHemisphereLightProbe: !0,
        copy: function (t) {
            return el.prototype.copy.call(this, t), this
        },
        toJSON: function (t) {
            return el.prototype.toJSON.call(this, t)
        }
    }), bl.prototype = Object.assign(Object.create(el.prototype), {
        constructor: bl,
        isAmbientLightProbe: !0,
        copy: function (t) {
            return el.prototype.copy.call(this, t), this
        },
        toJSON: function (t) {
            return el.prototype.toJSON.call(this, t)
        }
    });
    var wl = new B,
        Ml = new B;

    function Sl(t) {
        this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    Object.assign(function () {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new $e, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new $e, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }.prototype, {
        update: function (t) {
            var e = this._cache;
            if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                var n, i, r = t.projectionMatrix.clone(),
                    o = e.eyeSep / 2,
                    a = o * e.near / e.focus,
                    s = e.near * Math.tan(y.DEG2RAD * e.fov * .5) / e.zoom;
                Ml.elements[12] = -o, wl.elements[12] = o, n = -s * e.aspect + a, i = s * e.aspect + a, r.elements[0] = 2 * e.near / (i - n), r.elements[8] = (i + n) / (i - n), this.cameraL.projectionMatrix.copy(r), n = -s * e.aspect - a, i = s * e.aspect - a, r.elements[0] = 2 * e.near / (i - n), r.elements[8] = (i + n) / (i - n), this.cameraR.projectionMatrix.copy(r)
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Ml), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(wl)
        }
    }), Object.assign(Sl.prototype, {
        start: function () {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
        },
        stop: function () {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1
        },
        getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function () {
            var t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var e = ("undefined" == typeof performance ? Date : performance).now();
                t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
            }
            return t
        }
    });
    var Tl = new P,
        El = new A,
        Al = new P,
        Cl = new P;

    function Ll() {
        nt.call(this), this.type = "AudioListener", this.context = yl(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Sl
    }

    function Pl(t) {
        nt.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this.filters = []
    }
    Ll.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: Ll,
        getInput: function () {
            return this.gain
        },
        removeFilter: function () {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        },
        getFilter: function () {
            return this.filter
        },
        setFilter: function (t) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        },
        getMasterVolume: function () {
            return this.gain.gain.value
        },
        setMasterVolume: function (t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
        },
        updateMatrixWorld: function (t) {
            nt.prototype.updateMatrixWorld.call(this, t);
            var e = this.context.listener,
                n = this.up;
            if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Tl, El, Al), Cl.set(0, 0, -1).applyQuaternion(El), e.positionX) {
                var i = this.context.currentTime + this.timeDelta;
                e.positionX.linearRampToValueAtTime(Tl.x, i), e.positionY.linearRampToValueAtTime(Tl.y, i), e.positionZ.linearRampToValueAtTime(Tl.z, i), e.forwardX.linearRampToValueAtTime(Cl.x, i), e.forwardY.linearRampToValueAtTime(Cl.y, i), e.forwardZ.linearRampToValueAtTime(Cl.z, i), e.upX.linearRampToValueAtTime(n.x, i), e.upY.linearRampToValueAtTime(n.y, i), e.upZ.linearRampToValueAtTime(n.z, i)
            } else e.setPosition(Tl.x, Tl.y, Tl.z), e.setOrientation(Cl.x, Cl.y, Cl.z, n.x, n.y, n.z)
        }
    }), Pl.prototype = Object.assign(Object.create(nt.prototype), {
        constructor: Pl,
        getOutput: function () {
            return this.gain
        },
        setNodeSource: function (t) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
        },
        setMediaElementSource: function (t) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
        },
        setMediaStreamSource: function (t) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
        },
        setBuffer: function (t) {
            return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function (t) {
            if (void 0 === t && (t = 0), !0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    this._startedAt = this.context.currentTime + t;
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else console.warn("THREE.Audio: Audio is already playing.")
        },
        pause: function () {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function () {
            if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function () {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function () {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function () {
            return this.filters
        },
        setFilters: function (t) {
            return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
        },
        setDetune: function (t) {
            if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        },
        getDetune: function () {
            return this.detune
        },
        getFilter: function () {
            return this.getFilters()[0]
        },
        setFilter: function (t) {
            return this.setFilters(t ? [t] : [])
        },
        setPlaybackRate: function (t) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function () {
            return this.playbackRate
        },
        onEnded: function () {
            this.isPlaying = !1
        },
        getLoop: function () {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function (t) {
            if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        setLoopStart: function (t) {
            return this.loopStart = t, this
        },
        setLoopEnd: function (t) {
            return this.loopEnd = t, this
        },
        getVolume: function () {
            return this.gain.gain.value
        },
        setVolume: function (t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
        }
    });
    var Rl = new P,
        Ol = new A,
        Dl = new P,
        Il = new P;

    function Nl(t) {
        Pl.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }

    function kl(t, e) {
        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
    }

    function zl(t, e, n) {
        var i, r, o;
        switch (this.binding = t, this.valueSize = n, e) {
            case "quaternion":
                i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                break;
            default:
                i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
        }
        this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    Nl.prototype = Object.assign(Object.create(Pl.prototype), {
        constructor: Nl,
        getOutput: function () {
            return this.panner
        },
        getRefDistance: function () {
            return this.panner.refDistance
        },
        setRefDistance: function (t) {
            return this.panner.refDistance = t, this
        },
        getRolloffFactor: function () {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function (t) {
            return this.panner.rolloffFactor = t, this
        },
        getDistanceModel: function () {
            return this.panner.distanceModel
        },
        setDistanceModel: function (t) {
            return this.panner.distanceModel = t, this
        },
        getMaxDistance: function () {
            return this.panner.maxDistance
        },
        setMaxDistance: function (t) {
            return this.panner.maxDistance = t, this
        },
        setDirectionalCone: function (t, e, n) {
            return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
        },
        updateMatrixWorld: function (t) {
            if (nt.prototype.updateMatrixWorld.call(this, t), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                this.matrixWorld.decompose(Rl, Ol, Dl), Il.set(0, 0, 1).applyQuaternion(Ol);
                var e = this.panner;
                if (e.positionX) {
                    var n = this.context.currentTime + this.listener.timeDelta;
                    e.positionX.linearRampToValueAtTime(Rl.x, n), e.positionY.linearRampToValueAtTime(Rl.y, n), e.positionZ.linearRampToValueAtTime(Rl.z, n), e.orientationX.linearRampToValueAtTime(Il.x, n), e.orientationY.linearRampToValueAtTime(Il.y, n), e.orientationZ.linearRampToValueAtTime(Il.z, n)
                } else e.setPosition(Rl.x, Rl.y, Rl.z), e.setOrientation(Il.x, Il.y, Il.z)
            }
        }
    }), Object.assign(kl.prototype, {
        getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function () {
            for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n];
            return t / e.length
        }
    }), Object.assign(zl.prototype, {
        accumulate: function (t, e) {
            var n = this.buffer,
                i = this.valueSize,
                r = t * i + i,
                o = this.cumulativeWeight;
            if (0 === o) {
                for (var a = 0; a !== i; ++a) n[r + a] = n[a];
                o = e
            } else {
                var s = e / (o += e);
                this._mixBufferRegion(n, r, 0, s, i)
            }
            this.cumulativeWeight = o
        },
        accumulateAdditive: function (t) {
            var e = this.buffer,
                n = this.valueSize,
                i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
        },
        apply: function (t) {
            var e = this.valueSize,
                n = this.buffer,
                i = t * e + e,
                r = this.cumulativeWeight,
                o = this.cumulativeWeightAdditive,
                a = this.binding;
            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                var s = e * this._origIndex;
                this._mixBufferRegion(n, i, s, 1 - r, e)
            }
            o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
            for (var l = e, c = e + e; l !== c; ++l)
                if (n[l] !== n[l + e]) {
                    a.setValue(n, i);
                    break
                }
        },
        saveOriginalState: function () {
            var t = this.binding,
                e = this.buffer,
                n = this.valueSize,
                i = n * this._origIndex;
            t.getValue(e, i);
            for (var r = n, o = i; r !== o; ++r) e[r] = e[i + r % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
        },
        restoreOriginalState: function () {
            var t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        },
        _setAdditiveIdentityNumeric: function () {
            var t = this._addIndex * this.valueSize;
            this.buffer.fill(0, t, t + this.valueSize)
        },
        _setAdditiveIdentityQuaternion: function () {
            this._setAdditiveIdentityNumeric(), this.buffer[4 * this._addIndex + 3] = 1
        },
        _setAdditiveIdentityOther: function () {
            var t = this._origIndex * this.valueSize,
                e = this._addIndex * this.valueSize;
            this.buffer.copyWithin(e, t, this.valueSize)
        },
        _select: function (t, e, n, i, r) {
            if (i >= .5)
                for (var o = 0; o !== r; ++o) t[e + o] = t[n + o]
        },
        _slerp: function (t, e, n, i) {
            A.slerpFlat(t, e, t, e, t, n, i)
        },
        _slerpAdditive: function (t, e, n, i, r) {
            var o = this._workIndex * r;
            A.multiplyQuaternionsFlat(t, o, t, e, t, n), A.slerpFlat(t, e, t, e, t, o, i)
        },
        _lerp: function (t, e, n, i, r) {
            for (var o = 1 - i, a = 0; a !== r; ++a) {
                var s = e + a;
                t[s] = t[s] * o + t[n + a] * i
            }
        },
        _lerpAdditive: function (t, e, n, i, r) {
            for (var o = 0; o !== r; ++o) {
                var a = e + o;
                t[a] = t[a] + t[n + o] * i
            }
        }
    });
    var Bl = new RegExp("[\\[\\]\\.:\\/]", "g"),
        Fl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        Ul = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Hl = /(WCOD+)?/.source.replace("WCOD", Fl),
        Gl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Vl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        jl = new RegExp("^" + Ul + Hl + Gl + Vl + "$"),
        Wl = ["material", "materials", "bones"];

    function ql(t, e, n) {
        var i = n || Xl.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, i)
    }

    function Xl(t, e, n) {
        this.path = e, this.parsedPath = n || Xl.parseTrackName(e), this.node = Xl.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
    }

    function Yl(t, e, n, i) {
        this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = i || e.blendMode;
        for (var r = e.tracks, o = r.length, a = new Array(o), s = {
                endingStart: 2400,
                endingEnd: 2400
            }, l = 0; l !== o; ++l) {
            var c = r[l].createInterpolant(null);
            a[l] = c, c.settings = s
        }
        this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function Jl(t) {
        this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function Zl(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
    }

    function Ql(t, e, n) {
        pr.call(this, t, e), this.meshPerAttribute = n || 1
    }

    function Kl(t, e, n, i) {
        this.ray = new Ct(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new G, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function $l(t, e) {
        return t.distance - e.distance
    }

    function tc(t, e, n, i) {
        if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i)
            for (var r = t.children, o = 0, a = r.length; o < a; o++) tc(r[o], e, n, !0)
    }
    Object.assign(ql.prototype, {
        getValue: function (t, e) {
            this.bind();
            var n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
            void 0 !== i && i.getValue(t, e)
        },
        setValue: function (t, e) {
            for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
        },
        bind: function () {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
        },
        unbind: function () {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
        }
    }), Object.assign(Xl, {
        Composite: ql,
        create: function (t, e, n) {
            return t && t.isAnimationObjectGroup ? new Xl.Composite(t, e, n) : new Xl(t, e, n)
        },
        sanitizeNodeName: function (t) {
            return t.replace(/\s/g, "_").replace(Bl, "")
        },
        parseTrackName: function (t) {
            var e = jl.exec(t);
            if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            var n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                var r = n.nodeName.substring(i + 1); - 1 !== Wl.indexOf(r) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
            }
            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n
        },
        findNode: function (t, e) {
            if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
            if (t.skeleton) {
                var n = t.skeleton.getBoneByName(e);
                if (void 0 !== n) return n
            }
            if (t.children) {
                var i = function (t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            if (r.name === e || r.uuid === e) return r;
                            var o = i(r.children);
                            if (o) return o
                        }
                        return null
                    },
                    r = i(t.children);
                if (r) return r
            }
            return null
        }
    }), Object.assign(Xl.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function (t, e) {
            t[e] = this.node[this.propertyName]
        }, function (t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
        }, function (t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }, function (t, e) {
            this.resolvedProperty.toArray(t, e)
        }],
        SetterByBindingTypeAndVersioning: [
            [function (t, e) {
                this.targetObject[this.propertyName] = t[e]
            }, function (t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (t, e) {
                for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
            }, function (t, e) {
                for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }, function (t, e) {
                for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }, function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (t, e) {
                this.resolvedProperty.fromArray(t, e)
            }, function (t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function (t, e) {
            this.bind(), this.getValue(t, e)
        },
        setValue: function (t, e) {
            this.bind(), this.setValue(t, e)
        },
        bind: function () {
            var t = this.node,
                e = this.parsedPath,
                n = e.objectName,
                i = e.propertyName,
                r = e.propertyIndex;
            if (t || (t = Xl.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                if (n) {
                    var o = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (var a = 0; a < t.length; a++)
                                if (t[a].name === o) {
                                    o = a;
                                    break
                                } break;
                        default:
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[n]
                    }
                    if (void 0 !== o) {
                        if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[o]
                    }
                }
                var s = t[i];
                if (void 0 !== s) {
                    var l = this.Versioning.None;
                    this.targetObject = t, void 0 !== t.needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                    var c = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (t.geometry.isBufferGeometry) {
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                    if (t.geometry.morphAttributes.position[a].name === r) {
                                        r = a;
                                        break
                                    }
                            } else {
                                if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                    if (t.geometry.morphTargets[a].name === r) {
                                        r = a;
                                        break
                                    }
                            }
                        }
                        c = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
                } else {
                    var h = e.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + i + " but it wasn't found.", t)
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function () {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(Xl.prototype, {
        _getValue_unbound: Xl.prototype.getValue,
        _setValue_unbound: Xl.prototype.setValue
    }), Object.assign(function () {
        this.uuid = y.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var i = this;
        this.stats = {
            objects: {
                get total() {
                    return i._objects.length
                },
                get inUse() {
                    return this.total - i.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return i._bindings.length
            }
        }
    }.prototype, {
        isAnimationObjectGroup: !0,
        add: function () {
            for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = void 0, c = 0, h = arguments.length; c !== h; ++c) {
                var u = arguments[c],
                    d = u.uuid,
                    p = i[d];
                if (void 0 === p) {
                    p = e++, i[d] = p, t.push(u);
                    for (var f = 0, m = s; f !== m; ++f) a[f].push(new Xl(u, r[f], o[f]))
                } else if (p < n) {
                    l = t[p];
                    var v = --n,
                        g = t[v];
                    i[g.uuid] = p, t[p] = g, i[d] = v, t[v] = u;
                    for (f = 0, m = s; f !== m; ++f) {
                        var y = a[f],
                            _ = y[v],
                            x = y[p];
                        y[p] = _, void 0 === x && (x = new Xl(u, r[f], o[f])), y[v] = x
                    }
                } else t[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = n
        },
        remove: function () {
            for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, o = 0, a = arguments.length; o !== a; ++o) {
                var s = arguments[o],
                    l = s.uuid,
                    c = n[l];
                if (void 0 !== c && c >= e) {
                    var h = e++,
                        u = t[h];
                    n[u.uuid] = c, t[c] = u, n[l] = h, t[h] = s;
                    for (var d = 0, p = r; d !== p; ++d) {
                        var f = i[d],
                            m = f[h],
                            v = f[c];
                        f[c] = m, f[h] = v
                    }
                }
            }
            this.nCachedObjects_ = e
        },
        uncache: function () {
            for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                var l = arguments[a],
                    c = l.uuid,
                    h = i[c];
                if (void 0 !== h)
                    if (delete i[c], h < n) {
                        var u = --n,
                            d = t[u],
                            p = t[y = --e];
                        i[d.uuid] = h, t[h] = d, i[p.uuid] = u, t[u] = p, t.pop();
                        for (var f = 0, m = o; f !== m; ++f) {
                            var v = (_ = r[f])[u],
                                g = _[y];
                            _[h] = v, _[u] = g, _.pop()
                        }
                    } else {
                        var y;
                        i[(p = t[y = --e]).uuid] = h, t[h] = p, t.pop();
                        for (f = 0, m = o; f !== m; ++f) {
                            var _;
                            (_ = r[f])[h] = _[y], _.pop()
                        }
                    }
            }
            this.nCachedObjects_ = n
        },
        subscribe_: function (t, e) {
            var n = this._bindingsIndicesByPath,
                i = n[t],
                r = this._bindings;
            if (void 0 !== i) return r[i];
            var o = this._paths,
                a = this._parsedPaths,
                s = this._objects,
                l = s.length,
                c = this.nCachedObjects_,
                h = new Array(l);
            i = r.length, n[t] = i, o.push(t), a.push(e), r.push(h);
            for (var u = c, d = s.length; u !== d; ++u) {
                var p = s[u];
                h[u] = new Xl(p, t, e)
            }
            return h
        },
        unsubscribe_: function (t) {
            var e = this._bindingsIndicesByPath,
                n = e[t];
            if (void 0 !== n) {
                var i = this._paths,
                    r = this._parsedPaths,
                    o = this._bindings,
                    a = o.length - 1,
                    s = o[a];
                e[t[a]] = n, o[n] = s, o.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop()
            }
        }
    }), Object.assign(Yl.prototype, {
        play: function () {
            return this._mixer._activateAction(this), this
        },
        stop: function () {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function () {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        },
        isRunning: function () {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function () {
            return this._mixer._isActiveAction(this)
        },
        startAt: function (t) {
            return this._startTime = t, this
        },
        setLoop: function (t, e) {
            return this.loop = t, this.repetitions = e, this
        },
        setEffectiveWeight: function (t) {
            return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
        },
        getEffectiveWeight: function () {
            return this._effectiveWeight
        },
        fadeIn: function (t) {
            return this._scheduleFading(t, 0, 1)
        },
        fadeOut: function (t) {
            return this._scheduleFading(t, 1, 0)
        },
        crossFadeFrom: function (t, e, n) {
            if (t.fadeOut(e), this.fadeIn(e), n) {
                var i = this._clip.duration,
                    r = t._clip.duration,
                    o = r / i,
                    a = i / r;
                t.warp(1, o, e), this.warp(a, 1, e)
            }
            return this
        },
        crossFadeTo: function (t, e, n) {
            return t.crossFadeFrom(this, e, n)
        },
        stopFading: function () {
            var t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
        },
        setEffectiveTimeScale: function (t) {
            return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
        },
        getEffectiveTimeScale: function () {
            return this._effectiveTimeScale
        },
        setDuration: function (t) {
            return this.timeScale = this._clip.duration / t, this.stopWarping()
        },
        syncWith: function (t) {
            return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
        },
        halt: function (t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        },
        warp: function (t, e, n) {
            var i = this._mixer,
                r = i.time,
                o = this._timeScaleInterpolant,
                a = this.timeScale;
            null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
            var s = o.parameterPositions,
                l = o.sampleValues;
            return s[0] = r, s[1] = r + n, l[0] = t / a, l[1] = e / a, this
        },
        stopWarping: function () {
            var t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
        },
        getMixer: function () {
            return this._mixer
        },
        getClip: function () {
            return this._clip
        },
        getRoot: function () {
            return this._localRoot || this._mixer._root
        },
        _update: function (t, e, n, i) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    var o = (t - r) * n;
                    if (o < 0 || 0 === n) return;
                    this._startTime = null, e = n * o
                }
                e *= this._updateTimeScale(t);
                var a = this._updateTime(e),
                    s = this._updateWeight(t);
                if (s > 0) {
                    var l = this._interpolants,
                        c = this._propertyBindings;
                    switch (this.blendMode) {
                        case 2501:
                            for (var h = 0, u = l.length; h !== u; ++h) l[h].evaluate(a), c[h].accumulateAdditive(s);
                            break;
                        case 2500:
                        default:
                            for (h = 0, u = l.length; h !== u; ++h) l[h].evaluate(a), c[h].accumulate(i, s)
                    }
                }
            } else this._updateWeight(t)
        },
        _updateWeight: function (t) {
            var e = 0;
            if (this.enabled) {
                e = this.weight;
                var n = this._weightInterpolant;
                if (null !== n) {
                    var i = n.evaluate(t)[0];
                    e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e, e
        },
        _updateTimeScale: function (t) {
            var e = 0;
            if (!this.paused) {
                e = this.timeScale;
                var n = this._timeScaleInterpolant;
                if (null !== n) e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
            }
            return this._effectiveTimeScale = e, e
        },
        _updateTime: function (t) {
            var e = this.time + t,
                n = this._clip.duration,
                i = this.loop,
                r = this._loopCount,
                o = 2202 === i;
            if (0 === t) return -1 === r ? e : o && 1 == (1 & r) ? n - e : e;
            if (2200 === i) {
                -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                t: {
                    if (e >= n) e = n;
                    else {
                        if (!(e < 0)) {
                            this.time = e;
                            break t
                        }
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = e,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= n || e < 0) {
                    var a = Math.floor(e / n);
                    e -= n * a, r += Math.abs(a);
                    var s = this.repetitions - r;
                    if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this.time = e, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t > 0 ? 1 : -1
                    });
                    else {
                        if (1 === s) {
                            var l = t < 0;
                            this._setEndings(l, !l, o)
                        } else this._setEndings(!1, !1, o);
                        this._loopCount = r, this.time = e, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: a
                        })
                    }
                } else this.time = e;
                if (o && 1 == (1 & r)) return n - e
            }
            return e
        },
        _setEndings: function (t, e, n) {
            var i = this._interpolantSettings;
            n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function (t, e, n) {
            var i = this._mixer,
                r = i.time,
                o = this._weightInterpolant;
            null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
            var a = o.parameterPositions,
                s = o.sampleValues;
            return a[0] = r, s[0] = e, a[1] = r + t, s[1] = n, this
        }
    }), Jl.prototype = Object.assign(Object.create(f.prototype), {
        constructor: Jl,
        _bindAction: function (t, e) {
            var n = t._localRoot || this._root,
                i = t._clip.tracks,
                r = i.length,
                o = t._propertyBindings,
                a = t._interpolants,
                s = n.uuid,
                l = this._bindingsByRootAndName,
                c = l[s];
            void 0 === c && (c = {}, l[s] = c);
            for (var h = 0; h !== r; ++h) {
                var u = i[h],
                    d = u.name,
                    p = c[d];
                if (void 0 !== p) o[h] = p;
                else {
                    if (void 0 !== (p = o[h])) {
                        null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                        continue
                    }
                    var f = e && e._propertyBindings[h].binding.parsedPath;
                    ++(p = new zl(Xl.create(n, d, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), o[h] = p
                }
                a[h].resultBuffer = p.buffer
            }
        },
        _activateAction: function (t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    var e = (t._localRoot || this._root).uuid,
                        n = t._clip.uuid,
                        i = this._actionsByClip[n];
                    this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                }
                for (var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                    var s = r[o];
                    0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function (t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                    var r = e[n];
                    0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function () {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function (t) {
            var e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function (t, e, n) {
            var i = this._actions,
                r = this._actionsByClip,
                o = r[e];
            if (void 0 === o) o = {
                knownActions: [t],
                actionByRoot: {}
            }, t._byClipCacheIndex = 0, r[e] = o;
            else {
                var a = o.knownActions;
                t._byClipCacheIndex = a.length, a.push(t)
            }
            t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t
        },
        _removeInactiveAction: function (t) {
            var e = this._actions,
                n = e[e.length - 1],
                i = t._cacheIndex;
            n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
            var r = t._clip.uuid,
                o = this._actionsByClip,
                a = o[r],
                s = a.knownActions,
                l = s[s.length - 1],
                c = t._byClipCacheIndex;
            l._byClipCacheIndex = c, s[c] = l, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function (t) {
            for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                var r = e[n];
                0 == --r.referenceCount && this._removeInactiveBinding(r)
            }
        },
        _lendAction: function (t) {
            var e = this._actions,
                n = t._cacheIndex,
                i = this._nActiveActions++,
                r = e[i];
            t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
        },
        _takeBackAction: function (t) {
            var e = this._actions,
                n = t._cacheIndex,
                i = --this._nActiveActions,
                r = e[i];
            t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
        },
        _addInactiveBinding: function (t, e, n) {
            var i = this._bindingsByRootAndName,
                r = i[e],
                o = this._bindings;
            void 0 === r && (r = {}, i[e] = r), r[n] = t, t._cacheIndex = o.length, o.push(t)
        },
        _removeInactiveBinding: function (t) {
            var e = this._bindings,
                n = t.binding,
                i = n.rootNode.uuid,
                r = n.path,
                o = this._bindingsByRootAndName,
                a = o[i],
                s = e[e.length - 1],
                l = t._cacheIndex;
            s._cacheIndex = l, e[l] = s, e.pop(), delete a[r], 0 === Object.keys(a).length && delete o[i]
        },
        _lendBinding: function (t) {
            var e = this._bindings,
                n = t._cacheIndex,
                i = this._nActiveBindings++,
                r = e[i];
            t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
        },
        _takeBackBinding: function (t) {
            var e = this._bindings,
                n = t._cacheIndex,
                i = --this._nActiveBindings,
                r = e[i];
            t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
        },
        _lendControlInterpolant: function () {
            var t = this._controlInterpolants,
                e = this._nActiveControlInterpolants++,
                n = t[e];
            return void 0 === n && ((n = new Ja(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n
        },
        _takeBackControlInterpolant: function (t) {
            var e = this._controlInterpolants,
                n = t.__cacheIndex,
                i = --this._nActiveControlInterpolants,
                r = e[i];
            t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (t, e, n) {
            var i = e || this._root,
                r = i.uuid,
                o = "string" == typeof t ? os.findByName(i, t) : t,
                a = null !== o ? o.uuid : t,
                s = this._actionsByClip[a],
                l = null;
            if (void 0 === n && (n = null !== o ? o.blendMode : 2500), void 0 !== s) {
                var c = s.actionByRoot[r];
                if (void 0 !== c && c.blendMode === n) return c;
                l = s.knownActions[0], null === o && (o = l._clip)
            }
            if (null === o) return null;
            var h = new Yl(this, o, e, n);
            return this._bindAction(h, l), this._addInactiveAction(h, a, r), h
        },
        existingAction: function (t, e) {
            var n = e || this._root,
                i = n.uuid,
                r = "string" == typeof t ? os.findByName(n, t) : t,
                o = r ? r.uuid : t,
                a = this._actionsByClip[o];
            return void 0 !== a && a.actionByRoot[i] || null
        },
        stopAllAction: function () {
            var t = this._actions,
                e = this._nActiveActions,
                n = this._bindings,
                i = this._nActiveBindings;
            this._nActiveActions = 0, this._nActiveBindings = 0;
            for (var r = 0; r !== e; ++r) t[r].reset();
            for (r = 0; r !== i; ++r) n[r].useCount = 0;
            return this
        },
        update: function (t) {
            t *= this.timeScale;
            for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                e[a]._update(i, t, r, o)
            }
            var s = this._bindings,
                l = this._nActiveBindings;
            for (a = 0; a !== l; ++a) s[a].apply(o);
            return this
        },
        setTime: function (t) {
            this.time = 0;
            for (var e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
            return this.update(t)
        },
        getRoot: function () {
            return this._root
        },
        uncacheClip: function (t) {
            var e = this._actions,
                n = t.uuid,
                i = this._actionsByClip,
                r = i[n];
            if (void 0 !== r) {
                for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                    var l = o[a];
                    this._deactivateAction(l);
                    var c = l._cacheIndex,
                        h = e[e.length - 1];
                    l._cacheIndex = null, l._byClipCacheIndex = null, h._cacheIndex = c, e[c] = h, e.pop(), this._removeInactiveBindingsForAction(l)
                }
                delete i[n]
            }
        },
        uncacheRoot: function (t) {
            var e = t.uuid,
                n = this._actionsByClip;
            for (var i in n) {
                var r = n[i].actionByRoot[e];
                void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
            }
            var o = this._bindingsByRootAndName[e];
            if (void 0 !== o)
                for (var a in o) {
                    var s = o[a];
                    s.restoreOriginalState(), this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function (t, e) {
            var n = this.existingAction(t, e);
            null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
        }
    }), Zl.prototype.clone = function () {
        return new Zl(void 0 === this.value.clone ? this.value : this.value.clone())
    }, Ql.prototype = Object.assign(Object.create(pr.prototype), {
        constructor: Ql,
        isInstancedInterleavedBuffer: !0,
        copy: function (t) {
            return pr.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        }
    }), Object.assign(Kl.prototype, {
        set: function (t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function (t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function (t, e, n) {
            var i = n || [];
            return tc(t, this, i, e), i.sort($l), i
        },
        intersectObjects: function (t, e, n) {
            var i = n || [];
            if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
            for (var r = 0, o = t.length; r < o; r++) tc(t[r], this, i, e);
            return i.sort($l), i
        }
    }), Object.assign(function (t, e, n) {
        return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
    }.prototype, {
        set: function (t, e, n) {
            return this.radius = t, this.phi = e, this.theta = n, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
        },
        makeSafe: function () {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        },
        setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        },
        setFromCartesianCoords: function (t, e, n) {
            return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(y.clamp(e / this.radius, -1, 1))), this
        }
    }), Object.assign(function (t, e, n) {
        return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
    }.prototype, {
        set: function (t, e, n) {
            return this.radius = t, this.theta = e, this.y = n, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
        },
        setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        },
        setFromCartesianCoords: function (t, e, n) {
            return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
        }
    });
    var ec = new _;

    function nc(t, e) {
        this.min = void 0 !== t ? t : new _(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new _(-1 / 0, -1 / 0)
    }
    Object.assign(nc.prototype, {
        set: function (t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromPoints: function (t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function (t, e) {
            var n = ec.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function (t) {
            return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new _), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (t) {
            return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new _), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function (t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function (t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function (t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        containsPoint: function (t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function (t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new _), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function (t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new _), e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function (t) {
            return ec.copy(t).clamp(this.min, this.max).sub(t).length()
        },
        intersect: function (t) {
            return this.min.max(t.min), this.max.min(t.max), this
        },
        union: function (t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        translate: function (t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function (t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    });
    var ic = new P,
        rc = new P;

    function oc(t, e) {
        this.start = void 0 !== t ? t : new P, this.end = void 0 !== e ? e : new P
    }

    function ac(t) {
        nt.call(this), this.material = t, this.render = function () {}
    }
    Object.assign(oc.prototype, {
        set: function (t, e) {
            return this.start.copy(t), this.end.copy(e), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
        },
        getCenter: function (t) {
            return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new P), t.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function (t) {
            return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new P), t.subVectors(this.end, this.start)
        },
        distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        },
        distance: function () {
            return this.start.distanceTo(this.end)
        },
        at: function (t, e) {
            return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new P), this.delta(e).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function (t, e) {
            ic.subVectors(t, this.start), rc.subVectors(this.end, this.start);
            var n = rc.dot(rc),
                i = rc.dot(ic) / n;
            return e && (i = y.clamp(i, 0, 1)), i
        },
        closestPointToPoint: function (t, e, n) {
            var i = this.closestPointToPointParameter(t, e);
            return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new P), this.delta(n).multiplyScalar(i).add(this.start)
        },
        applyMatrix4: function (t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
        },
        equals: function (t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }), ac.prototype = Object.create(nt.prototype), ac.prototype.constructor = ac, ac.prototype.isImmediateRenderObject = !0;
    var sc = new P;

    function lc(t, e) {
        nt.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        for (var n = new be, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
            var a = r / 32 * Math.PI * 2,
                s = o / 32 * Math.PI * 2;
            i.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
        }
        n.setAttribute("position", new he(i, 3));
        var l = new Zr({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new oo(n, l), this.add(this.cone), this.update()
    }
    lc.prototype = Object.create(nt.prototype), lc.prototype.constructor = lc, lc.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, lc.prototype.update = function () {
        this.light.updateMatrixWorld();
        var t = this.light.distance ? this.light.distance : 1e3,
            e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t), sc.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(sc), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    };
    var cc = new P,
        hc = new B,
        uc = new B;

    function dc(t) {
        for (var e = function t(e) {
                var n = [];
                e && e.isBone && n.push(e);
                for (var i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                return n
            }(t), n = new be, i = [], r = [], o = new Xt(0, 0, 1), a = new Xt(0, 1, 0), s = 0; s < e.length; s++) {
            var l = e[s];
            l.parent && l.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
        }
        n.setAttribute("position", new he(i, 3)), n.setAttribute("color", new he(r, 3));
        var c = new Zr({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        oo.call(this, n, c), this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
    }

    function pc(t, e, n) {
        this.light = t, this.light.updateMatrixWorld(), this.color = n;
        var i = new _a(e, 4, 2),
            r = new te({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            });
        Fe.call(this, i, r), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }
    dc.prototype = Object.create(oo.prototype), dc.prototype.constructor = dc, dc.prototype.isSkeletonHelper = !0, dc.prototype.updateMatrixWorld = function (t) {
        var e = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
        uc.getInverse(this.root.matrixWorld);
        for (var r = 0, o = 0; r < e.length; r++) {
            var a = e[r];
            a.parent && a.parent.isBone && (hc.multiplyMatrices(uc, a.matrixWorld), cc.setFromMatrixPosition(hc), i.setXYZ(o, cc.x, cc.y, cc.z), hc.multiplyMatrices(uc, a.parent.matrixWorld), cc.setFromMatrixPosition(hc), i.setXYZ(o + 1, cc.x, cc.y, cc.z), o += 2)
        }
        n.getAttribute("position").needsUpdate = !0, nt.prototype.updateMatrixWorld.call(this, t)
    }, pc.prototype = Object.create(Fe.prototype), pc.prototype.constructor = pc, pc.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose()
    }, pc.prototype.update = function () {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    };
    var fc = new P,
        mc = new Xt,
        vc = new Xt;

    function gc(t, e, n) {
        nt.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
        var i = new Ao(e);
        i.rotateY(.5 * Math.PI), this.material = new te({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }), void 0 === this.color && (this.material.vertexColors = !0);
        var r = i.getAttribute("position"),
            o = new Float32Array(3 * r.count);
        i.setAttribute("color", new ne(o, 3)), this.add(new Fe(i, this.material)), this.update()
    }

    function yc(t, e, n, i) {
        t = t || 10, e = e || 10, n = new Xt(void 0 !== n ? n : 4473924), i = new Xt(void 0 !== i ? i : 8947848);
        for (var r = e / 2, o = t / e, a = t / 2, s = [], l = [], c = 0, h = 0, u = -a; c <= e; c++, u += o) {
            s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
            var d = c === r ? n : i;
            d.toArray(l, h), h += 3, d.toArray(l, h), h += 3, d.toArray(l, h), h += 3, d.toArray(l, h), h += 3
        }
        var p = new be;
        p.setAttribute("position", new he(s, 3)), p.setAttribute("color", new he(l, 3));
        var f = new Zr({
            vertexColors: !0,
            toneMapped: !1
        });
        oo.call(this, p, f), this.type = "GridHelper"
    }

    function _c(t, e, n, i, r, o) {
        t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new Xt(void 0 !== r ? r : 4473924), o = new Xt(void 0 !== o ? o : 8947848);
        var a, s, l, c, h, u, d, p = [],
            f = [];
        for (c = 0; c <= e; c++) l = c / e * (2 * Math.PI), a = Math.sin(l) * t, s = Math.cos(l) * t, p.push(0, 0, 0), p.push(a, 0, s), d = 1 & c ? r : o, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
        for (c = 0; c <= n; c++)
            for (d = 1 & c ? r : o, u = t - t / n * c, h = 0; h < i; h++) l = h / i * (2 * Math.PI), a = Math.sin(l) * u, s = Math.cos(l) * u, p.push(a, 0, s), f.push(d.r, d.g, d.b), l = (h + 1) / i * (2 * Math.PI), a = Math.sin(l) * u, s = Math.cos(l) * u, p.push(a, 0, s), f.push(d.r, d.g, d.b);
        var m = new be;
        m.setAttribute("position", new he(p, 3)), m.setAttribute("color", new he(f, 3));
        var v = new Zr({
            vertexColors: !0,
            toneMapped: !1
        });
        oo.call(this, m, v), this.type = "PolarGridHelper"
    }
    gc.prototype = Object.create(nt.prototype), gc.prototype.constructor = gc, gc.prototype.dispose = function () {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, gc.prototype.update = function () {
        var t = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
            var e = t.geometry.getAttribute("color");
            mc.copy(this.light.color), vc.copy(this.light.groundColor);
            for (var n = 0, i = e.count; n < i; n++) {
                var r = n < i / 2 ? mc : vc;
                e.setXYZ(n, r.r, r.g, r.b)
            }
            e.needsUpdate = !0
        }
        t.lookAt(fc.setFromMatrixPosition(this.light.matrixWorld).negate())
    }, yc.prototype = Object.assign(Object.create(oo.prototype), {
        constructor: yc,
        copy: function (t) {
            return oo.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), _c.prototype = Object.create(oo.prototype), _c.prototype.constructor = _c;
    var xc = new P,
        bc = new P,
        wc = new P;

    function Mc(t, e, n) {
        nt.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
        var i = new be;
        i.setAttribute("position", new he([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        var r = new Zr({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new no(i, r), this.add(this.lightPlane), (i = new be).setAttribute("position", new he([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new no(i, r), this.add(this.targetLine), this.update()
    }
    Mc.prototype = Object.create(nt.prototype), Mc.prototype.constructor = Mc, Mc.prototype.dispose = function () {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, Mc.prototype.update = function () {
        xc.setFromMatrixPosition(this.light.matrixWorld), bc.setFromMatrixPosition(this.light.target.matrixWorld), wc.subVectors(bc, xc), this.lightPlane.lookAt(bc), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(bc), this.targetLine.scale.z = wc.length()
    };
    var Sc = new P,
        Tc = new Ke;

    function Ec(t) {
        var e = new be,
            n = new Zr({
                color: 16777215,
                vertexColors: !0,
                toneMapped: !1
            }),
            i = [],
            r = [],
            o = {},
            a = new Xt(16755200),
            s = new Xt(16711680),
            l = new Xt(43775),
            c = new Xt(16777215),
            h = new Xt(3355443);

        function u(t, e, n) {
            d(t, n), d(e, n)
        }

        function d(t, e) {
            i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(i.length / 3 - 1)
        }
        u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new he(i, 3)), e.setAttribute("color", new he(r, 3)), oo.call(this, e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }

    function Ac(t, e, n, i, r, o, a) {
        Sc.set(r, o, a).unproject(i);
        var s = e[t];
        if (void 0 !== s)
            for (var l = n.getAttribute("position"), c = 0, h = s.length; c < h; c++) l.setXYZ(s[c], Sc.x, Sc.y, Sc.z)
    }
    Ec.prototype = Object.create(oo.prototype), Ec.prototype.constructor = Ec, Ec.prototype.update = function () {
        var t = this.geometry,
            e = this.pointMap;
        Tc.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ac("c", e, t, Tc, 0, 0, -1), Ac("t", e, t, Tc, 0, 0, 1), Ac("n1", e, t, Tc, -1, -1, -1), Ac("n2", e, t, Tc, 1, -1, -1), Ac("n3", e, t, Tc, -1, 1, -1), Ac("n4", e, t, Tc, 1, 1, -1), Ac("f1", e, t, Tc, -1, -1, 1), Ac("f2", e, t, Tc, 1, -1, 1), Ac("f3", e, t, Tc, -1, 1, 1), Ac("f4", e, t, Tc, 1, 1, 1), Ac("u1", e, t, Tc, .7, 1.1, -1), Ac("u2", e, t, Tc, -.7, 1.1, -1), Ac("u3", e, t, Tc, 0, 2, -1), Ac("cf1", e, t, Tc, -1, 0, 1), Ac("cf2", e, t, Tc, 1, 0, 1), Ac("cf3", e, t, Tc, 0, -1, 1), Ac("cf4", e, t, Tc, 0, 1, 1), Ac("cn1", e, t, Tc, -1, 0, -1), Ac("cn2", e, t, Tc, 1, 0, -1), Ac("cn3", e, t, Tc, 0, -1, -1), Ac("cn4", e, t, Tc, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
    };
    var Cc = new gt;

    function Lc(t, e) {
        this.object = t, void 0 === e && (e = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = new Float32Array(24),
            r = new be;
        r.setIndex(new ne(n, 1)), r.setAttribute("position", new ne(i, 3)), oo.call(this, r, new Zr({
            color: e,
            toneMapped: !1
        })), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
    }

    function Pc(t, e) {
        this.type = "Box3Helper", this.box = t, e = e || 16776960;
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = new be;
        i.setIndex(new ne(n, 1)), i.setAttribute("position", new he([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), oo.call(this, i, new Zr({
            color: e,
            toneMapped: !1
        })), this.type = "Box3Helper", this.geometry.computeBoundingSphere()
    }

    function Rc(t, e, n) {
        this.plane = t, this.size = void 0 === e ? 1 : e;
        var i = void 0 !== n ? n : 16776960,
            r = new be;
        r.setAttribute("position", new he([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), no.call(this, r, new Zr({
            color: i,
            toneMapped: !1
        })), this.type = "PlaneHelper";
        var o = new be;
        o.setAttribute("position", new he([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Fe(o, new te({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    Lc.prototype = Object.create(oo.prototype), Lc.prototype.constructor = Lc, Lc.prototype.update = function (t) {
        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Cc.setFromObject(this.object), !Cc.isEmpty()) {
            var e = Cc.min,
                n = Cc.max,
                i = this.geometry.attributes.position,
                r = i.array;
            r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
        }
    }, Lc.prototype.setFromObject = function (t) {
        return this.object = t, this.update(), this
    }, Lc.prototype.copy = function (t) {
        return oo.prototype.copy.call(this, t), this.object = t.object, this
    }, Lc.prototype.clone = function () {
        return (new this.constructor).copy(this)
    }, Pc.prototype = Object.create(oo.prototype), Pc.prototype.constructor = Pc, Pc.prototype.updateMatrixWorld = function (t) {
        var e = this.box;
        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), nt.prototype.updateMatrixWorld.call(this, t))
    }, Rc.prototype = Object.create(no.prototype), Rc.prototype.constructor = Rc, Rc.prototype.updateMatrixWorld = function (t) {
        var e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? 1 : 0, this.lookAt(this.plane.normal), nt.prototype.updateMatrixWorld.call(this, t)
    };
    var Oc, Dc, Ic = new P;

    function Nc(t, e, n, i, r, o) {
        nt.call(this), this.type = "ArrowHelper", void 0 === t && (t = new P(0, 0, 1)), void 0 === e && (e = new P(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === Oc && ((Oc = new be).setAttribute("position", new he([0, 0, 0, 0, 1, 0], 3)), (Dc = new La(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new no(Oc, new Zr({
            color: i,
            toneMapped: !1
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Fe(Dc, new te({
            color: i,
            toneMapped: !1
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o)
    }

    function kc(t) {
        var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            n = new be;
        n.setAttribute("position", new he(e, 3)), n.setAttribute("color", new he([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        var i = new Zr({
            vertexColors: !0,
            toneMapped: !1
        });
        oo.call(this, n, i), this.type = "AxesHelper"
    }
    Nc.prototype = Object.create(nt.prototype), Nc.prototype.constructor = Nc, Nc.prototype.setDirection = function (t) {
        if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            Ic.set(t.z, 0, -t.x).normalize();
            var e = Math.acos(t.y);
            this.quaternion.setFromAxisAngle(Ic, e)
        }
    }, Nc.prototype.setLength = function (t, e, n) {
        void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
    }, Nc.prototype.setColor = function (t) {
        this.line.material.color.set(t), this.cone.material.color.set(t)
    }, Nc.prototype.copy = function (t) {
        return nt.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
    }, Nc.prototype.clone = function () {
        return (new this.constructor).copy(this)
    }, kc.prototype = Object.create(oo.prototype), kc.prototype.constructor = kc;
    var zc = Math.pow(2, 8),
        Bc = [.125, .215, .35, .446, .526, .582],
        Fc = 5 + Bc.length,
        Uc = {
            3e3: 0,
            3001: 1,
            3002: 2,
            3004: 3,
            3005: 4,
            3006: 5,
            3007: 6
        },
        Hc = new Js,
        {
            _lodPlanes: Gc,
            _sizeLods: Vc,
            _sigmas: jc
        } = function () {
            for (var t = [], e = [], n = [], i = 8, r = 0; r < Fc; r++) {
                var o = Math.pow(2, i);
                e.push(o);
                var a = 1 / o;
                r > 4 ? a = Bc[r - 8 + 4 - 1] : 0 == r && (a = 0), n.push(a);
                for (var s = 1 / (o - 1), l = -s / 2, c = 1 + s / 2, h = [l, l, c, l, c, c, l, l, c, c, l, c], u = new Float32Array(108), d = new Float32Array(72), p = new Float32Array(36), f = 0; f < 6; f++) {
                    var m = f % 3 * 2 / 3 - 1,
                        v = f > 2 ? 0 : -1,
                        g = [m, v, 0, m + 2 / 3, v, 0, m + 2 / 3, v + 1, 0, m, v, 0, m + 2 / 3, v + 1, 0, m, v + 1, 0];
                    u.set(g, 18 * f), d.set(h, 12 * f);
                    var y = [f, f, f, f, f, f];
                    p.set(y, 6 * f)
                }
                var _ = new be;
                _.setAttribute("position", new ne(u, 3)), _.setAttribute("uv", new ne(d, 2)), _.setAttribute("faceIndex", new ne(p, 1)), t.push(_), i > 4 && i--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: n
            }
        }(),
        Wc = null,
        qc = (1 + Math.sqrt(5)) / 2,
        Xc = 1 / qc,
        Yc = [new P(1, 1, 1), new P(-1, 1, 1), new P(1, 1, -1), new P(-1, 1, -1), new P(0, qc, Xc), new P(0, qc, -Xc), new P(Xc, 0, qc), new P(-Xc, 0, qc), new P(qc, Xc, 0), new P(-qc, Xc, 0)];

    function Jc(t) {
        var e, n, i, r;
        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = (e = 20, n = new Float32Array(e), i = new P(0, 1, 0), (r = new ka({
            defines: {
                n: e
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: n
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: i
                },
                inputEncoding: {
                    value: Uc[3e3]
                },
                outputEncoding: {
                    value: Uc[3e3]
                }
            },
            vertexShader: eh(),
            fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${nh()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })).type = "SphericalGaussianBlur", r), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
    }

    function Zc(t) {
        return void 0 !== t && 1009 === t.type && (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding)
    }

    function Qc(t) {
        var e = new T(3 * zc, 3 * zc, t);
        return e.texture.mapping = 306, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
    }

    function Kc(t, e, n, i, r) {
        t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
    }

    function $c() {
        var t = new ka({
            uniforms: {
                envMap: {
                    value: null
                },
                texelSize: {
                    value: new _(1, 1)
                },
                inputEncoding: {
                    value: Uc[3e3]
                },
                outputEncoding: {
                    value: Uc[3e3]
                }
            },
            vertexShader: eh(),
            fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${nh()}\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        });
        return t.type = "EquirectangularToCubeUV", t
    }

    function th() {
        var t = new ka({
            uniforms: {
                envMap: {
                    value: null
                },
                inputEncoding: {
                    value: Uc[3e3]
                },
                outputEncoding: {
                    value: Uc[3e3]
                }
            },
            vertexShader: eh(),
            fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${nh()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        });
        return t.type = "CubemapToCubeUV", t
    }

    function eh() {
        return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t"
    }

    function nh() {
        return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t"
    }
    Jc.prototype = {
        constructor: Jc,
        fromScene: function (t, e = 0, n = .1, i = 100) {
            Wc = this._renderer.getRenderTarget();
            var r = this._allocateTargets();
            return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
        },
        fromEquirectangular: function (t) {
            return t.magFilter = 1003, t.minFilter = 1003, t.generateMipmaps = !1, this.fromCubemap(t)
        },
        fromCubemap: function (t) {
            Wc = this._renderer.getRenderTarget();
            var e = this._allocateTargets(t);
            return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
        },
        compileCubemapShader: function () {
            null === this._cubemapShader && (this._cubemapShader = th(), this._compileMaterial(this._cubemapShader))
        },
        compileEquirectangularShader: function () {
            null === this._equirectShader && (this._equirectShader = $c(), this._compileMaterial(this._equirectShader))
        },
        dispose: function () {
            this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
            for (var t = 0; t < Gc.length; t++) Gc[t].dispose()
        },
        _cleanup: function (t) {
            this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Wc), t.scissorTest = !1, t.setSize(t.width, t.height)
        },
        _allocateTargets: function (t) {
            var e = {
                    magFilter: 1003,
                    minFilter: 1003,
                    generateMipmaps: !1,
                    type: 1009,
                    format: 1023,
                    encoding: Zc(t) ? t.encoding : 3002,
                    depthBuffer: !1,
                    stencilBuffer: !1
                },
                n = Qc(e);
            return n.depthBuffer = !t, this._pingPongRenderTarget = Qc(e), n
        },
        _compileMaterial: function (t) {
            var e = new it;
            e.add(new Fe(Gc[0], t)), this._renderer.compile(e, Hc)
        },
        _sceneToCubeUV: function (t, e, n, i) {
            var r = new $e(90, 1, e, n),
                o = [1, 1, 1, 1, -1, 1],
                a = [1, 1, -1, -1, -1, 1],
                s = this._renderer,
                l = s.outputEncoding,
                c = s.toneMapping,
                h = s.toneMappingExposure,
                u = s.getClearColor(),
                d = s.getClearAlpha();
            s.toneMapping = 1, s.toneMappingExposure = 1, s.outputEncoding = 3e3, t.scale.z *= -1;
            var p = t.background;
            if (p && p.isColor) {
                p.convertSRGBToLinear();
                var f = Math.max(p.r, p.g, p.b),
                    m = Math.min(Math.max(Math.ceil(Math.log2(f)), -128), 127);
                p = p.multiplyScalar(Math.pow(2, -m));
                var v = (m + 128) / 255;
                s.setClearColor(p, v), t.background = null
            }
            for (var g = 0; g < 6; g++) {
                var y = g % 3;
                0 == y ? (r.up.set(0, o[g], 0), r.lookAt(a[g], 0, 0)) : 1 == y ? (r.up.set(0, 0, o[g]), r.lookAt(0, a[g], 0)) : (r.up.set(0, o[g], 0), r.lookAt(0, 0, a[g])), Kc(i, y * zc, g > 2 ? zc : 0, zc, zc), s.setRenderTarget(i), s.render(t, r)
            }
            s.toneMapping = c, s.toneMappingExposure = h, s.outputEncoding = l, s.setClearColor(u, d), t.scale.z *= -1
        },
        _textureToCubeUV: function (t, e) {
            var n = new it,
                i = this._renderer;
            t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = th()) : null == this._equirectShader && (this._equirectShader = $c());
            var r = t.isCubeTexture ? this._cubemapShader : this._equirectShader;
            n.add(new Fe(Gc[0], r));
            var o = r.uniforms;
            o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = Uc[t.encoding], o.outputEncoding.value = Uc[e.texture.encoding], Kc(e, 0, 0, 3 * zc, 2 * zc), i.setRenderTarget(e), i.render(n, Hc)
        },
        _applyPMREM: function (t) {
            var e = this._renderer,
                n = e.autoClear;
            e.autoClear = !1;
            for (var i = 1; i < Fc; i++) {
                var r = Math.sqrt(jc[i] * jc[i] - jc[i - 1] * jc[i - 1]),
                    o = Yc[(i - 1) % Yc.length];
                this._blur(t, i - 1, i, r, o)
            }
            e.autoClear = n
        },
        _blur: function (t, e, n, i, r) {
            var o = this._pingPongRenderTarget;
            this._halfBlur(t, o, e, n, i, "latitudinal", r), this._halfBlur(o, t, n, n, i, "longitudinal", r)
        },
        _halfBlur: function (t, e, n, i, r, o, a) {
            var s = this._renderer,
                l = this._blurMaterial;
            "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
            var c = new it;
            c.add(new Fe(Gc[i], l));
            var h = l.uniforms,
                u = Vc[n] - 1,
                d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                p = r / d,
                f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
            f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
            for (var m = [], v = 0, g = 0; g < 20; ++g) {
                var y = g / p,
                    _ = Math.exp(-y * y / 2);
                m.push(_), 0 == g ? v += _ : g < f && (v += 2 * _)
            }
            for (g = 0; g < m.length; g++) m[g] = m[g] / v;
            h.envMap.value = t.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === o, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = 8 - n, h.inputEncoding.value = Uc[t.texture.encoding], h.outputEncoding.value = Uc[t.texture.encoding];
            var x = Vc[i];
            Kc(e, y = 3 * Math.max(0, zc - 2 * x), (0 === i ? 0 : 2 * zc) + 2 * x * (i > 4 ? i - 8 + 4 : 0), 3 * x, 2 * x), s.setRenderTarget(e), s.render(c, Hc)
        }
    };

    function ih(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), As.call(this, t), this.type = "catmullrom"
    }
    _s.create = function (t, e) {
        return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(_s.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
    }, Object.assign(Fs.prototype, {
        createPointsGeometry: function (t) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function (t) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function (t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var e = new qe, n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.vertices.push(new P(r.x, r.y, r.z || 0))
            }
            return e
        }
    }), Object.assign(Us.prototype, {
        fromPoints: function (t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
        }
    }), Object.create(As.prototype), Object.create(As.prototype), ih.prototype = Object.create(As.prototype), Object.assign(ih.prototype, {
        initFromArray: function () {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function () {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function () {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), yc.prototype.setColors = function () {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, dc.prototype.update = function () {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(hs.prototype, {
        extractUrlBase: function (t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), il(t)
        }
    }), hs.Handlers = {
        add: function () {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function () {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    }, Object.assign(ll.prototype, {
        setTexturePath: function (t) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
        }
    }), Object.assign(nc.prototype, {
        center: function (t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function () {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function (t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        size: function (t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Object.assign(gt.prototype, {
        center: function (t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function () {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function (t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionSphere: function (t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        },
        size: function (t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Object.assign(xt.prototype, {
        empty: function () {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }
    }), an.prototype.setFromMatrix = function (t) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
    }, oc.prototype.center = function (t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, Object.assign(y, {
        random16: function () {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function (t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), y.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function (t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), y.ceilPowerOfTwo(t)
        }
    }), Object.assign(x.prototype, {
        flattenToArrayOffset: function (t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        multiplyVector3: function (t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        multiplyVector3Array: function () {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBufferAttribute: function (t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        applyToVector3Array: function () {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(B.prototype, {
        extractPosition: function (t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        },
        flattenToArrayOffset: function (t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        getPosition: function () {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new P).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function (t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function (t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector4: function (t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector3Array: function () {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function (t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        },
        crossVector: function (t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBufferAttribute: function (t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        applyToVector3Array: function () {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function (t, e, n, i, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o)
        }
    }), Ot.prototype.isIntersectionLine = function (t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
    }, A.prototype.multiplyVector3 = function (t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
    }, Object.assign(Ct.prototype, {
        isIntersectionBox: function (t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionPlane: function (t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        },
        isIntersectionSphere: function (t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }
    }), Object.assign(Vt.prototype, {
        area: function () {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function (t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
        },
        midpoint: function (t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
        },
        normal: function (t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
        },
        plane: function (t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
        }
    }), Object.assign(Vt, {
        barycoordFromPoint: function (t, e, n, i, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Vt.getBarycoord(t, e, n, i, r)
        },
        normal: function (t, e, n, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Vt.getNormal(t, e, n, i)
        }
    }), Object.assign(Hs.prototype, {
        extractAllPoints: function (t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
        },
        extrude: function (t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new da(this, t)
        },
        makeGeometry: function (t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Sa(this, t)
        }
    }), Object.assign(_.prototype, {
        fromAttribute: function (t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function (t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        },
        lengthManhattan: function () {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(P.prototype, {
        setEulerFromRotationMatrix: function () {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function () {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function (t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function (t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function (t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        },
        applyProjection: function (t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        },
        fromAttribute: function (t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function (t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        },
        lengthManhattan: function () {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(S.prototype, {
        fromAttribute: function (t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        lengthManhattan: function () {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(qe.prototype, {
        computeTangents: function () {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function () {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        },
        applyMatrix: function (t) {
            return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }
    }), Object.assign(nt.prototype, {
        getChildByName: function (t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        },
        renderDepth: function () {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function (t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        },
        getWorldRotation: function () {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        },
        applyMatrix: function (t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }
    }), Object.defineProperties(nt.prototype, {
        eulerOrder: {
            get: function () {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function (t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.assign(Fe.prototype, {
        setDrawMode: function () {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }), Object.defineProperties(Fe.prototype, {
        drawMode: {
            get: function () {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
            },
            set: function () {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }), Object.defineProperties(Fr.prototype, {
        objects: {
            get: function () {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Vr.prototype, "useVertexTexture", {
        get: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Ur.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(_s.prototype, "__arcLengthDivisions", {
        get: function () {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function (t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
        }
    }), $e.prototype.setLens = function (t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
    }, Object.defineProperties(Gs.prototype, {
        onlyShadow: {
            set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function () {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function (t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function (t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function (t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
            }
        }
    }), Object.defineProperties(ne.prototype, {
        length: {
            get: function () {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        dynamic: {
            get: function () {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage
            },
            set: function () {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048)
            }
        }
    }), Object.assign(ne.prototype, {
        setDynamic: function (t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this
        },
        copyIndicesArray: function () {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        },
        setArray: function () {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }), Object.assign(be.prototype, {
        addIndex: function (t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        },
        addAttribute: function (t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new ne(arguments[1], arguments[2])))
        },
        addDrawCall: function (t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        },
        clearDrawCalls: function () {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function () {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function () {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        },
        removeAttribute: function (t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
        },
        applyMatrix: function (t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }
    }), Object.defineProperties(be.prototype, {
        drawcalls: {
            get: function () {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function () {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.defineProperties(Kl.prototype, {
        linePrecision: {
            get: function () {
                return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
            },
            set: function (t) {
                console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t
            }
        }
    }), Object.defineProperties(pr.prototype, {
        dynamic: {
            get: function () {
                return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage
            },
            set: function (t) {
                console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t)
            }
        }
    }), Object.assign(pr.prototype, {
        setDynamic: function (t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this
        },
        setArray: function () {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }), Object.assign(pa.prototype, {
        getArrays: function () {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function () {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function () {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Zl.prototype, {
        dynamic: {
            set: function () {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function () {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties($t.prototype, {
        wrapAround: {
            get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function () {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function () {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function () {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new Xt
            }
        },
        shading: {
            get: function () {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function (t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
            }
        },
        stencilMask: {
            get: function () {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
            },
            set: function (t) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
            }
        }
    }), Object.defineProperties(Fa.prototype, {
        metal: {
            get: function () {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function () {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(Qe.prototype, {
        derivatives: {
            get: function () {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function (t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
            }
        }
    }), Object.assign(hr.prototype, {
        clearTarget: function (t, e, n, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
        },
        animate: function (t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
        },
        getCurrentRenderTarget: function () {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function () {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function () {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function () {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function () {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function () {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function () {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function (t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        },
        initMaterial: function () {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function () {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function () {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function () {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function () {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function () {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function () {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        },
        getActiveMipMapLevel: function () {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }
    }), Object.defineProperties(hr.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function () {
                return this.shadowMap.type
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
            }
        },
        vr: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
            }
        },
        gammaInput: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function () {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? 3001 : 3e3
            }
        }
    }), Object.defineProperties(nr.prototype, {
        cullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(T.prototype, {
        wrapS: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
            }
        },
        offset: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
            }
        },
        repeat: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
            }
        },
        format: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
            }
        },
        type: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
            }
        }
    }), Object.defineProperties(Pl.prototype, {
        load: {
            value: function (t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var e = this;
                return (new _l).load(t, (function (t) {
                    e.setBuffer(t)
                })), this
            }
        },
        startTime: {
            set: function () {
                console.warn("THREE.Audio: .startTime is now .play( delay ).")
            }
        }
    }), kl.prototype.getData = function () {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, tn.prototype.updateCubeMap = function (t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
    };
    b.crossOrigin = void 0, b.loadTexture = function (t, e, n, i) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var r = new ys;
        r.setCrossOrigin(this.crossOrigin);
        var o = r.load(t, n, void 0, i);
        return e && (o.mapping = e), o
    }, b.loadTextureCube = function (t, e, n, i) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var r = new gs;
        r.setCrossOrigin(this.crossOrigin);
        var o = r.load(t, n, void 0, i);
        return e && (o.mapping = e), o
    }, b.loadCompressedTexture = function () {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, b.loadCompressedTextureCube = function () {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    };
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: "116"
        }
    }));
    var rh = n(2),
        oh = n.n(rh),
        ah = n(3),
        sh = n.n(ah),
        lh = n(4),
        ch = n.n(lh),
        hh = n(5),
        uh = n.n(hh),
        dh = n(6),
        ph = n.n(dh),
        fh = n(7),
        mh = n.n(fh);

    function vh(t, e) {
        var n = t.__state.conversionName.toString(),
            i = Math.round(t.r),
            r = Math.round(t.g),
            o = Math.round(t.b),
            a = t.a,
            s = Math.round(t.h),
            l = t.s.toFixed(1),
            c = t.v.toFixed(1);
        if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
            for (var h = t.hex.toString(16); h.length < 6;) h = "0" + h;
            return "#" + h
        }
        return "CSS_RGB" === n ? "rgb(" + i + "," + r + "," + o + ")" : "CSS_RGBA" === n ? "rgba(" + i + "," + r + "," + o + "," + a + ")" : "HEX" === n ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === n ? "[" + i + "," + r + "," + o + "]" : "RGBA_ARRAY" === n ? "[" + i + "," + r + "," + o + "," + a + "]" : "RGB_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + o + "}" : "RGBA_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + o + ",a:" + a + "}" : "HSV_OBJ" === n ? "{h:" + s + ",s:" + l + ",v:" + c + "}" : "HSVA_OBJ" === n ? "{h:" + s + ",s:" + l + ",v:" + c + ",a:" + a + "}" : "unknown format"
    }
    var gh = Array.prototype.forEach,
        yh = Array.prototype.slice,
        _h = {
            BREAK: {},
            extend: function (t) {
                return this.each(yh.call(arguments, 1), (function (e) {
                    (this.isObject(e) ? Object.keys(e) : []).forEach(function (n) {
                        this.isUndefined(e[n]) || (t[n] = e[n])
                    }.bind(this))
                }), this), t
            },
            defaults: function (t) {
                return this.each(yh.call(arguments, 1), (function (e) {
                    (this.isObject(e) ? Object.keys(e) : []).forEach(function (n) {
                        this.isUndefined(t[n]) && (t[n] = e[n])
                    }.bind(this))
                }), this), t
            },
            compose: function () {
                var t = yh.call(arguments);
                return function () {
                    for (var e = yh.call(arguments), n = t.length - 1; n >= 0; n--) e = [t[n].apply(this, e)];
                    return e[0]
                }
            },
            each: function (t, e, n) {
                if (t)
                    if (gh && t.forEach && t.forEach === gh) t.forEach(e, n);
                    else if (t.length === t.length + 0) {
                    var i, r = void 0;
                    for (r = 0, i = t.length; r < i; r++)
                        if (r in t && e.call(n, t[r], r) === this.BREAK) return
                } else
                    for (var o in t)
                        if (e.call(n, t[o], o) === this.BREAK) return
            },
            defer: function (t) {
                setTimeout(t, 0)
            },
            debounce: function (t, e, n) {
                var i = void 0;
                return function () {
                    var r = this,
                        o = arguments;

                    function a() {
                        i = null, n || t.apply(r, o)
                    }
                    var s = n || !i;
                    clearTimeout(i), i = setTimeout(a, e), s && t.apply(r, o)
                }
            },
            toArray: function (t) {
                return t.toArray ? t.toArray() : yh.call(t)
            },
            isUndefined: function (t) {
                return void 0 === t
            },
            isNull: function (t) {
                return null === t
            },
            isNaN: function (t) {
                function e(e) {
                    return t.apply(this, arguments)
                }
                return e.toString = function () {
                    return t.toString()
                }, e
            }((function (t) {
                return isNaN(t)
            })),
            isArray: Array.isArray || function (t) {
                return t.constructor === Array
            },
            isObject: function (t) {
                return t === Object(t)
            },
            isNumber: function (t) {
                return t === t + 0
            },
            isString: function (t) {
                return t === t + ""
            },
            isBoolean: function (t) {
                return !1 === t || !0 === t
            },
            isFunction: function (t) {
                return t instanceof Function
            }
        },
        xh = [{
            litmus: _h.isString,
            conversions: {
                THREE_CHAR_HEX: {
                    read: function (t) {
                        var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                        return null !== e && {
                            space: "HEX",
                            hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                        }
                    },
                    write: vh
                },
                SIX_CHAR_HEX: {
                    read: function (t) {
                        var e = t.match(/^#([A-F0-9]{6})$/i);
                        return null !== e && {
                            space: "HEX",
                            hex: parseInt("0x" + e[1].toString(), 0)
                        }
                    },
                    write: vh
                },
                CSS_RGB: {
                    read: function (t) {
                        var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                        return null !== e && {
                            space: "RGB",
                            r: parseFloat(e[1]),
                            g: parseFloat(e[2]),
                            b: parseFloat(e[3])
                        }
                    },
                    write: vh
                },
                CSS_RGBA: {
                    read: function (t) {
                        var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                        return null !== e && {
                            space: "RGB",
                            r: parseFloat(e[1]),
                            g: parseFloat(e[2]),
                            b: parseFloat(e[3]),
                            a: parseFloat(e[4])
                        }
                    },
                    write: vh
                }
            }
        }, {
            litmus: _h.isNumber,
            conversions: {
                HEX: {
                    read: function (t) {
                        return {
                            space: "HEX",
                            hex: t,
                            conversionName: "HEX"
                        }
                    },
                    write: function (t) {
                        return t.hex
                    }
                }
            }
        }, {
            litmus: _h.isArray,
            conversions: {
                RGB_ARRAY: {
                    read: function (t) {
                        return 3 === t.length && {
                            space: "RGB",
                            r: t[0],
                            g: t[1],
                            b: t[2]
                        }
                    },
                    write: function (t) {
                        return [t.r, t.g, t.b]
                    }
                },
                RGBA_ARRAY: {
                    read: function (t) {
                        return 4 === t.length && {
                            space: "RGB",
                            r: t[0],
                            g: t[1],
                            b: t[2],
                            a: t[3]
                        }
                    },
                    write: function (t) {
                        return [t.r, t.g, t.b, t.a]
                    }
                }
            }
        }, {
            litmus: _h.isObject,
            conversions: {
                RGBA_OBJ: {
                    read: function (t) {
                        return !!(_h.isNumber(t.r) && _h.isNumber(t.g) && _h.isNumber(t.b) && _h.isNumber(t.a)) && {
                            space: "RGB",
                            r: t.r,
                            g: t.g,
                            b: t.b,
                            a: t.a
                        }
                    },
                    write: function (t) {
                        return {
                            r: t.r,
                            g: t.g,
                            b: t.b,
                            a: t.a
                        }
                    }
                },
                RGB_OBJ: {
                    read: function (t) {
                        return !!(_h.isNumber(t.r) && _h.isNumber(t.g) && _h.isNumber(t.b)) && {
                            space: "RGB",
                            r: t.r,
                            g: t.g,
                            b: t.b
                        }
                    },
                    write: function (t) {
                        return {
                            r: t.r,
                            g: t.g,
                            b: t.b
                        }
                    }
                },
                HSVA_OBJ: {
                    read: function (t) {
                        return !!(_h.isNumber(t.h) && _h.isNumber(t.s) && _h.isNumber(t.v) && _h.isNumber(t.a)) && {
                            space: "HSV",
                            h: t.h,
                            s: t.s,
                            v: t.v,
                            a: t.a
                        }
                    },
                    write: function (t) {
                        return {
                            h: t.h,
                            s: t.s,
                            v: t.v,
                            a: t.a
                        }
                    }
                },
                HSV_OBJ: {
                    read: function (t) {
                        return !!(_h.isNumber(t.h) && _h.isNumber(t.s) && _h.isNumber(t.v)) && {
                            space: "HSV",
                            h: t.h,
                            s: t.s,
                            v: t.v
                        }
                    },
                    write: function (t) {
                        return {
                            h: t.h,
                            s: t.s,
                            v: t.v
                        }
                    }
                }
            }
        }],
        bh = void 0,
        wh = void 0,
        Mh = function () {
            wh = !1;
            var t = arguments.length > 1 ? _h.toArray(arguments) : arguments[0];
            return _h.each(xh, (function (e) {
                if (e.litmus(t)) return _h.each(e.conversions, (function (e, n) {
                    if (bh = e.read(t), !1 === wh && !1 !== bh) return wh = bh, bh.conversionName = n, bh.conversion = e, _h.BREAK
                })), _h.BREAK
            })), wh
        },
        Sh = void 0,
        Th = {
            hsv_to_rgb: function (t, e, n) {
                var i = Math.floor(t / 60) % 6,
                    r = t / 60 - Math.floor(t / 60),
                    o = n * (1 - e),
                    a = n * (1 - r * e),
                    s = n * (1 - (1 - r) * e),
                    l = [
                        [n, s, o],
                        [a, n, o],
                        [o, n, s],
                        [o, a, n],
                        [s, o, n],
                        [n, o, a]
                    ][i];
                return {
                    r: 255 * l[0],
                    g: 255 * l[1],
                    b: 255 * l[2]
                }
            },
            rgb_to_hsv: function (t, e, n) {
                var i = Math.min(t, e, n),
                    r = Math.max(t, e, n),
                    o = r - i,
                    a = void 0;
                return 0 === r ? {
                    h: NaN,
                    s: 0,
                    v: 0
                } : (a = t === r ? (e - n) / o : e === r ? 2 + (n - t) / o : 4 + (t - e) / o, (a /= 6) < 0 && (a += 1), {
                    h: 360 * a,
                    s: o / r,
                    v: r / 255
                })
            },
            rgb_to_hex: function (t, e, n) {
                var i = this.hex_with_component(0, 2, t);
                return i = this.hex_with_component(i, 1, e), i = this.hex_with_component(i, 0, n)
            },
            component_from_hex: function (t, e) {
                return t >> 8 * e & 255
            },
            hex_with_component: function (t, e, n) {
                return n << (Sh = 8 * e) | t & ~(255 << Sh)
            }
        },
        Eh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        },
        Ah = function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        },
        Ch = function () {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }
            return function (e, n, i) {
                return n && t(e.prototype, n), i && t(e, i), e
            }
        }(),
        Lh = function t(e, n, i) {
            null === e && (e = Function.prototype);
            var r = Object.getOwnPropertyDescriptor(e, n);
            if (void 0 === r) {
                var o = Object.getPrototypeOf(e);
                return null === o ? void 0 : t(o, n, i)
            }
            if ("value" in r) return r.value;
            var a = r.get;
            return void 0 !== a ? a.call(i) : void 0
        },
        Ph = function (t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
        },
        Rh = function (t, e) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !e || "object" != typeof e && "function" != typeof e ? t : e
        },
        Oh = function () {
            function t() {
                if (Ah(this, t), this.__state = Mh.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
                this.__state.a = this.__state.a || 1
            }
            return Ch(t, [{
                key: "toString",
                value: function () {
                    return vh(this)
                }
            }, {
                key: "toHexString",
                value: function () {
                    return vh(this, !0)
                }
            }, {
                key: "toOriginal",
                value: function () {
                    return this.__state.conversion.write(this)
                }
            }]), t
        }();

    function Dh(t, e, n) {
        Object.defineProperty(t, e, {
            get: function () {
                return "RGB" === this.__state.space || Oh.recalculateRGB(this, e, n), this.__state[e]
            },
            set: function (t) {
                "RGB" !== this.__state.space && (Oh.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = t
            }
        })
    }

    function Ih(t, e) {
        Object.defineProperty(t, e, {
            get: function () {
                return "HSV" === this.__state.space || Oh.recalculateHSV(this), this.__state[e]
            },
            set: function (t) {
                "HSV" !== this.__state.space && (Oh.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t
            }
        })
    }
    Oh.recalculateRGB = function (t, e, n) {
        if ("HEX" === t.__state.space) t.__state[e] = Th.component_from_hex(t.__state.hex, n);
        else {
            if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
            _h.extend(t.__state, Th.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
        }
    }, Oh.recalculateHSV = function (t) {
        var e = Th.rgb_to_hsv(t.r, t.g, t.b);
        _h.extend(t.__state, {
            s: e.s,
            v: e.v
        }), _h.isNaN(e.h) ? _h.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
    }, Oh.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], Dh(Oh.prototype, "r", 2), Dh(Oh.prototype, "g", 1), Dh(Oh.prototype, "b", 0), Ih(Oh.prototype, "h"), Ih(Oh.prototype, "s"), Ih(Oh.prototype, "v"), Object.defineProperty(Oh.prototype, "a", {
        get: function () {
            return this.__state.a
        },
        set: function (t) {
            this.__state.a = t
        }
    }), Object.defineProperty(Oh.prototype, "hex", {
        get: function () {
            return "HEX" !== this.__state.space && (this.__state.hex = Th.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex
        },
        set: function (t) {
            this.__state.space = "HEX", this.__state.hex = t
        }
    });
    var Nh = function () {
            function t(e, n) {
                Ah(this, t), this.initialValue = e[n], this.domElement = document.createElement("div"), this.object = e, this.property = n, this.__onChange = void 0, this.__onFinishChange = void 0
            }
            return Ch(t, [{
                key: "onChange",
                value: function (t) {
                    return this.__onChange = t, this
                }
            }, {
                key: "onFinishChange",
                value: function (t) {
                    return this.__onFinishChange = t, this
                }
            }, {
                key: "setValue",
                value: function (t) {
                    return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
                }
            }, {
                key: "getValue",
                value: function () {
                    return this.object[this.property]
                }
            }, {
                key: "updateDisplay",
                value: function () {
                    return this
                }
            }, {
                key: "isModified",
                value: function () {
                    return this.initialValue !== this.getValue()
                }
            }]), t
        }(),
        kh = {};
    _h.each({
        HTMLEvents: ["change"],
        MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
        KeyboardEvents: ["keydown"]
    }, (function (t, e) {
        _h.each(t, (function (t) {
            kh[t] = e
        }))
    }));
    var zh = /(\d+(\.\d+)?)px/;

    function Bh(t) {
        if ("0" === t || _h.isUndefined(t)) return 0;
        var e = t.match(zh);
        return _h.isNull(e) ? 0 : parseFloat(e[1])
    }
    var Fh = {
            makeSelectable: function (t, e) {
                void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function () {
                    return !1
                } : function () {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
            },
            makeFullscreen: function (t, e, n) {
                var i = n,
                    r = e;
                _h.isUndefined(r) && (r = !0), _h.isUndefined(i) && (i = !0), t.style.position = "absolute", r && (t.style.left = 0, t.style.right = 0), i && (t.style.top = 0, t.style.bottom = 0)
            },
            fakeEvent: function (t, e, n, i) {
                var r = n || {},
                    o = kh[e];
                if (!o) throw new Error("Event type " + e + " not supported.");
                var a = document.createEvent(o);
                switch (o) {
                    case "MouseEvents":
                        var s = r.x || r.clientX || 0,
                            l = r.y || r.clientY || 0;
                        a.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, s, l, !1, !1, !1, !1, 0, null);
                        break;
                    case "KeyboardEvents":
                        var c = a.initKeyboardEvent || a.initKeyEvent;
                        _h.defaults(r, {
                            cancelable: !0,
                            ctrlKey: !1,
                            altKey: !1,
                            shiftKey: !1,
                            metaKey: !1,
                            keyCode: void 0,
                            charCode: void 0
                        }), c(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
                        break;
                    default:
                        a.initEvent(e, r.bubbles || !1, r.cancelable || !0)
                }
                _h.defaults(a, i), t.dispatchEvent(a)
            },
            bind: function (t, e, n, i) {
                var r = i || !1;
                return t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on" + e, n), Fh
            },
            unbind: function (t, e, n, i) {
                var r = i || !1;
                return t.removeEventListener ? t.removeEventListener(e, n, r) : t.detachEvent && t.detachEvent("on" + e, n), Fh
            },
            addClass: function (t, e) {
                if (void 0 === t.className) t.className = e;
                else if (t.className !== e) {
                    var n = t.className.split(/ +/); - 1 === n.indexOf(e) && (n.push(e), t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                }
                return Fh
            },
            removeClass: function (t, e) {
                if (e)
                    if (t.className === e) t.removeAttribute("class");
                    else {
                        var n = t.className.split(/ +/),
                            i = n.indexOf(e); - 1 !== i && (n.splice(i, 1), t.className = n.join(" "))
                    }
                else t.className = void 0;
                return Fh
            },
            hasClass: function (t, e) {
                return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
            },
            getWidth: function (t) {
                var e = getComputedStyle(t);
                return Bh(e["border-left-width"]) + Bh(e["border-right-width"]) + Bh(e["padding-left"]) + Bh(e["padding-right"]) + Bh(e.width)
            },
            getHeight: function (t) {
                var e = getComputedStyle(t);
                return Bh(e["border-top-width"]) + Bh(e["border-bottom-width"]) + Bh(e["padding-top"]) + Bh(e["padding-bottom"]) + Bh(e.height)
            },
            getOffset: function (t) {
                var e = t,
                    n = {
                        left: 0,
                        top: 0
                    };
                if (e.offsetParent)
                    do {
                        n.left += e.offsetLeft, n.top += e.offsetTop, e = e.offsetParent
                    } while (e);
                return n
            },
            isActive: function (t) {
                return t === document.activeElement && (t.type || t.href)
            }
        },
        Uh = function (t) {
            function e(t, n) {
                Ah(this, e);
                var i = Rh(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                    r = i;
                return i.__prev = i.getValue(), i.__checkbox = document.createElement("input"), i.__checkbox.setAttribute("type", "checkbox"), Fh.bind(i.__checkbox, "change", (function () {
                    r.setValue(!r.__prev)
                }), !1), i.domElement.appendChild(i.__checkbox), i.updateDisplay(), i
            }
            return Ph(e, t), Ch(e, [{
                key: "setValue",
                value: function (t) {
                    var n = Lh(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n
                }
            }, {
                key: "updateDisplay",
                value: function () {
                    return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), Lh(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }(Nh),
        Hh = function (t) {
            function e(t, n, i) {
                Ah(this, e);
                var r = Rh(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                    o = i,
                    a = r;
                if (r.__select = document.createElement("select"), _h.isArray(o)) {
                    var s = {};
                    _h.each(o, (function (t) {
                        s[t] = t
                    })), o = s
                }
                return _h.each(o, (function (t, e) {
                    var n = document.createElement("option");
                    n.innerHTML = e, n.setAttribute("value", t), a.__select.appendChild(n)
                })), r.updateDisplay(), Fh.bind(r.__select, "change", (function () {
                    var t = this.options[this.selectedIndex].value;
                    a.setValue(t)
                })), r.domElement.appendChild(r.__select), r
            }
            return Ph(e, t), Ch(e, [{
                key: "setValue",
                value: function (t) {
                    var n = Lh(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n
                }
            }, {
                key: "updateDisplay",
                value: function () {
                    return Fh.isActive(this.__select) ? this : (this.__select.value = this.getValue(), Lh(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
                }
            }]), e
        }(Nh),
        Gh = function (t) {
            function e(t, n) {
                Ah(this, e);
                var i = Rh(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                    r = i;

                function o() {
                    r.setValue(r.__input.value)
                }
                return i.__input = document.createElement("input"), i.__input.setAttribute("type", "text"), Fh.bind(i.__input, "keyup", o), Fh.bind(i.__input, "change", o), Fh.bind(i.__input, "blur", (function () {
                    r.__onFinishChange && r.__onFinishChange.call(r, r.getValue())
                })), Fh.bind(i.__input, "keydown", (function (t) {
                    13 === t.keyCode && this.blur()
                })), i.updateDisplay(), i.domElement.appendChild(i.__input), i
            }
            return Ph(e, t), Ch(e, [{
                key: "updateDisplay",
                value: function () {
                    return Fh.isActive(this.__input) || (this.__input.value = this.getValue()), Lh(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }(Nh);

    function Vh(t) {
        var e = t.toString();
        return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
    }
    var jh = function (t) {
        function e(t, n, i) {
            Ah(this, e);
            var r = Rh(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                o = i || {};
            return r.__min = o.min, r.__max = o.max, r.__step = o.step, _h.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = Vh(r.__impliedStep), r
        }
        return Ph(e, t), Ch(e, [{
            key: "setValue",
            value: function (t) {
                var n = t;
                return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max), void 0 !== this.__step && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step), Lh(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n)
            }
        }, {
            key: "min",
            value: function (t) {
                return this.__min = t, this
            }
        }, {
            key: "max",
            value: function (t) {
                return this.__max = t, this
            }
        }, {
            key: "step",
            value: function (t) {
                return this.__step = t, this.__impliedStep = t, this.__precision = Vh(t), this
            }
        }]), e
    }(Nh);
    var Wh = function (t) {
        function e(t, n, i) {
            Ah(this, e);
            var r = Rh(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, i));
            r.__truncationSuspended = !1;
            var o = r,
                a = void 0;

            function s() {
                o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
            }

            function l(t) {
                var e = a - t.clientY;
                o.setValue(o.getValue() + e * o.__impliedStep), a = t.clientY
            }

            function c() {
                Fh.unbind(window, "mousemove", l), Fh.unbind(window, "mouseup", c), s()
            }
            return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), Fh.bind(r.__input, "change", (function () {
                var t = parseFloat(o.__input.value);
                _h.isNaN(t) || o.setValue(t)
            })), Fh.bind(r.__input, "blur", (function () {
                s()
            })), Fh.bind(r.__input, "mousedown", (function (t) {
                Fh.bind(window, "mousemove", l), Fh.bind(window, "mouseup", c), a = t.clientY
            })), Fh.bind(r.__input, "keydown", (function (t) {
                13 === t.keyCode && (o.__truncationSuspended = !0, this.blur(), o.__truncationSuspended = !1, s())
            })), r.updateDisplay(), r.domElement.appendChild(r.__input), r
        }
        return Ph(e, t), Ch(e, [{
            key: "updateDisplay",
            value: function () {
                var t, n, i;
                return this.__input.value = this.__truncationSuspended ? this.getValue() : (t = this.getValue(), n = this.__precision, i = Math.pow(10, n), Math.round(t * i) / i), Lh(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
            }
        }]), e
    }(jh);

    function qh(t, e, n, i, r) {
        return i + (t - e) / (n - e) * (r - i)
    }
    var Xh = function (t) {
            function e(t, n, i, r, o) {
                Ah(this, e);
                var a = Rh(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
                        min: i,
                        max: r,
                        step: o
                    })),
                    s = a;

                function l(t) {
                    t.preventDefault();
                    var e = s.__background.getBoundingClientRect();
                    return s.setValue(qh(t.clientX, e.left, e.right, s.__min, s.__max)), !1
                }

                function c() {
                    Fh.unbind(window, "mousemove", l), Fh.unbind(window, "mouseup", c), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                }

                function h(t) {
                    var e = t.touches[0].clientX,
                        n = s.__background.getBoundingClientRect();
                    s.setValue(qh(e, n.left, n.right, s.__min, s.__max))
                }

                function u() {
                    Fh.unbind(window, "touchmove", h), Fh.unbind(window, "touchend", u), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                }
                return a.__background = document.createElement("div"), a.__foreground = document.createElement("div"), Fh.bind(a.__background, "mousedown", (function (t) {
                    document.activeElement.blur(), Fh.bind(window, "mousemove", l), Fh.bind(window, "mouseup", c), l(t)
                })), Fh.bind(a.__background, "touchstart", (function (t) {
                    if (1 !== t.touches.length) return;
                    Fh.bind(window, "touchmove", h), Fh.bind(window, "touchend", u), h(t)
                })), Fh.addClass(a.__background, "slider"), Fh.addClass(a.__foreground, "slider-fg"), a.updateDisplay(), a.__background.appendChild(a.__foreground), a.domElement.appendChild(a.__background), a
            }
            return Ph(e, t), Ch(e, [{
                key: "updateDisplay",
                value: function () {
                    var t = (this.getValue() - this.__min) / (this.__max - this.__min);
                    return this.__foreground.style.width = 100 * t + "%", Lh(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }(jh),
        Yh = function (t) {
            function e(t, n, i) {
                Ah(this, e);
                var r = Rh(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
                    o = r;
                return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === i ? "Fire" : i, Fh.bind(r.__button, "click", (function (t) {
                    return t.preventDefault(), o.fire(), !1
                })), Fh.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r
            }
            return Ph(e, t), Ch(e, [{
                key: "fire",
                value: function () {
                    this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                }
            }]), e
        }(Nh),
        Jh = function (t) {
            function e(t, n) {
                Ah(this, e);
                var i = Rh(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
                i.__color = new Oh(i.getValue()), i.__temp = new Oh(0);
                var r = i;
                i.domElement = document.createElement("div"), Fh.makeSelectable(i.domElement, !1), i.__selector = document.createElement("div"), i.__selector.className = "selector", i.__saturation_field = document.createElement("div"), i.__saturation_field.className = "saturation-field", i.__field_knob = document.createElement("div"), i.__field_knob.className = "field-knob", i.__field_knob_border = "2px solid ", i.__hue_knob = document.createElement("div"), i.__hue_knob.className = "hue-knob", i.__hue_field = document.createElement("div"), i.__hue_field.className = "hue-field", i.__input = document.createElement("input"), i.__input.type = "text", i.__input_textShadow = "0 1px 1px ", Fh.bind(i.__input, "keydown", (function (t) {
                    13 === t.keyCode && u.call(this)
                })), Fh.bind(i.__input, "blur", u), Fh.bind(i.__selector, "mousedown", (function () {
                    Fh.addClass(this, "drag").bind(window, "mouseup", (function () {
                        Fh.removeClass(r.__selector, "drag")
                    }))
                })), Fh.bind(i.__selector, "touchstart", (function () {
                    Fh.addClass(this, "drag").bind(window, "touchend", (function () {
                        Fh.removeClass(r.__selector, "drag")
                    }))
                }));
                var o, a = document.createElement("div");

                function s(t) {
                    p(t), Fh.bind(window, "mousemove", p), Fh.bind(window, "touchmove", p), Fh.bind(window, "mouseup", c), Fh.bind(window, "touchend", c)
                }

                function l(t) {
                    f(t), Fh.bind(window, "mousemove", f), Fh.bind(window, "touchmove", f), Fh.bind(window, "mouseup", h), Fh.bind(window, "touchend", h)
                }

                function c() {
                    Fh.unbind(window, "mousemove", p), Fh.unbind(window, "touchmove", p), Fh.unbind(window, "mouseup", c), Fh.unbind(window, "touchend", c), d()
                }

                function h() {
                    Fh.unbind(window, "mousemove", f), Fh.unbind(window, "touchmove", f), Fh.unbind(window, "mouseup", h), Fh.unbind(window, "touchend", h), d()
                }

                function u() {
                    var t = Mh(this.value);
                    !1 !== t ? (r.__color.__state = t, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString()
                }

                function d() {
                    r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal())
                }

                function p(t) {
                    -1 === t.type.indexOf("touch") && t.preventDefault();
                    var e = r.__saturation_field.getBoundingClientRect(),
                        n = t.touches && t.touches[0] || t,
                        i = n.clientX,
                        o = n.clientY,
                        a = (i - e.left) / (e.right - e.left),
                        s = 1 - (o - e.top) / (e.bottom - e.top);
                    return s > 1 ? s = 1 : s < 0 && (s = 0), a > 1 ? a = 1 : a < 0 && (a = 0), r.__color.v = s, r.__color.s = a, r.setValue(r.__color.toOriginal()), !1
                }

                function f(t) {
                    -1 === t.type.indexOf("touch") && t.preventDefault();
                    var e = r.__hue_field.getBoundingClientRect(),
                        n = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);
                    return n > 1 ? n = 1 : n < 0 && (n = 0), r.__color.h = 360 * n, r.setValue(r.__color.toOriginal()), !1
                }
                return _h.extend(i.__selector.style, {
                    width: "122px",
                    height: "102px",
                    padding: "3px",
                    backgroundColor: "#222",
                    boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                }), _h.extend(i.__field_knob.style, {
                    position: "absolute",
                    width: "12px",
                    height: "12px",
                    border: i.__field_knob_border + (i.__color.v < .5 ? "#fff" : "#000"),
                    boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                    borderRadius: "12px",
                    zIndex: 1
                }), _h.extend(i.__hue_knob.style, {
                    position: "absolute",
                    width: "15px",
                    height: "2px",
                    borderRight: "4px solid #fff",
                    zIndex: 1
                }), _h.extend(i.__saturation_field.style, {
                    width: "100px",
                    height: "100px",
                    border: "1px solid #555",
                    marginRight: "3px",
                    display: "inline-block",
                    cursor: "pointer"
                }), _h.extend(a.style, {
                    width: "100%",
                    height: "100%",
                    background: "none"
                }), Qh(a, "top", "rgba(0,0,0,0)", "#000"), _h.extend(i.__hue_field.style, {
                    width: "15px",
                    height: "100px",
                    border: "1px solid #555",
                    cursor: "ns-resize",
                    position: "absolute",
                    top: "3px",
                    right: "3px"
                }), (o = i.__hue_field).style.background = "", o.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", o.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", _h.extend(i.__input.style, {
                    outline: "none",
                    textAlign: "center",
                    color: "#fff",
                    border: 0,
                    fontWeight: "bold",
                    textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)"
                }), Fh.bind(i.__saturation_field, "mousedown", s), Fh.bind(i.__saturation_field, "touchstart", s), Fh.bind(i.__field_knob, "mousedown", s), Fh.bind(i.__field_knob, "touchstart", s), Fh.bind(i.__hue_field, "mousedown", l), Fh.bind(i.__hue_field, "touchstart", l), i.__saturation_field.appendChild(a), i.__selector.appendChild(i.__field_knob), i.__selector.appendChild(i.__saturation_field), i.__selector.appendChild(i.__hue_field), i.__hue_field.appendChild(i.__hue_knob), i.domElement.appendChild(i.__input), i.domElement.appendChild(i.__selector), i.updateDisplay(), i
            }
            return Ph(e, t), Ch(e, [{
                key: "updateDisplay",
                value: function () {
                    var t = Mh(this.getValue());
                    if (!1 !== t) {
                        var e = !1;
                        _h.each(Oh.COMPONENTS, (function (n) {
                            if (!_h.isUndefined(t[n]) && !_h.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n]) return e = !0, {}
                        }), this), e && _h.extend(this.__color.__state, t)
                    }
                    _h.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
                    var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
                        i = 255 - n;
                    _h.extend(this.__field_knob.style, {
                        marginLeft: 100 * this.__color.s - 7 + "px",
                        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                        backgroundColor: this.__temp.toHexString(),
                        border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
                    }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, Qh(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), _h.extend(this.__input.style, {
                        backgroundColor: this.__color.toHexString(),
                        color: "rgb(" + n + "," + n + "," + n + ")",
                        textShadow: this.__input_textShadow + "rgba(" + i + "," + i + "," + i + ",.7)"
                    })
                }
            }]), e
        }(Nh),
        Zh = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

    function Qh(t, e, n, i) {
        t.style.background = "", _h.each(Zh, (function (r) {
            t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + n + " 0%, " + i + " 100%); "
        }))
    }
    var Kh = function (t, e) {
            var n = e || document,
                i = document.createElement("style");
            i.type = "text/css", i.innerHTML = t;
            var r = n.getElementsByTagName("head")[0];
            try {
                r.appendChild(i)
            } catch (t) {}
        },
        $h = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
        tu = function (t, e) {
            var n = t[e];
            return _h.isArray(arguments[2]) || _h.isObject(arguments[2]) ? new Hh(t, e, arguments[2]) : _h.isNumber(n) ? _h.isNumber(arguments[2]) && _h.isNumber(arguments[3]) ? _h.isNumber(arguments[4]) ? new Xh(t, e, arguments[2], arguments[3], arguments[4]) : new Xh(t, e, arguments[2], arguments[3]) : _h.isNumber(arguments[4]) ? new Wh(t, e, {
                min: arguments[2],
                max: arguments[3],
                step: arguments[4]
            }) : new Wh(t, e, {
                min: arguments[2],
                max: arguments[3]
            }) : _h.isString(n) ? new Gh(t, e) : _h.isFunction(n) ? new Yh(t, e, "") : _h.isBoolean(n) ? new Uh(t, e) : null
        };
    var eu = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {
            setTimeout(t, 1e3 / 60)
        },
        nu = function () {
            function t() {
                Ah(this, t), this.backgroundElement = document.createElement("div"), _h.extend(this.backgroundElement.style, {
                    backgroundColor: "rgba(0,0,0,0.8)",
                    top: 0,
                    left: 0,
                    display: "none",
                    zIndex: "1000",
                    opacity: 0,
                    WebkitTransition: "opacity 0.2s linear",
                    transition: "opacity 0.2s linear"
                }), Fh.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), _h.extend(this.domElement.style, {
                    position: "fixed",
                    display: "none",
                    zIndex: "1001",
                    opacity: 0,
                    WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                    transition: "transform 0.2s ease-out, opacity 0.2s linear"
                }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
                var e = this;
                Fh.bind(this.backgroundElement, "click", (function () {
                    e.hide()
                }))
            }
            return Ch(t, [{
                key: "show",
                value: function () {
                    var t = this;
                    this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), _h.defer((function () {
                        t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
                    }))
                }
            }, {
                key: "hide",
                value: function () {
                    var t = this,
                        e = function e() {
                            t.domElement.style.display = "none", t.backgroundElement.style.display = "none", Fh.unbind(t.domElement, "webkitTransitionEnd", e), Fh.unbind(t.domElement, "transitionend", e), Fh.unbind(t.domElement, "oTransitionEnd", e)
                        };
                    Fh.bind(this.domElement, "webkitTransitionEnd", e), Fh.bind(this.domElement, "transitionend", e), Fh.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
                }
            }, {
                key: "layout",
                value: function () {
                    this.domElement.style.left = window.innerWidth / 2 - Fh.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - Fh.getHeight(this.domElement) / 2 + "px"
                }
            }]), t
        }();
    Kh(function (t) {
        if (t && "undefined" != typeof window) {
            var e = document.createElement("style");
            return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t
        }
    }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
    var iu = function () {
            try {
                return !!window.localStorage
            } catch (t) {
                return !1
            }
        }(),
        ru = void 0,
        ou = !0,
        au = void 0,
        su = !1,
        lu = [],
        cu = function t(e) {
            var n = this,
                i = e || {};
            this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), Fh.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], i = _h.defaults(i, {
                closeOnTop: !1,
                autoPlace: !0,
                width: t.DEFAULT_WIDTH
            }), i = _h.defaults(i, {
                resizable: i.autoPlace,
                hideable: i.autoPlace
            }), _h.isUndefined(i.load) ? i.load = {
                preset: "Default"
            } : i.preset && (i.load.preset = i.preset), _h.isUndefined(i.parent) && i.hideable && lu.push(this), i.resizable = _h.isUndefined(i.parent) && i.resizable, i.autoPlace && _h.isUndefined(i.scrollable) && (i.scrollable = !0);
            var r, o = iu && "true" === localStorage.getItem(mu(this, "isLocal")),
                a = void 0,
                s = void 0;
            if (Object.defineProperties(this, {
                    parent: {
                        get: function () {
                            return i.parent
                        }
                    },
                    scrollable: {
                        get: function () {
                            return i.scrollable
                        }
                    },
                    autoPlace: {
                        get: function () {
                            return i.autoPlace
                        }
                    },
                    closeOnTop: {
                        get: function () {
                            return i.closeOnTop
                        }
                    },
                    preset: {
                        get: function () {
                            return n.parent ? n.getRoot().preset : i.load.preset
                        },
                        set: function (t) {
                            n.parent ? n.getRoot().preset = t : i.load.preset = t,
                                function (t) {
                                    for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
                                }(this), n.revert()
                        }
                    },
                    width: {
                        get: function () {
                            return i.width
                        },
                        set: function (t) {
                            i.width = t, xu(n, t)
                        }
                    },
                    name: {
                        get: function () {
                            return i.name
                        },
                        set: function (t) {
                            i.name = t, s && (s.innerHTML = i.name)
                        }
                    },
                    closed: {
                        get: function () {
                            return i.closed
                        },
                        set: function (e) {
                            i.closed = e, i.closed ? Fh.addClass(n.__ul, t.CLASS_CLOSED) : Fh.removeClass(n.__ul, t.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                        }
                    },
                    load: {
                        get: function () {
                            return i.load
                        }
                    },
                    useLocalStorage: {
                        get: function () {
                            return o
                        },
                        set: function (t) {
                            iu && (o = t, t ? Fh.bind(window, "unload", a) : Fh.unbind(window, "unload", a), localStorage.setItem(mu(n, "isLocal"), t))
                        }
                    }
                }), _h.isUndefined(i.parent)) {
                if (this.closed = i.closed || !1, Fh.addClass(this.domElement, t.CLASS_MAIN), Fh.makeSelectable(this.domElement, !1), iu && o) {
                    n.useLocalStorage = !0;
                    var l = localStorage.getItem(mu(this, "gui"));
                    l && (i.load = JSON.parse(l))
                }
                this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, Fh.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), i.closeOnTop ? (Fh.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (Fh.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), Fh.bind(this.__closeButton, "click", (function () {
                    n.closed = !n.closed
                }))
            } else {
                void 0 === i.closed && (i.closed = !0);
                var c = document.createTextNode(i.name);
                Fh.addClass(c, "controller-name"), s = hu(n, c);
                Fh.addClass(this.__ul, t.CLASS_CLOSED), Fh.addClass(s, "title"), Fh.bind(s, "click", (function (t) {
                    return t.preventDefault(), n.closed = !n.closed, !1
                })), i.closed || (this.closed = !1)
            }
            i.autoPlace && (_h.isUndefined(i.parent) && (ou && (au = document.createElement("div"), Fh.addClass(au, "dg"), Fh.addClass(au, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(au), ou = !1), au.appendChild(this.domElement), Fh.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || xu(n, i.width)), this.__resizeHandler = function () {
                n.onResizeDebounced()
            }, Fh.bind(window, "resize", this.__resizeHandler), Fh.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), Fh.bind(this.__ul, "transitionend", this.__resizeHandler), Fh.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), i.resizable && _u(this), a = function () {
                iu && "true" === localStorage.getItem(mu(n, "isLocal")) && localStorage.setItem(mu(n, "gui"), JSON.stringify(n.getSaveObject()))
            }, this.saveToLocalStorageIfPossible = a, i.parent || ((r = n.getRoot()).width += 1, _h.defer((function () {
                r.width -= 1
            })))
        };

    function hu(t, e, n) {
        var i = document.createElement("li");
        return e && i.appendChild(e), n ? t.__ul.insertBefore(i, n) : t.__ul.appendChild(i), t.onResize(), i
    }

    function uu(t) {
        Fh.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && Fh.unbind(window, "unload", t.saveToLocalStorageIfPossible)
    }

    function du(t, e) {
        var n = t.__preset_select[t.__preset_select.selectedIndex];
        n.innerHTML = e ? n.value + "*" : n.value
    }

    function pu(t, e) {
        var n = t.getRoot(),
            i = n.__rememberedObjects.indexOf(e.object);
        if (-1 !== i) {
            var r = n.__rememberedObjectIndecesToControllers[i];
            if (void 0 === r && (r = {}, n.__rememberedObjectIndecesToControllers[i] = r), r[e.property] = e, n.load && n.load.remembered) {
                var o = n.load.remembered,
                    a = void 0;
                if (o[t.preset]) a = o[t.preset];
                else {
                    if (!o.Default) return;
                    a = o.Default
                }
                if (a[i] && void 0 !== a[i][e.property]) {
                    var s = a[i][e.property];
                    e.initialValue = s, e.setValue(s)
                }
            }
        }
    }

    function fu(t, e, n, i) {
        if (void 0 === e[n]) throw new Error('Object "' + e + '" has no property "' + n + '"');
        var r = void 0;
        if (i.color) r = new Jh(e, n);
        else {
            var o = [e, n].concat(i.factoryArgs);
            r = tu.apply(t, o)
        }
        i.before instanceof Nh && (i.before = i.before.__li), pu(t, r), Fh.addClass(r.domElement, "c");
        var a = document.createElement("span");
        Fh.addClass(a, "property-name"), a.innerHTML = r.property;
        var s = document.createElement("div");
        s.appendChild(a), s.appendChild(r.domElement);
        var l = hu(t, s, i.before);
        return Fh.addClass(l, cu.CLASS_CONTROLLER_ROW), r instanceof Jh ? Fh.addClass(l, "color") : Fh.addClass(l, Eh(r.getValue())),
            function (t, e, n) {
                if (n.__li = e, n.__gui = t, _h.extend(n, {
                        options: function (e) {
                            if (arguments.length > 1) {
                                var i = n.__li.nextElementSibling;
                                return n.remove(), fu(t, n.object, n.property, {
                                    before: i,
                                    factoryArgs: [_h.toArray(arguments)]
                                })
                            }
                            if (_h.isArray(e) || _h.isObject(e)) {
                                var r = n.__li.nextElementSibling;
                                return n.remove(), fu(t, n.object, n.property, {
                                    before: r,
                                    factoryArgs: [e]
                                })
                            }
                        },
                        name: function (t) {
                            return n.__li.firstElementChild.firstElementChild.innerHTML = t, n
                        },
                        listen: function () {
                            return n.__gui.listen(n), n
                        },
                        remove: function () {
                            return n.__gui.remove(n), n
                        }
                    }), n instanceof Xh) {
                    var i = new Wh(n.object, n.property, {
                        min: n.__min,
                        max: n.__max,
                        step: n.__step
                    });
                    _h.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function (t) {
                        var e = n[t],
                            r = i[t];
                        n[t] = i[t] = function () {
                            var t = Array.prototype.slice.call(arguments);
                            return r.apply(i, t), e.apply(n, t)
                        }
                    })), Fh.addClass(e, "has-slider"), n.domElement.insertBefore(i.domElement, n.domElement.firstElementChild)
                } else if (n instanceof Wh) {
                    var r = function (e) {
                        if (_h.isNumber(n.__min) && _h.isNumber(n.__max)) {
                            var i = n.__li.firstElementChild.firstElementChild.innerHTML,
                                r = n.__gui.__listening.indexOf(n) > -1;
                            n.remove();
                            var o = fu(t, n.object, n.property, {
                                before: n.__li.nextElementSibling,
                                factoryArgs: [n.__min, n.__max, n.__step]
                            });
                            return o.name(i), r && o.listen(), o
                        }
                        return e
                    };
                    n.min = _h.compose(r, n.min), n.max = _h.compose(r, n.max)
                } else n instanceof Uh ? (Fh.bind(e, "click", (function () {
                    Fh.fakeEvent(n.__checkbox, "click")
                })), Fh.bind(n.__checkbox, "click", (function (t) {
                    t.stopPropagation()
                }))) : n instanceof Yh ? (Fh.bind(e, "click", (function () {
                    Fh.fakeEvent(n.__button, "click")
                })), Fh.bind(e, "mouseover", (function () {
                    Fh.addClass(n.__button, "hover")
                })), Fh.bind(e, "mouseout", (function () {
                    Fh.removeClass(n.__button, "hover")
                }))) : n instanceof Jh && (Fh.addClass(e, "color"), n.updateDisplay = _h.compose((function (t) {
                    return e.style.borderLeftColor = n.__color.toString(), t
                }), n.updateDisplay), n.updateDisplay());
                n.setValue = _h.compose((function (e) {
                    return t.getRoot().__preset_select && n.isModified() && du(t.getRoot(), !0), e
                }), n.setValue)
            }(t, l, r), t.__controllers.push(r), r
    }

    function mu(t, e) {
        return document.location.href + "." + e
    }

    function vu(t, e, n) {
        var i = document.createElement("option");
        i.innerHTML = e, i.value = e, t.__preset_select.appendChild(i), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
    }

    function gu(t, e) {
        e.style.display = t.useLocalStorage ? "block" : "none"
    }

    function yu(t) {
        var e = t.__save_row = document.createElement("li");
        Fh.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), Fh.addClass(e, "save-row");
        var n = document.createElement("span");
        n.innerHTML = "&nbsp;", Fh.addClass(n, "button gears");
        var i = document.createElement("span");
        i.innerHTML = "Save", Fh.addClass(i, "button"), Fh.addClass(i, "save");
        var r = document.createElement("span");
        r.innerHTML = "New", Fh.addClass(r, "button"), Fh.addClass(r, "save-as");
        var o = document.createElement("span");
        o.innerHTML = "Revert", Fh.addClass(o, "button"), Fh.addClass(o, "revert");
        var a = t.__preset_select = document.createElement("select");
        if (t.load && t.load.remembered ? _h.each(t.load.remembered, (function (e, n) {
                vu(t, n, n === t.preset)
            })) : vu(t, "Default", !1), Fh.bind(a, "change", (function () {
                for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                t.preset = this.value
            })), e.appendChild(a), e.appendChild(n), e.appendChild(i), e.appendChild(r), e.appendChild(o), iu) {
            var s = document.getElementById("dg-local-explain"),
                l = document.getElementById("dg-local-storage");
            document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(mu(0, "isLocal")) && l.setAttribute("checked", "checked"), gu(t, s), Fh.bind(l, "change", (function () {
                t.useLocalStorage = !t.useLocalStorage, gu(t, s)
            }))
        }
        var c = document.getElementById("dg-new-constructor");
        Fh.bind(c, "keydown", (function (t) {
            !t.metaKey || 67 !== t.which && 67 !== t.keyCode || ru.hide()
        })), Fh.bind(n, "click", (function () {
            c.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), ru.show(), c.focus(), c.select()
        })), Fh.bind(i, "click", (function () {
            t.save()
        })), Fh.bind(r, "click", (function () {
            var e = prompt("Enter a new preset name.");
            e && t.saveAs(e)
        })), Fh.bind(o, "click", (function () {
            t.revert()
        }))
    }

    function _u(t) {
        var e = void 0;

        function n(n) {
            return n.preventDefault(), t.width += e - n.clientX, t.onResize(), e = n.clientX, !1
        }

        function i() {
            Fh.removeClass(t.__closeButton, cu.CLASS_DRAG), Fh.unbind(window, "mousemove", n), Fh.unbind(window, "mouseup", i)
        }

        function r(r) {
            return r.preventDefault(), e = r.clientX, Fh.addClass(t.__closeButton, cu.CLASS_DRAG), Fh.bind(window, "mousemove", n), Fh.bind(window, "mouseup", i), !1
        }
        t.__resize_handle = document.createElement("div"), _h.extend(t.__resize_handle.style, {
            width: "6px",
            marginLeft: "-3px",
            height: "200px",
            cursor: "ew-resize",
            position: "absolute"
        }), Fh.bind(t.__resize_handle, "mousedown", r), Fh.bind(t.__closeButton, "mousedown", r), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
    }

    function xu(t, e) {
        t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
    }

    function bu(t, e) {
        var n = {};
        return _h.each(t.__rememberedObjects, (function (i, r) {
            var o = {},
                a = t.__rememberedObjectIndecesToControllers[r];
            _h.each(a, (function (t, n) {
                o[n] = e ? t.initialValue : t.getValue()
            })), n[r] = o
        })), n
    }
    cu.toggleHide = function () {
        su = !su, _h.each(lu, (function (t) {
            t.domElement.style.display = su ? "none" : ""
        }))
    }, cu.CLASS_AUTO_PLACE = "a", cu.CLASS_AUTO_PLACE_CONTAINER = "ac", cu.CLASS_MAIN = "main", cu.CLASS_CONTROLLER_ROW = "cr", cu.CLASS_TOO_TALL = "taller-than-window", cu.CLASS_CLOSED = "closed", cu.CLASS_CLOSE_BUTTON = "close-button", cu.CLASS_CLOSE_TOP = "close-top", cu.CLASS_CLOSE_BOTTOM = "close-bottom", cu.CLASS_DRAG = "drag", cu.DEFAULT_WIDTH = 245, cu.TEXT_CLOSED = "Close Controls", cu.TEXT_OPEN = "Open Controls", cu._keydownHandler = function (t) {
        "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || cu.toggleHide()
    }, Fh.bind(window, "keydown", cu._keydownHandler, !1), _h.extend(cu.prototype, {
        add: function (t, e) {
            return fu(this, t, e, {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
            })
        },
        addColor: function (t, e) {
            return fu(this, t, e, {
                color: !0
            })
        },
        remove: function (t) {
            this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
            var e = this;
            _h.defer((function () {
                e.onResize()
            }))
        },
        destroy: function () {
            if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
            this.autoPlace && au.removeChild(this.domElement);
            var t = this;
            _h.each(this.__folders, (function (e) {
                t.removeFolder(e)
            })), Fh.unbind(window, "keydown", cu._keydownHandler, !1), uu(this)
        },
        addFolder: function (t) {
            if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
            var e = {
                name: t,
                parent: this
            };
            e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
            var n = new cu(e);
            this.__folders[t] = n;
            var i = hu(this, n.domElement);
            return Fh.addClass(i, "folder"), n
        },
        removeFolder: function (t) {
            this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], uu(t);
            var e = this;
            _h.each(t.__folders, (function (e) {
                t.removeFolder(e)
            })), _h.defer((function () {
                e.onResize()
            }))
        },
        open: function () {
            this.closed = !1
        },
        close: function () {
            this.closed = !0
        },
        hide: function () {
            this.domElement.style.display = "none"
        },
        show: function () {
            this.domElement.style.display = ""
        },
        onResize: function () {
            var t = this.getRoot();
            if (t.scrollable) {
                var e = Fh.getOffset(t.__ul).top,
                    n = 0;
                _h.each(t.__ul.childNodes, (function (e) {
                    t.autoPlace && e === t.__save_row || (n += Fh.getHeight(e))
                })), window.innerHeight - e - 20 < n ? (Fh.addClass(t.domElement, cu.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (Fh.removeClass(t.domElement, cu.CLASS_TOO_TALL), t.__ul.style.height = "auto")
            }
            t.__resize_handle && _h.defer((function () {
                t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
            })), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
        },
        onResizeDebounced: _h.debounce((function () {
            this.onResize()
        }), 50),
        remember: function () {
            if (_h.isUndefined(ru) && ((ru = new nu).domElement.innerHTML = $h), this.parent) throw new Error("You can only call remember on a top level GUI.");
            var t = this;
            _h.each(Array.prototype.slice.call(arguments), (function (e) {
                0 === t.__rememberedObjects.length && yu(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
            })), this.autoPlace && xu(this, this.width)
        },
        getRoot: function () {
            for (var t = this; t.parent;) t = t.parent;
            return t
        },
        getSaveObject: function () {
            var t = this.load;
            return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = bu(this)), t.folders = {}, _h.each(this.__folders, (function (e, n) {
                t.folders[n] = e.getSaveObject()
            })), t
        },
        save: function () {
            this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = bu(this), du(this, !1), this.saveToLocalStorageIfPossible()
        },
        saveAs: function (t) {
            this.load.remembered || (this.load.remembered = {}, this.load.remembered.Default = bu(this, !0)), this.load.remembered[t] = bu(this), this.preset = t, vu(this, t, !0), this.saveToLocalStorageIfPossible()
        },
        revert: function (t) {
            _h.each(this.__controllers, (function (e) {
                this.getRoot().load.remembered ? pu(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
            }), this), _h.each(this.__folders, (function (t) {
                t.revert(t)
            })), t || du(this.getRoot(), !1)
        },
        listen: function (t) {
            var e = 0 === this.__listening.length;
            this.__listening.push(t), e && function t(e) {
                0 !== e.length && eu.call(window, (function () {
                    t(e)
                }));
                _h.each(e, (function (t) {
                    t.updateDisplay()
                }))
            }(this.__listening)
        },
        updateDisplay: function () {
            _h.each(this.__controllers, (function (t) {
                t.updateDisplay()
            })), _h.each(this.__folders, (function (t) {
                t.updateDisplay()
            }))
        }
    });
    const wu = {
        OG: {
            clrA: [.4, .34, .91],
            clrB: [.49, .96, .13],
            clrC: [.55, .83, .21],
            clrD: [.45, .96, .48]
        },
        default: {
            clrA: [.5, .5, .5],
            clrB: [.5, .5, .5],
            clrC: [1, 1, 1],
            clrD: [0, .1, .2]
        },
        "divergence-studio": {
            clrA: [.88, .5, .68],
            clrB: [.87, .69, .21],
            clrC: [.01, .12, .47],
            clrD: [.84, .92, .97]
        },
        "norman-gabriel": {
            clrA: [1, .75, .99],
            clrB: [.57, .94, .59],
            clrC: [.65, .28, .24],
            clrD: [.65, .74, .79]
        },
        "riso-scotti": {
            clrA: [.66, .51, .37],
            clrB: [1, .68, .13],
            clrC: [.49, .57, .19],
            clrD: [.09, 0, .12]
        },
        "tessileria-cavallini": {
            clrA: [.65, .55, .71],
            clrB: [.54, .72, .38],
            clrC: [.39, .85, .93],
            clrD: [.14, .16, .18]
        }
    };

    function Mu(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Su(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
    }
    /*!
     * GSAP 3.5.1
     * https://greensock.com
     *
     * @license Copyright 2008-2020, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Tu, Eu, Au, Cu, Lu, Pu, Ru, Ou, Du, Iu, Nu, ku, zu, Bu, Fu, Uu, Hu, Gu, Vu, ju, Wu, qu, Xu, Yu = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        Ju = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        Zu = 1e8,
        Qu = 2 * Math.PI,
        Ku = Qu / 4,
        $u = 0,
        td = Math.sqrt,
        ed = Math.cos,
        nd = Math.sin,
        id = function (t) {
            return "string" == typeof t
        },
        rd = function (t) {
            return "function" == typeof t
        },
        od = function (t) {
            return "number" == typeof t
        },
        ad = function (t) {
            return void 0 === t
        },
        sd = function (t) {
            return "object" == typeof t
        },
        ld = function (t) {
            return !1 !== t
        },
        cd = function () {
            return "undefined" != typeof window
        },
        hd = function (t) {
            return rd(t) || id(t)
        },
        ud = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {},
        dd = Array.isArray,
        pd = /(?:-?\.?\d|\.)+/gi,
        fd = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
        md = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        vd = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
        gd = /[+-]=-?[\.\d]+/,
        yd = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
        _d = {},
        xd = {},
        bd = function (t) {
            return (xd = Xd(t, _d)) && Pf
        },
        wd = function (t, e) {
            return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
        },
        Md = function (t, e) {
            return !e && console.warn(t)
        },
        Sd = function (t, e) {
            return t && (_d[t] = e) && xd && (xd[t] = e) || _d
        },
        Td = function () {
            return 0
        },
        Ed = {},
        Ad = [],
        Cd = {},
        Ld = {},
        Pd = {},
        Rd = 30,
        Od = [],
        Dd = "",
        Id = function (t) {
            var e, n, i = t[0];
            if (sd(i) || rd(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                for (n = Od.length; n-- && !Od[n].targetTest(i););
                e = Od[n]
            }
            for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new tf(t[n], e))) || t.splice(n, 1);
            return t
        },
        Nd = function (t) {
            return t._gsap || Id(xp(t))[0]._gsap
        },
        kd = function (t, e, n) {
            return (n = t[e]) && rd(n) ? t[e]() : ad(n) && t.getAttribute && t.getAttribute(e) || n
        },
        zd = function (t, e) {
            return (t = t.split(",")).forEach(e) || t
        },
        Bd = function (t) {
            return Math.round(1e5 * t) / 1e5 || 0
        },
        Fd = function (t, e) {
            for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
            return i < n
        },
        Ud = function (t, e, n) {
            var i, r = od(t[1]),
                o = (r ? 2 : 1) + (e < 2 ? 0 : 1),
                a = t[o];
            if (r && (a.duration = t[1]), a.parent = n, e) {
                for (i = a; n && !("immediateRender" in i);) i = n.vars.defaults || {}, n = ld(n.vars.inherit) && n.parent;
                a.immediateRender = ld(i.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[o - 1]
            }
            return a
        },
        Hd = function () {
            var t, e, n = Ad.length,
                i = Ad.slice(0);
            for (Cd = {}, Ad.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
        },
        Gd = function (t, e, n, i) {
            Ad.length && Hd(), t.render(e, n, i), Ad.length && Hd()
        },
        Vd = function (t) {
            var e = parseFloat(t);
            return (e || 0 === e) && (t + "").match(yd).length < 2 ? e : id(t) ? t.trim() : t
        },
        jd = function (t) {
            return t
        },
        Wd = function (t, e) {
            for (var n in e) n in t || (t[n] = e[n]);
            return t
        },
        qd = function (t, e) {
            for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n])
        },
        Xd = function (t, e) {
            for (var n in e) t[n] = e[n];
            return t
        },
        Yd = function t(e, n) {
            for (var i in n) e[i] = sd(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i];
            return e
        },
        Jd = function (t, e) {
            var n, i = {};
            for (n in t) n in e || (i[n] = t[n]);
            return i
        },
        Zd = function (t) {
            var e = t.parent || Tu,
                n = t.keyframes ? qd : Wd;
            if (ld(t.inherit))
                for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
            return t
        },
        Qd = function (t, e, n, i) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var r = e._prev,
                o = e._next;
            r ? r._next = o : t[n] === e && (t[n] = o), o ? o._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
        },
        Kd = function (t, e) {
            t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
        },
        $d = function (t, e) {
            if (t && (!e || e._end > t._dur || e._start < 0))
                for (var n = t; n;) n._dirty = 1, n = n.parent;
            return t
        },
        tp = function (t) {
            for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
            return t
        },
        ep = function (t) {
            return t._repeat ? np(t._tTime, t = t.duration() + t._rDelay) * t : 0
        },
        np = function (t, e) {
            return (t /= e) && ~~t === t ? ~~t - 1 : ~~t
        },
        ip = function (t, e) {
            return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        },
        rp = function (t) {
            return t._end = Bd(t._start + (t._tDur / Math.abs(t._ts || t._rts || 1e-8) || 0))
        },
        op = function (t, e) {
            var n = t._dp;
            return n && n.smoothChildTiming && t._ts && (t._start = Bd(t._dp._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), rp(t), n._dirty || $d(n, t)), t
        },
        ap = function (t, e) {
            var n;
            if ((e._time || e._initted && !e._dur) && (n = ip(t.rawTime(), e), (!e._dur || mp(0, e.totalDuration(), n) - e._tTime > 1e-8) && e.render(n, !0)), $d(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                if (t._dur < t.duration())
                    for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                t._zTime = -1e-8
            }
        },
        sp = function (t, e, n, i) {
            return e.parent && Kd(e), e._start = Bd(n + e._delay), e._end = Bd(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
                function (t, e, n, i, r) {
                    void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                    var o, a = t[i];
                    if (r)
                        for (o = e[r]; a && a[r] > o;) a = a._prev;
                    a ? (e._next = a._next, a._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = a, e.parent = e._dp = t
                }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, i || ap(t, e), t
        },
        lp = function (t, e) {
            return (_d.ScrollTrigger || wd("scrollTrigger", e)) && _d.ScrollTrigger.create(e, t)
        },
        cp = function (t, e, n, i) {
            return lf(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && Pu !== Hp.frame ? (Ad.push(t), t._lazy = [e, i], 1) : void 0 : 1
        },
        hp = function (t, e, n, i) {
            var r = t._repeat,
                o = Bd(e) || 0,
                a = t._tTime / t._tDur;
            return a && !i && (t._time *= o / t._dur), t._dur = o, t._tDur = r ? r < 0 ? 1e10 : Bd(o * (r + 1) + t._rDelay * r) : o, a && !i ? op(t, t._tTime = t._tDur * a) : t.parent && rp(t), n || $d(t.parent, t), t
        },
        up = function (t) {
            return t instanceof nf ? $d(t) : hp(t, t._dur)
        },
        dp = {
            _start: 0,
            endTime: Td
        },
        pp = function t(e, n) {
            var i, r, o = e.labels,
                a = e._recent || dp,
                s = e.duration() >= Zu ? a.endTime(!1) : e._dur;
            return id(n) && (isNaN(n) || n in o) ? "<" === (i = n.charAt(0)) || ">" === i ? ("<" === i ? a._start : a.endTime(a._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (i = n.indexOf("=")) < 0 ? (n in o || (o[n] = s), o[n]) : (r = +(n.charAt(i - 1) + n.substr(i + 1)), i > 1 ? t(e, n.substr(0, i - 1)) + r : s + r) : null == n ? s : +n
        },
        fp = function (t, e) {
            return t || 0 === t ? e(t) : e
        },
        mp = function (t, e, n) {
            return n < t ? t : n > e ? e : n
        },
        vp = function (t) {
            return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t) ? t : ""
        },
        gp = [].slice,
        yp = function (t, e) {
            return t && sd(t) && "length" in t && (!e && !t.length || t.length - 1 in t && sd(t[0])) && !t.nodeType && t !== Eu
        },
        _p = function (t, e, n) {
            return void 0 === n && (n = []), t.forEach((function (t) {
                var i;
                return id(t) && !e || yp(t, 1) ? (i = n).push.apply(i, xp(t)) : n.push(t)
            })) || n
        },
        xp = function (t, e) {
            return !id(t) || e || !Au && Gp() ? dd(t) ? _p(t, e) : yp(t) ? gp.call(t, 0) : t ? [t] : [] : gp.call(Cu.querySelectorAll(t), 0)
        },
        bp = function (t) {
            return t.sort((function () {
                return .5 - Math.random()
            }))
        },
        wp = function (t) {
            if (rd(t)) return t;
            var e = sd(t) ? t : {
                    each: t
                },
                n = Jp(e.ease),
                i = e.from || 0,
                r = parseFloat(e.base) || 0,
                o = {},
                a = i > 0 && i < 1,
                s = isNaN(i) || a,
                l = e.axis,
                c = i,
                h = i;
            return id(i) ? c = h = {
                    center: .5,
                    edges: .5,
                    end: 1
                } [i] || 0 : !a && s && (c = i[0], h = i[1]),
                function (t, a, u) {
                    var d, p, f, m, v, g, y, _, x, b = (u || e).length,
                        w = o[b];
                    if (!w) {
                        if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, Zu])[1])) {
                            for (y = -Zu; y < (y = u[x++].getBoundingClientRect().left) && x < b;);
                            x--
                        }
                        for (w = o[b] = [], d = s ? Math.min(x, b) * c - .5 : i % x, p = s ? b * h / x - .5 : i / x | 0, y = 0, _ = Zu, g = 0; g < b; g++) f = g % x - d, m = p - (g / x | 0), w[g] = v = l ? Math.abs("y" === l ? m : f) : td(f * f + m * m), v > y && (y = v), v < _ && (_ = v);
                        "random" === i && bp(w), w.max = y - _, w.min = _, w.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === i ? -1 : 1), w.b = b < 0 ? r - b : r, w.u = vp(e.amount || e.each) || 0, n = n && b < 0 ? Xp(n) : n
                    }
                    return b = (w[t] - w.min) / w.max || 0, Bd(w.b + (n ? n(b) : b) * w.v) + w.u
                }
        },
        Mp = function (t) {
            var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
            return function (n) {
                return Math.floor(Math.round(parseFloat(n) / t) * t * e) / e + (od(n) ? 0 : vp(n))
            }
        },
        Sp = function (t, e) {
            var n, i, r = dd(t);
            return !r && sd(t) && (n = r = t.radius || Zu, t.values ? (t = xp(t.values), (i = !od(t[0])) && (n *= n)) : t = Mp(t.increment)), fp(e, r ? rd(t) ? function (e) {
                return i = t(e), Math.abs(i - e) <= n ? i : e
            } : function (e) {
                for (var r, o, a = parseFloat(i ? e.x : e), s = parseFloat(i ? e.y : 0), l = Zu, c = 0, h = t.length; h--;)(r = i ? (r = t[h].x - a) * r + (o = t[h].y - s) * o : Math.abs(t[h] - a)) < l && (l = r, c = h);
                return c = !n || l <= n ? t[c] : e, i || c === e || od(e) ? c : c + vp(e)
            } : Mp(t))
        },
        Tp = function (t, e, n, i) {
            return fp(dd(t) ? !e : !0 === n ? !!(n = 0) : !i, (function () {
                return dd(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / n) * n * i) / i
            }))
        },
        Ep = function (t, e, n) {
            return fp(n, (function (n) {
                return t[~~e(n)]
            }))
        },
        Ap = function (t) {
            for (var e, n, i, r, o = 0, a = ""; ~(e = t.indexOf("random(", o));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? yd : pd), a += t.substr(o, e - o) + Tp(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), o = i + 1;
            return a + t.substr(o, t.length - o)
        },
        Cp = function (t, e, n, i, r) {
            var o = e - t,
                a = i - n;
            return fp(r, (function (e) {
                return n + ((e - t) / o * a || 0)
            }))
        },
        Lp = function (t, e, n) {
            var i, r, o, a = t.labels,
                s = Zu;
            for (i in a)(r = a[i] - e) < 0 == !!n && r && s > (r = Math.abs(r)) && (o = i, s = r);
            return o
        },
        Pp = function (t, e, n) {
            var i, r, o = t.vars,
                a = o[e];
            if (a) return i = o[e + "Params"], r = o.callbackScope || t, n && Ad.length && Hd(), i ? a.apply(r, i) : a.call(r)
        },
        Rp = function (t) {
            return Kd(t), t.progress() < 1 && Pp(t, "onInterrupt"), t
        },
        Op = function (t) {
            var e = (t = !t.name && t.default || t).name,
                n = rd(t),
                i = e && !n && t.init ? function () {
                    this._props = []
                } : t,
                r = {
                    init: Td,
                    render: bf,
                    add: af,
                    kill: Mf,
                    modifier: wf,
                    rawVars: 0
                },
                o = {
                    targetTest: 0,
                    get: 0,
                    getSetter: gf,
                    aliases: {},
                    register: 0
                };
            if (Gp(), t !== i) {
                if (Ld[e]) return;
                Wd(i, Wd(Jd(t, r), o)), Xd(i.prototype, Xd(r, Jd(t, o))), Ld[i.prop = e] = i, t.targetTest && (Od.push(i), Ed[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
            }
            Sd(e, i), t.register && t.register(Pf, i, Ef)
        },
        Dp = {
            aqua: [0, 255, 255],
            lime: [0, 255, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, 255],
            navy: [0, 0, 128],
            white: [255, 255, 255],
            olive: [128, 128, 0],
            yellow: [255, 255, 0],
            orange: [255, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [255, 0, 0],
            pink: [255, 192, 203],
            cyan: [0, 255, 255],
            transparent: [255, 255, 255, 0]
        },
        Ip = function (t, e, n) {
            return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0
        },
        Np = function (t, e, n) {
            var i, r, o, a, s, l, c, h, u, d, p = t ? od(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : Dp.black;
            if (!p) {
                if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Dp[t]) p = Dp[t];
                else if ("#" === t.charAt(0)) 4 === t.length && (i = t.charAt(1), r = t.charAt(2), o = t.charAt(3), t = "#" + i + i + r + r + o + o), p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                else if ("hsl" === t.substr(0, 3))
                    if (p = d = t.match(pd), e) {
                        if (~t.indexOf("=")) return p = t.match(fd), n && p.length < 4 && (p[3] = 1), p
                    } else a = +p[0] % 360 / 360, s = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (s + 1) : l + s - l * s), p.length > 3 && (p[3] *= 1), p[0] = Ip(a + 1 / 3, i, r), p[1] = Ip(a, i, r), p[2] = Ip(a - 1 / 3, i, r);
                else p = t.match(pd) || Dp.transparent;
                p = p.map(Number)
            }
            return e && !d && (i = p[0] / 255, r = p[1] / 255, o = p[2] / 255, l = ((c = Math.max(i, r, o)) + (h = Math.min(i, r, o))) / 2, c === h ? a = s = 0 : (u = c - h, s = l > .5 ? u / (2 - c - h) : u / (c + h), a = c === i ? (r - o) / u + (r < o ? 6 : 0) : c === r ? (o - i) / u + 2 : (i - r) / u + 4, a *= 60), p[0] = ~~(a + .5), p[1] = ~~(100 * s + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p
        },
        kp = function (t) {
            var e = [],
                n = [],
                i = -1;
            return t.split(Bp).forEach((function (t) {
                var r = t.match(md) || [];
                e.push.apply(e, r), n.push(i += r.length + 1)
            })), e.c = n, e
        },
        zp = function (t, e, n) {
            var i, r, o, a, s = "",
                l = (t + s).match(Bp),
                c = e ? "hsla(" : "rgba(",
                h = 0;
            if (!l) return t;
            if (l = l.map((function (t) {
                    return (t = Np(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                })), n && (o = kp(t), (i = n.c).join(s) !== o.c.join(s)))
                for (a = (r = t.replace(Bp, "1").split(md)).length - 1; h < a; h++) s += r[h] + (~i.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (o.length ? o : l.length ? l : n).shift());
            if (!r)
                for (a = (r = t.split(Bp)).length - 1; h < a; h++) s += r[h] + l[h];
            return s + r[a]
        },
        Bp = function () {
            var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
            for (t in Dp) e += "|" + t + "\\b";
            return new RegExp(e + ")", "gi")
        }(),
        Fp = /hsl[a]?\(/,
        Up = function (t) {
            var e, n = t.join(" ");
            if (Bp.lastIndex = 0, Bp.test(n)) return e = Fp.test(n), t[1] = zp(t[1], e), t[0] = zp(t[0], e, kp(t[1])), !0
        },
        Hp = (Fu = Date.now, Uu = 500, Hu = 33, Gu = Fu(), Vu = Gu, Wu = ju = 1e3 / 240, Xu = function t(e) {
            var n, i, r, o, a = Fu() - Vu,
                s = !0 === e;
            if (a > Uu && (Gu += a - Hu), ((n = (r = (Vu += a) - Gu) - Wu) > 0 || s) && (o = ++ku.frame, zu = r - 1e3 * ku.time, ku.time = r /= 1e3, Wu += n + (n >= ju ? 4 : ju - n), i = 1), s || (Du = Iu(t)), i)
                for (Bu = 0; Bu < qu.length; Bu++) qu[Bu](r, zu, o, e)
        }, ku = {
            time: 0,
            frame: 0,
            tick: function () {
                Xu(!0)
            },
            deltaRatio: function (t) {
                return zu / (1e3 / (t || 60))
            },
            wake: function () {
                Lu && (!Au && cd() && (Eu = Au = window, Cu = Eu.document || {}, _d.gsap = Pf, (Eu.gsapVersions || (Eu.gsapVersions = [])).push(Pf.version), bd(xd || Eu.GreenSockGlobals || !Eu.gsap && Eu || {}), Nu = Eu.requestAnimationFrame), Du && ku.sleep(), Iu = Nu || function (t) {
                    return setTimeout(t, Wu - 1e3 * ku.time + 1 | 0)
                }, Ou = 1, Xu(2))
            },
            sleep: function () {
                (Nu ? Eu.cancelAnimationFrame : clearTimeout)(Du), Ou = 0, Iu = Td
            },
            lagSmoothing: function (t, e) {
                Uu = t || 1 / 1e-8, Hu = Math.min(e, Uu, 0)
            },
            fps: function (t) {
                ju = 1e3 / (t || 240), Wu = 1e3 * ku.time + ju
            },
            add: function (t) {
                qu.indexOf(t) < 0 && qu.push(t), Gp()
            },
            remove: function (t) {
                var e;
                ~(e = qu.indexOf(t)) && qu.splice(e, 1) && Bu >= e && Bu--
            },
            _listeners: qu = []
        }),
        Gp = function () {
            return !Ou && Hp.wake()
        },
        Vp = {},
        jp = /^[\d.\-M][\d.\-,\s]/,
        Wp = /["']/g,
        qp = function (t) {
            for (var e, n, i, r = {}, o = t.substr(1, t.length - 3).split(":"), a = o[0], s = 1, l = o.length; s < l; s++) n = o[s], e = s !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[a] = isNaN(i) ? i.replace(Wp, "").trim() : +i, a = n.substr(e + 1).trim();
            return r
        },
        Xp = function (t) {
            return function (e) {
                return 1 - t(1 - e)
            }
        },
        Yp = function t(e, n) {
            for (var i, r = e._first; r;) r instanceof nf ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
        },
        Jp = function (t, e) {
            return t && (rd(t) ? t : Vp[t] || function (t) {
                var e, n, i, r, o = (t + "").split("("),
                    a = Vp[o[0]];
                return a && o.length > 1 && a.config ? a.config.apply(null, ~t.indexOf("{") ? [qp(o[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(Vd)) : Vp._CE && jp.test(t) ? Vp._CE("", t) : a
            }(t)) || e
        },
        Zp = function (t, e, n, i) {
            void 0 === n && (n = function (t) {
                return 1 - e(1 - t)
            }), void 0 === i && (i = function (t) {
                return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
            });
            var r, o = {
                easeIn: e,
                easeOut: n,
                easeInOut: i
            };
            return zd(t, (function (t) {
                for (var e in Vp[t] = _d[t] = o, Vp[r = t.toLowerCase()] = n, o) Vp[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Vp[t + "." + e] = o[e]
            })), o
        },
        Qp = function (t) {
            return function (e) {
                return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
            }
        },
        Kp = function t(e, n, i) {
            var r = n >= 1 ? n : 1,
                o = (i || (e ? .3 : .45)) / (n < 1 ? n : 1),
                a = o / Qu * (Math.asin(1 / r) || 0),
                s = function (t) {
                    return 1 === t ? 1 : r * Math.pow(2, -10 * t) * nd((t - a) * o) + 1
                },
                l = "out" === e ? s : "in" === e ? function (t) {
                    return 1 - s(1 - t)
                } : Qp(s);
            return o = Qu / o, l.config = function (n, i) {
                return t(e, n, i)
            }, l
        },
        $p = function t(e, n) {
            void 0 === n && (n = 1.70158);
            var i = function (t) {
                    return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                },
                r = "out" === e ? i : "in" === e ? function (t) {
                    return 1 - i(1 - t)
                } : Qp(i);
            return r.config = function (n) {
                return t(e, n)
            }, r
        };
    zd("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
            var n = e < 5 ? e + 1 : e;
            Zp(t + ",Power" + (n - 1), e ? function (t) {
                return Math.pow(t, n)
            } : function (t) {
                return t
            }, (function (t) {
                return 1 - Math.pow(1 - t, n)
            }), (function (t) {
                return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
            }))
        })), Vp.Linear.easeNone = Vp.none = Vp.Linear.easeIn, Zp("Elastic", Kp("in"), Kp("out"), Kp()),
        function (t, e) {
            var n = 1 / e,
                i = function (i) {
                    return i < n ? t * i * i : i < .7272727272727273 ? t * Math.pow(i - 1.5 / e, 2) + .75 : i < .9090909090909092 ? t * (i -= 2.25 / e) * i + .9375 : t * Math.pow(i - 2.625 / e, 2) + .984375
                };
            Zp("Bounce", (function (t) {
                return 1 - i(1 - t)
            }), i)
        }(7.5625, 2.75), Zp("Expo", (function (t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        })), Zp("Circ", (function (t) {
            return -(td(1 - t * t) - 1)
        })), Zp("Sine", (function (t) {
            return 1 === t ? 1 : 1 - ed(t * Ku)
        })), Zp("Back", $p("in"), $p("out"), $p()), Vp.SteppedEase = Vp.steps = _d.SteppedEase = {
            config: function (t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t,
                    i = t + (e ? 0 : 1),
                    r = e ? 1 : 0;
                return function (t) {
                    return ((i * mp(0, 1 - 1e-8, t) | 0) + r) * n
                }
            }
        }, Ju.ease = Vp["quad.out"], zd("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
            return Dd += t + "," + t + "Params,"
        }));
    var tf = function (t, e) {
            this.id = $u++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : kd, this.set = e ? e.getSetter : gf
        },
        ef = function () {
            function t(t, e) {
                var n = t.parent || Tu;
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, hp(this, +t.duration, 1, 1), this.data = t.data, Ou || Hp.wake(), n && sp(n, this, e || 0 === e ? e : n._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
            }
            var e = t.prototype;
            return e.delay = function (t) {
                return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
            }, e.duration = function (t) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }, e.totalDuration = function (t) {
                return arguments.length ? (this._dirty = 0, hp(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, e.totalTime = function (t, e) {
                if (Gp(), !arguments.length) return this._tTime;
                var n = this._dp;
                if (n && n.smoothChildTiming && this._ts) {
                    for (op(this, t); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && sp(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && 1e-8 === Math.abs(this._zTime) || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), Gd(this, t, e)), this
            }, e.time = function (t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + ep(this)) % this._dur || (t ? this._dur : 0), e) : this._time
            }, e.totalProgress = function (t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }, e.progress = function (t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + ep(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }, e.iteration = function (t, e) {
                var n = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? np(this._tTime, n) + 1 : 1
            }, e.timeScale = function (t) {
                if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === t) return this;
                var e = this.parent && this._ts ? ip(this.parent._time, this) : this._tTime;
                return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, tp(this.totalTime(mp(-this._delay, this._tDur, e), !0))
            }, e.paused = function (t) {
                return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Gp(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= 1e-8) && 1e-8 !== Math.abs(this._zTime)))), this) : this._ps
            }, e.startTime = function (t) {
                if (arguments.length) {
                    this._start = t;
                    var e = this.parent || this._dp;
                    return e && (e._sort || !this.parent) && sp(e, this, t - this._delay), this
                }
                return this._start
            }, e.endTime = function (t) {
                return this._start + (ld(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
            }, e.rawTime = function (t) {
                var e = this.parent || this._dp;
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ip(e.rawTime(t), this) : this._tTime : this._tTime
            }, e.globalTime = function (t) {
                for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp;
                return n
            }, e.repeat = function (t) {
                return arguments.length ? (this._repeat = t, up(this)) : this._repeat
            }, e.repeatDelay = function (t) {
                return arguments.length ? (this._rDelay = t, up(this)) : this._rDelay
            }, e.yoyo = function (t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, e.seek = function (t, e) {
                return this.totalTime(pp(this, t), ld(e))
            }, e.restart = function (t, e) {
                return this.play().totalTime(t ? -this._delay : 0, ld(e))
            }, e.play = function (t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, e.reverse = function (t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, e.pause = function (t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, e.resume = function () {
                return this.paused(!1)
            }, e.reversed = function (t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
            }, e.invalidate = function () {
                return this._initted = 0, this._zTime = -1e-8, this
            }, e.isActive = function () {
                var t, e = this.parent || this._dp,
                    n = this._start;
                return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - 1e-8))
            }, e.eventCallback = function (t, e, n) {
                var i = this.vars;
                return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
            }, e.then = function (t) {
                var e = this;
                return new Promise((function (n) {
                    var i = rd(t) ? t : jd,
                        r = function () {
                            var t = e.then;
                            e.then = null, rd(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                        };
                    e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                }))
            }, e.kill = function () {
                Rp(this)
            }, t
        }();
    Wd(ef.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var nf = function (t) {
        function e(e, n) {
            var i;
            return void 0 === e && (e = {}), (i = t.call(this, e, n) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = ld(e.sortChildren), i.parent && ap(i.parent, Mu(i)), e.scrollTrigger && lp(Mu(i), e.scrollTrigger), i
        }
        Su(e, t);
        var n = e.prototype;
        return n.to = function (t, e, n) {
            return new df(t, Ud(arguments, 0, this), pp(this, od(e) ? arguments[3] : n)), this
        }, n.from = function (t, e, n) {
            return new df(t, Ud(arguments, 1, this), pp(this, od(e) ? arguments[3] : n)), this
        }, n.fromTo = function (t, e, n, i) {
            return new df(t, Ud(arguments, 2, this), pp(this, od(e) ? arguments[4] : i)), this
        }, n.set = function (t, e, n) {
            return e.duration = 0, e.parent = this, Zd(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new df(t, e, pp(this, n), 1), this
        }, n.call = function (t, e, n) {
            return sp(this, df.delayedCall(0, t, e), pp(this, n))
        }, n.staggerTo = function (t, e, n, i, r, o, a) {
            return n.duration = e, n.stagger = n.stagger || i, n.onComplete = o, n.onCompleteParams = a, n.parent = this, new df(t, n, pp(this, r)), this
        }, n.staggerFrom = function (t, e, n, i, r, o, a) {
            return n.runBackwards = 1, Zd(n).immediateRender = ld(n.immediateRender), this.staggerTo(t, e, n, i, r, o, a)
        }, n.staggerFromTo = function (t, e, n, i, r, o, a, s) {
            return i.startAt = n, Zd(i).immediateRender = ld(i.immediateRender), this.staggerTo(t, e, i, r, o, a, s)
        }, n.render = function (t, e, n) {
            var i, r, o, a, s, l, c, h, u, d, p, f, m = this._time,
                v = this._dirty ? this.totalDuration() : this._tDur,
                g = this._dur,
                y = this !== Tu && t > v - 1e-8 && t >= 0 ? v : t < 1e-8 ? 0 : t,
                _ = this._zTime < 0 != t < 0 && (this._initted || !g);
            if (y !== this._tTime || n || _) {
                if (m !== this._time && g && (y += this._time - m, t += this._time - m), i = y, u = this._start, l = !(h = this._ts), _ && (g || (m = this._zTime), (t || !e) && (this._zTime = t)), this._repeat && (p = this._yoyo, s = g + this._rDelay, i = Bd(y % s), y === v ? (a = this._repeat, i = g) : ((a = ~~(y / s)) && a === y / s && (i = g, a--), i > g && (i = g)), d = np(this._tTime, s), !m && this._tTime && d !== a && (d = a), p && 1 & a && (i = g - i, f = 1), a !== d && !this._lock)) {
                    var x = p && 1 & d,
                        b = x === (p && 1 & a);
                    if (a < d && (x = !x), m = x ? 0 : g, this._lock = 1, this.render(m || (f ? 0 : Bd(a * s)), e, !g)._lock = 0, !e && this.parent && Pp(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m !== this._time || l !== !this._ts) return this;
                    if (g = this._dur, v = this._tDur, b && (this._lock = 2, m = x ? g : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                    Yp(this, f)
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (c = function (t, e, n) {
                        var i;
                        if (n > e)
                            for (i = t._first; i && i._start <= n;) {
                                if (!i._dur && "isPause" === i.data && i._start > e) return i;
                                i = i._next
                            } else
                                for (i = t._last; i && i._start >= n;) {
                                    if (!i._dur && "isPause" === i.data && i._start < e) return i;
                                    i = i._prev
                                }
                    }(this, Bd(m), Bd(i))) && (y -= i - (i = c._start)), this._tTime = y, this._time = i, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), !m && i && !e && Pp(this, "onStart"), i >= m && t >= 0)
                    for (r = this._first; r;) {
                        if (o = r._next, (r._act || i >= r._start) && r._ts && c !== r) {
                            if (r.parent !== this) return this.render(t, e, n);
                            if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                c = 0, o && (y += this._zTime = -1e-8);
                                break
                            }
                        }
                        r = o
                    } else {
                        r = this._last;
                        for (var w = t < 0 ? t : i; r;) {
                            if (o = r._prev, (r._act || w <= r._end) && r._ts && c !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (w - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (w - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                    c = 0, o && (y += this._zTime = w ? -1e-8 : 1e-8);
                                    break
                                }
                            }
                            r = o
                        }
                    }
                if (c && !e && (this.pause(), c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1, this._ts)) return this._start = u, rp(this), this.render(t, e, n);
                this._onUpdate && !e && Pp(this, "onUpdate", !0), (y === v && v >= this.totalDuration() || !y && m) && (u !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((t || !g) && (y === v && this._ts > 0 || !y && this._ts < 0) && Kd(this, 1), e || t < 0 && !m || !y && !m || (Pp(this, y === v ? "onComplete" : "onReverseComplete", !0), this._prom && !(y < v && this.timeScale() > 0) && this._prom())))
            }
            return this
        }, n.add = function (t, e) {
            var n = this;
            if (od(e) || (e = pp(this, e)), !(t instanceof ef)) {
                if (dd(t)) return t.forEach((function (t) {
                    return n.add(t, e)
                })), this;
                if (id(t)) return this.addLabel(t, e);
                if (!rd(t)) return this;
                t = df.delayedCall(0, t)
            }
            return this !== t ? sp(this, t, e) : this
        }, n.getChildren = function (t, e, n, i) {
            void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -Zu);
            for (var r = [], o = this._first; o;) o._start >= i && (o instanceof df ? e && r.push(o) : (n && r.push(o), t && r.push.apply(r, o.getChildren(!0, e, n)))), o = o._next;
            return r
        }, n.getById = function (t) {
            for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                if (e[n].vars.id === t) return e[n]
        }, n.remove = function (t) {
            return id(t) ? this.removeLabel(t) : rd(t) ? this.killTweensOf(t) : (Qd(this, t), t === this._recent && (this._recent = this._last), $d(this))
        }, n.totalTime = function (e, n) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Bd(Hp.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
        }, n.addLabel = function (t, e) {
            return this.labels[t] = pp(this, e), this
        }, n.removeLabel = function (t) {
            return delete this.labels[t], this
        }, n.addPause = function (t, e, n) {
            var i = df.delayedCall(0, e || Td, n);
            return i.data = "isPause", this._hasPause = 1, sp(this, i, pp(this, t))
        }, n.removePause = function (t) {
            var e = this._first;
            for (t = pp(this, t); e;) e._start === t && "isPause" === e.data && Kd(e), e = e._next
        }, n.killTweensOf = function (t, e, n) {
            for (var i = this.getTweensOf(t, n), r = i.length; r--;) rf !== i[r] && i[r].kill(t, e);
            return this
        }, n.getTweensOf = function (t, e) {
            for (var n, i = [], r = xp(t), o = this._first, a = od(e); o;) o instanceof df ? Fd(o._targets, r) && (a ? (!rf || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && i.push(o) : (n = o.getTweensOf(r, e)).length && i.push.apply(i, n), o = o._next;
            return i
        }, n.tweenTo = function (t, e) {
            e = e || {};
            var n = this,
                i = pp(n, t),
                r = e,
                o = r.startAt,
                a = r.onStart,
                s = r.onStartParams,
                l = df.to(n, Wd(e, {
                    ease: "none",
                    lazy: !1,
                    time: i,
                    overwrite: "auto",
                    duration: e.duration || Math.abs((i - (o && "time" in o ? o.time : n._time)) / n.timeScale()) || 1e-8,
                    onStart: function () {
                        n.pause();
                        var t = e.duration || Math.abs((i - n._time) / n.timeScale());
                        l._dur !== t && hp(l, t, 0, 1).render(l._time, !0, !0), a && a.apply(l, s || [])
                    }
                }));
            return l
        }, n.tweenFromTo = function (t, e, n) {
            return this.tweenTo(e, Wd({
                startAt: {
                    time: pp(this, t)
                }
            }, n))
        }, n.recent = function () {
            return this._recent
        }, n.nextLabel = function (t) {
            return void 0 === t && (t = this._time), Lp(this, pp(this, t))
        }, n.previousLabel = function (t) {
            return void 0 === t && (t = this._time), Lp(this, pp(this, t), 1)
        }, n.currentLabel = function (t) {
            return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + 1e-8)
        }, n.shiftChildren = function (t, e, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, o = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
            if (e)
                for (i in o) o[i] >= n && (o[i] += t);
            return $d(this)
        }, n.invalidate = function () {
            var e = this._first;
            for (this._lock = 0; e;) e.invalidate(), e = e._next;
            return t.prototype.invalidate.call(this)
        }, n.clear = function (t) {
            void 0 === t && (t = !0);
            for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
            return this._time = this._tTime = this._pTime = 0, t && (this.labels = {}), $d(this)
        }, n.totalDuration = function (t) {
            var e, n, i, r = 0,
                o = this,
                a = o._last,
                s = Zu;
            if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
            if (o._dirty) {
                for (i = o.parent; a;) e = a._prev, a._dirty && a.totalDuration(), (n = a._start) > s && o._sort && a._ts && !o._lock ? (o._lock = 1, sp(o, a, n - a._delay, 1)._lock = 0) : s = n, n < 0 && a._ts && (r -= n, (!i && !o._dp || i && i.smoothChildTiming) && (o._start += n / o._ts, o._time -= n, o._tTime -= n), o.shiftChildren(-n, !1, -Infinity), s = 0), a._end > r && a._ts && (r = a._end), a = e;
                hp(o, o === Tu && o._time > r ? o._time : r, 1, 1), o._dirty = 0
            }
            return o._tDur
        }, e.updateRoot = function (t) {
            if (Tu._ts && (Gd(Tu, ip(t, Tu)), Pu = Hp.frame), Hp.frame >= Rd) {
                Rd += Yu.autoSleep || 120;
                var e = Tu._first;
                if ((!e || !e._ts) && Yu.autoSleep && Hp._listeners.length < 2) {
                    for (; e && !e._ts;) e = e._next;
                    e || Hp.sleep()
                }
            }
        }, e
    }(ef);
    Wd(nf.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var rf, of = function (t, e, n, i, r, o, a) {
            var s, l, c, h, u, d, p, f, m = new Ef(this._pt, t, e, 0, 1, xf, null, r),
                v = 0,
                g = 0;
            for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = Ap(i)), o && (o(f = [n, i], t, e), n = f[0], i = f[1]), l = n.match(vd) || []; s = vd.exec(i);) h = s[0], u = i.substring(v, s.index), c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1), h !== l[g++] && (d = parseFloat(l[g - 1]) || 0, m._pt = {
                _next: m._pt,
                p: u || 1 === g ? u : ",",
                s: d,
                c: "=" === h.charAt(1) ? parseFloat(h.substr(2)) * ("-" === h.charAt(0) ? -1 : 1) : parseFloat(h) - d,
                m: c && c < 4 ? Math.round : 0
            }, v = vd.lastIndex);
            return m.c = v < i.length ? i.substring(v, i.length) : "", m.fp = a, (gd.test(i) || p) && (m.e = 0), this._pt = m, m
        },
        af = function (t, e, n, i, r, o, a, s, l) {
            rd(i) && (i = i(r || 0, t, o));
            var c, h = t[e],
                u = "get" !== n ? n : rd(h) ? l ? t[e.indexOf("set") || !rd(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : h,
                d = rd(h) ? l ? mf : ff : pf;
            if (id(i) && (~i.indexOf("random(") && (i = Ap(i)), "=" === i.charAt(1) && (i = parseFloat(u) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (vp(u) || 0))), u !== i) return isNaN(u * i) ? (!h && !(e in t) && wd(e, i), of .call(this, t, e, u, i, d, s || Yu.stringFilter, l)) : (c = new Ef(this._pt, t, e, +u || 0, i - (u || 0), "boolean" == typeof h ? _f : yf, 0, d), l && (c.fp = l), a && c.modifier(a, this, t), this._pt = c)
        },
        sf = function (t, e, n, i, r, o) {
            var a, s, l, c;
            if (Ld[t] && !1 !== (a = new Ld[t]).init(r, a.rawVars ? e[t] : function (t, e, n, i, r) {
                    if (rd(t) && (t = cf(t, r, e, n, i)), !sd(t) || t.style && t.nodeType || dd(t) || ud(t)) return id(t) ? cf(t, r, e, n, i) : t;
                    var o, a = {};
                    for (o in t) a[o] = cf(t[o], r, e, n, i);
                    return a
                }(e[t], i, r, o, n), n, i, o) && (n._pt = s = new Ef(n._pt, r, t, 0, 1, a.render, a, 0, a.priority), n !== Ru))
                for (l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length; c--;) l[a._props[c]] = s;
            return a
        },
        lf = function t(e, n) {
            var i, r, o, a, s, l, c, h, u, d, p, f, m, v = e.vars,
                g = v.ease,
                y = v.startAt,
                _ = v.immediateRender,
                x = v.lazy,
                b = v.onUpdate,
                w = v.onUpdateParams,
                M = v.callbackScope,
                S = v.runBackwards,
                T = v.yoyoEase,
                E = v.keyframes,
                A = v.autoRevert,
                C = e._dur,
                L = e._startAt,
                P = e._targets,
                R = e.parent,
                O = R && "nested" === R.data ? R.parent._targets : P,
                D = "auto" === e._overwrite,
                I = e.timeline;
            if (I && (!E || !g) && (g = "none"), e._ease = Jp(g, Ju.ease), e._yEase = T ? Xp(Jp(!0 === T ? g : T, Ju.ease)) : 0, T && e._yoyo && !e._repeat && (T = e._yEase, e._yEase = e._ease, e._ease = T), !I) {
                if (f = (h = P[0] ? Nd(P[0]).harness : 0) && v[h.prop], i = Jd(v, Ed), L && L.render(-1, !0).kill(), y) {
                    if (Kd(e._startAt = df.set(P, Wd({
                            data: "isStart",
                            overwrite: !1,
                            parent: R,
                            immediateRender: !0,
                            lazy: ld(x),
                            startAt: null,
                            delay: 0,
                            onUpdate: b,
                            onUpdateParams: w,
                            callbackScope: M,
                            stagger: 0
                        }, y))), _)
                        if (n > 0) A || (e._startAt = 0);
                        else if (C && !(n < 0 && L)) return void(n && (e._zTime = n))
                } else if (S && C)
                    if (L) !A && (e._startAt = 0);
                    else if (n && (_ = !1), o = Wd({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: _ && ld(x),
                        immediateRender: _,
                        stagger: 0,
                        parent: R
                    }, i), f && (o[h.prop] = f), Kd(e._startAt = df.set(P, o)), _) {
                    if (!n) return
                } else t(e._startAt, 1e-8);
                for (e._pt = 0, x = C && ld(x) || x && !C, r = 0; r < P.length; r++) {
                    if (c = (s = P[r])._gsap || Id(P)[r]._gsap, e._ptLookup[r] = d = {}, Cd[c.id] && Ad.length && Hd(), p = O === P ? r : O.indexOf(s), h && !1 !== (u = new h).init(s, f || i, e, p, O) && (e._pt = a = new Ef(e._pt, s, u.name, 0, 1, u.render, u, 0, u.priority), u._props.forEach((function (t) {
                            d[t] = a
                        })), u.priority && (l = 1)), !h || f)
                        for (o in i) Ld[o] && (u = sf(o, i, e, p, s, O)) ? u.priority && (l = 1) : d[o] = a = af.call(e, s, o, "get", i[o], p, O, 0, v.stringFilter);
                    e._op && e._op[r] && e.kill(s, e._op[r]), D && e._pt && (rf = e, Tu.killTweensOf(s, d, e.globalTime(0)), m = !e.parent, rf = 0), e._pt && x && (Cd[c.id] = 1)
                }
                l && Tf(e), e._onInit && e._onInit(e)
            }
            e._from = !I && !!v.runBackwards, e._onUpdate = b, e._initted = (!e._op || e._pt) && !m
        },
        cf = function (t, e, n, i, r) {
            return rd(t) ? t.call(e, n, i, r) : id(t) && ~t.indexOf("random(") ? Ap(t) : t
        },
        hf = Dd + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
        uf = (hf + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
        df = function (t) {
            function e(e, n, i, r) {
                var o;
                "number" == typeof n && (i.duration = n, n = i, i = null);
                var a, s, l, c, h, u, d, p, f = (o = t.call(this, r ? n : Zd(n), i) || this).vars,
                    m = f.duration,
                    v = f.delay,
                    g = f.immediateRender,
                    y = f.stagger,
                    _ = f.overwrite,
                    x = f.keyframes,
                    b = f.defaults,
                    w = f.scrollTrigger,
                    M = f.yoyoEase,
                    S = o.parent,
                    T = (dd(e) || ud(e) ? od(e[0]) : "length" in n) ? [e] : xp(e);
                if (o._targets = T.length ? Id(T) : Md("GSAP target " + e + " not found. https://greensock.com", !Yu.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = _, x || y || hd(m) || hd(v)) {
                    if (n = o.vars, (a = o.timeline = new nf({
                            data: "nested",
                            defaults: b || {}
                        })).kill(), a.parent = Mu(o), x) Wd(a.vars.defaults, {
                        ease: "none"
                    }), x.forEach((function (t) {
                        return a.to(T, t, ">")
                    }));
                    else {
                        if (c = T.length, d = y ? wp(y) : Td, sd(y))
                            for (h in y) ~hf.indexOf(h) && (p || (p = {}), p[h] = y[h]);
                        for (s = 0; s < c; s++) {
                            for (h in l = {}, n) uf.indexOf(h) < 0 && (l[h] = n[h]);
                            l.stagger = 0, M && (l.yoyoEase = M), p && Xd(l, p), u = T[s], l.duration = +cf(m, Mu(o), s, u, T), l.delay = (+cf(v, Mu(o), s, u, T) || 0) - o._delay, !y && 1 === c && l.delay && (o._delay = v = l.delay, o._start += v, l.delay = 0), a.to(u, l, d(s, u, T))
                        }
                        a.duration() ? m = v = 0 : o.timeline = 0
                    }
                    m || o.duration(m = a.duration())
                } else o.timeline = 0;
                return !0 === _ && (rf = Mu(o), Tu.killTweensOf(T), rf = 0), S && ap(S, Mu(o)), (g || !m && !x && o._start === Bd(S._time) && ld(g) && function t(e) {
                    return !e || e._ts && t(e.parent)
                }(Mu(o)) && "nested" !== S.data) && (o._tTime = -1e-8, o.render(Math.max(0, -v))), w && lp(Mu(o), w), o
            }
            Su(e, t);
            var n = e.prototype;
            return n.render = function (t, e, n) {
                var i, r, o, a, s, l, c, h, u, d = this._time,
                    p = this._tDur,
                    f = this._dur,
                    m = t > p - 1e-8 && t >= 0 ? p : t < 1e-8 ? 0 : t;
                if (f) {
                    if (m !== this._tTime || !t || n || this._startAt && this._zTime < 0 != t < 0) {
                        if (i = m, h = this.timeline, this._repeat) {
                            if (a = f + this._rDelay, i = Bd(m % a), m === p ? (o = this._repeat, i = f) : ((o = ~~(m / a)) && o === m / a && (i = f, o--), i > f && (i = f)), (l = this._yoyo && 1 & o) && (u = this._yEase, i = f - i), s = np(this._tTime, a), i === d && !n && this._initted) return this;
                            o !== s && (h && this._yEase && Yp(h, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(Bd(a * o), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (cp(this, t < 0 ? t : i, n, e)) return this._tTime = 0, this;
                            if (f !== this._dur) return this.render(t, e, n)
                        }
                        for (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (u || this._ease)(i / f), this._from && (this.ratio = c = 1 - c), i && !d && !e && Pp(this, "onStart"), r = this._pt; r;) r.r(c, r.d), r = r._next;
                        h && h.render(t < 0 ? t : !i && l ? -1e-8 : h._dur * c, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), Pp(this, "onUpdate")), this._repeat && o !== s && this.vars.onRepeat && !e && this.parent && Pp(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && Kd(this, 1), e || t < 0 && !d || !m && !d || (Pp(this, m === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                    }
                } else ! function (t, e, n, i) {
                    var r, o, a = t.ratio,
                        s = e < 0 || !e && a && !t._start && t._zTime > 1e-8 && !t._dp._lock || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data ? 0 : 1,
                        l = t._rDelay,
                        c = 0;
                    if (l && t._repeat && (c = mp(0, t._tDur, e), np(c, l) !== (o = np(t._tTime, l)) && (a = 1 - s, t.vars.repeatRefresh && t._initted && t.invalidate())), s !== a || i || 1e-8 === t._zTime || !e && t._zTime) {
                        if (!t._initted && cp(t, e, i, n)) return;
                        for (o = t._zTime, t._zTime = e || (n ? 1e-8 : 0), n || (n = e && !o), t.ratio = s, t._from && (s = 1 - s), t._time = 0, t._tTime = c, n || Pp(t, "onStart"), r = t._pt; r;) r.r(s, r.d), r = r._next;
                        t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && Pp(t, "onUpdate"), c && t._repeat && !n && t.parent && Pp(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === s && (s && Kd(t, 1), n || (Pp(t, s ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                    } else t._zTime || (t._zTime = e)
                }(this, t, e, n);
                return this
            }, n.targets = function () {
                return this._targets
            }, n.invalidate = function () {
                return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
            }, n.kill = function (t, e) {
                if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return Rp(this);
                if (this.timeline) {
                    var n = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, rf && !0 !== rf.vars.overwrite)._first || Rp(this), this.parent && n !== this.timeline.totalDuration() && hp(this, this._dur * this.timeline._tDur / n, 0, 1), this
                }
                var i, r, o, a, s, l, c, h = this._targets,
                    u = t ? xp(t) : h,
                    d = this._ptLookup,
                    p = this._pt;
                if ((!e || "all" === e) && function (t, e) {
                        for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];);
                        return n < 0
                    }(h, u)) return "all" === e && (this._pt = 0), Rp(this);
                for (i = this._op = this._op || [], "all" !== e && (id(e) && (s = {}, zd(e, (function (t) {
                        return s[t] = 1
                    })), e = s), e = function (t, e) {
                        var n, i, r, o, a = t[0] ? Nd(t[0]).harness : 0,
                            s = a && a.aliases;
                        if (!s) return e;
                        for (i in n = Xd({}, e), s)
                            if (i in n)
                                for (r = (o = s[i].split(",")).length; r--;) n[o[r]] = n[i];
                        return n
                    }(h, e)), c = h.length; c--;)
                    if (~u.indexOf(h[c]))
                        for (s in r = d[c], "all" === e ? (i[c] = e, a = r, o = {}) : (o = i[c] = i[c] || {}, a = e), a)(l = r && r[s]) && ("kill" in l.d && !0 !== l.d.kill(s) || Qd(this, l, "_pt"), delete r[s]), "all" !== o && (o[s] = 1);
                return this._initted && !this._pt && p && Rp(this), this
            }, e.to = function (t, n) {
                return new e(t, n, arguments[2])
            }, e.from = function (t, n) {
                return new e(t, Ud(arguments, 1))
            }, e.delayedCall = function (t, n, i, r) {
                return new e(n, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: n,
                    onReverseComplete: n,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: r
                })
            }, e.fromTo = function (t, n, i) {
                return new e(t, Ud(arguments, 2))
            }, e.set = function (t, n) {
                return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
            }, e.killTweensOf = function (t, e, n) {
                return Tu.killTweensOf(t, e, n)
            }, e
        }(ef);
    Wd(df.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), zd("staggerTo,staggerFrom,staggerFromTo", (function (t) {
        df[t] = function () {
            var e = new nf,
                n = gp.call(arguments, 0);
            return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
        }
    }));
    var pf = function (t, e, n) {
            return t[e] = n
        },
        ff = function (t, e, n) {
            return t[e](n)
        },
        mf = function (t, e, n, i) {
            return t[e](i.fp, n)
        },
        vf = function (t, e, n) {
            return t.setAttribute(e, n)
        },
        gf = function (t, e) {
            return rd(t[e]) ? ff : ad(t[e]) && t.setAttribute ? vf : pf
        },
        yf = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
        },
        _f = function (t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        },
        xf = function (t, e) {
            var n = e._pt,
                i = "";
            if (!t && e.b) i = e.b;
            else if (1 === t && e.e) i = e.e;
            else {
                for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                i += e.c
            }
            e.set(e.t, e.p, i, e)
        },
        bf = function (t, e) {
            for (var n = e._pt; n;) n.r(t, n.d), n = n._next
        },
        wf = function (t, e, n, i) {
            for (var r, o = this._pt; o;) r = o._next, o.p === i && o.modifier(t, e, n), o = r
        },
        Mf = function (t) {
            for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? Qd(this, i, "_pt") : i.dep || (e = 1), i = n;
            return !e
        },
        Sf = function (t, e, n, i) {
            i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
        },
        Tf = function (t) {
            for (var e, n, i, r, o = t._pt; o;) {
                for (e = o._next, n = i; n && n.pr > o.pr;) n = n._next;
                (o._prev = n ? n._prev : r) ? o._prev._next = o: i = o, (o._next = n) ? n._prev = o : r = o, o = e
            }
            t._pt = i
        },
        Ef = function () {
            function t(t, e, n, i, r, o, a, s, l) {
                this.t = e, this.s = i, this.c = r, this.p = n, this.r = o || yf, this.d = a || this, this.set = s || pf, this.pr = l || 0, this._next = t, t && (t._prev = this)
            }
            return t.prototype.modifier = function (t, e, n) {
                this.mSet = this.mSet || this.set, this.set = Sf, this.m = t, this.mt = n, this.tween = e
            }, t
        }();
    zd(Dd + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
        return Ed[t] = 1
    })), _d.TweenMax = _d.TweenLite = df, _d.TimelineLite = _d.TimelineMax = nf, Tu = new nf({
        sortChildren: !1,
        defaults: Ju,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), Yu.stringFilter = Up;
    var Af = {
        registerPlugin: function () {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
            e.forEach((function (t) {
                return Op(t)
            }))
        },
        timeline: function (t) {
            return new nf(t)
        },
        getTweensOf: function (t, e) {
            return Tu.getTweensOf(t, e)
        },
        getProperty: function (t, e, n, i) {
            id(t) && (t = xp(t)[0]);
            var r = Nd(t || {}).get,
                o = n ? jd : Vd;
            return "native" === n && (n = ""), t ? e ? o((Ld[e] && Ld[e].get || r)(t, e, n, i)) : function (e, n, i) {
                return o((Ld[e] && Ld[e].get || r)(t, e, n, i))
            } : t
        },
        quickSetter: function (t, e, n) {
            if ((t = xp(t)).length > 1) {
                var i = t.map((function (t) {
                        return Pf.quickSetter(t, e, n)
                    })),
                    r = i.length;
                return function (t) {
                    for (var e = r; e--;) i[e](t)
                }
            }
            t = t[0] || {};
            var o = Ld[e],
                a = Nd(t),
                s = a.harness && (a.harness.aliases || {})[e] || e,
                l = o ? function (e) {
                    var i = new o;
                    Ru._pt = 0, i.init(t, n ? e + n : e, Ru, 0, [t]), i.render(1, i), Ru._pt && bf(1, Ru)
                } : a.set(t, s);
            return o ? l : function (e) {
                return l(t, s, n ? e + n : e, a, 1)
            }
        },
        isTweening: function (t) {
            return Tu.getTweensOf(t, !0).length > 0
        },
        defaults: function (t) {
            return t && t.ease && (t.ease = Jp(t.ease, Ju.ease)), Yd(Ju, t || {})
        },
        config: function (t) {
            return Yd(Yu, t || {})
        },
        registerEffect: function (t) {
            var e = t.name,
                n = t.effect,
                i = t.plugins,
                r = t.defaults,
                o = t.extendTimeline;
            (i || "").split(",").forEach((function (t) {
                return t && !Ld[t] && !_d[t] && Md(e + " effect requires " + t + " plugin.")
            })), Pd[e] = function (t, e, i) {
                return n(xp(t), Wd(e || {}, r), i)
            }, o && (nf.prototype[e] = function (t, n, i) {
                return this.add(Pd[e](t, sd(n) ? n : (i = n) && {}, this), i)
            })
        },
        registerEase: function (t, e) {
            Vp[t] = Jp(e)
        },
        parseEase: function (t, e) {
            return arguments.length ? Jp(t, e) : Vp
        },
        getById: function (t) {
            return Tu.getById(t)
        },
        exportRoot: function (t, e) {
            void 0 === t && (t = {});
            var n, i, r = new nf(t);
            for (r.smoothChildTiming = ld(t.smoothChildTiming), Tu.remove(r), r._dp = 0, r._time = r._tTime = Tu._time, n = Tu._first; n;) i = n._next, !e && !n._dur && n instanceof df && n.vars.onComplete === n._targets[0] || sp(r, n, n._start - n._delay), n = i;
            return sp(Tu, r, 0), r
        },
        utils: {
            wrap: function t(e, n, i) {
                var r = n - e;
                return dd(e) ? Ep(e, t(0, e.length), n) : fp(i, (function (t) {
                    return (r + (t - e) % r) % r + e
                }))
            },
            wrapYoyo: function t(e, n, i) {
                var r = n - e,
                    o = 2 * r;
                return dd(e) ? Ep(e, t(0, e.length - 1), n) : fp(i, (function (t) {
                    return e + ((t = (o + (t - e) % o) % o || 0) > r ? o - t : t)
                }))
            },
            distribute: wp,
            random: Tp,
            snap: Sp,
            normalize: function (t, e, n) {
                return Cp(t, e, 0, 1, n)
            },
            getUnit: vp,
            clamp: function (t, e, n) {
                return fp(n, (function (n) {
                    return mp(t, e, n)
                }))
            },
            splitColor: Np,
            toArray: xp,
            mapRange: Cp,
            pipe: function () {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                return function (t) {
                    return e.reduce((function (t, e) {
                        return e(t)
                    }), t)
                }
            },
            unitize: function (t, e) {
                return function (n) {
                    return t(parseFloat(n)) + (e || vp(n))
                }
            },
            interpolate: function t(e, n, i, r) {
                var o = isNaN(e + n) ? 0 : function (t) {
                    return (1 - t) * e + t * n
                };
                if (!o) {
                    var a, s, l, c, h, u = id(e),
                        d = {};
                    if (!0 === i && (r = 1) && (i = null), u) e = {
                        p: e
                    }, n = {
                        p: n
                    };
                    else if (dd(e) && !dd(n)) {
                        for (l = [], c = e.length, h = c - 2, s = 1; s < c; s++) l.push(t(e[s - 1], e[s]));
                        c--, o = function (t) {
                            t *= c;
                            var e = Math.min(h, ~~t);
                            return l[e](t - e)
                        }, i = n
                    } else r || (e = Xd(dd(e) ? [] : {}, e));
                    if (!l) {
                        for (a in n) af.call(d, e, a, "get", n[a]);
                        o = function (t) {
                            return bf(t, d) || (u ? e.p : e)
                        }
                    }
                }
                return fp(i, o)
            },
            shuffle: bp
        },
        install: bd,
        effects: Pd,
        ticker: Hp,
        updateRoot: nf.updateRoot,
        plugins: Ld,
        globalTimeline: Tu,
        core: {
            PropTween: Ef,
            globals: Sd,
            Tween: df,
            Timeline: nf,
            Animation: ef,
            getCache: Nd,
            _removeLinkedListItem: Qd
        }
    };
    zd("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
        return Af[t] = df[t]
    })), Hp.add(nf.updateRoot), Ru = Af.to({}, {
        duration: 0
    });
    var Cf = function (t, e) {
            for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
            return n
        },
        Lf = function (t, e) {
            return {
                name: t,
                rawVars: 1,
                init: function (t, n, i) {
                    i._onInit = function (t) {
                        var i, r;
                        if (id(n) && (i = {}, zd(n, (function (t) {
                                return i[t] = 1
                            })), n = i), e) {
                            for (r in i = {}, n) i[r] = e(n[r]);
                            n = i
                        }! function (t, e) {
                            var n, i, r, o = t._targets;
                            for (n in e)
                                for (i = o.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = Cf(r, n)), r && r.modifier && r.modifier(e[n], t, o[i], n))
                        }(t, n)
                    }
                }
            }
        },
        Pf = Af.registerPlugin({
            name: "attr",
            init: function (t, e, n, i, r) {
                var o, a;
                for (o in e)(a = this.add(t, "setAttribute", (t.getAttribute(o) || 0) + "", e[o], i, r, 0, 0, o)) && (a.op = o), this._props.push(o)
            }
        }, {
            name: "endArray",
            init: function (t, e) {
                for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n])
            }
        }, Lf("roundProps", Mp), Lf("modifiers"), Lf("snap", Sp)) || Af;
    df.version = nf.version = Pf.version = "3.5.1", Lu = 1, cd() && Gp();
    Vp.Power0, Vp.Power1, Vp.Power2, Vp.Power3, Vp.Power4, Vp.Linear, Vp.Quad, Vp.Cubic, Vp.Quart, Vp.Quint, Vp.Strong, Vp.Elastic, Vp.Back, Vp.SteppedEase, Vp.Bounce, Vp.Sine, Vp.Expo, Vp.Circ;
    /*!
     * CSSPlugin 3.5.1
     * https://greensock.com
     *
     * Copyright 2008-2020, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Rf, Of, Df, If, Nf, kf, zf, Bf, Ff = {},
        Uf = 180 / Math.PI,
        Hf = Math.PI / 180,
        Gf = Math.atan2,
        Vf = /([A-Z])/g,
        jf = /(?:left|right|width|margin|padding|x)/i,
        Wf = /[\s,\(]\S/,
        qf = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        Xf = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        },
        Yf = function (t, e) {
            return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        },
        Jf = function (t, e) {
            return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
        },
        Zf = function (t, e) {
            var n = e.s + e.c * t;
            e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
        },
        Qf = function (t, e) {
            return e.set(e.t, e.p, t ? e.e : e.b, e)
        },
        Kf = function (t, e) {
            return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
        },
        $f = function (t, e, n) {
            return t.style[e] = n
        },
        tm = function (t, e, n) {
            return t.style.setProperty(e, n)
        },
        em = function (t, e, n) {
            return t._gsap[e] = n
        },
        nm = function (t, e, n) {
            return t._gsap.scaleX = t._gsap.scaleY = n
        },
        im = function (t, e, n, i, r) {
            var o = t._gsap;
            o.scaleX = o.scaleY = n, o.renderTransform(r, o)
        },
        rm = function (t, e, n, i, r) {
            var o = t._gsap;
            o[e] = n, o.renderTransform(r, o)
        },
        om = "transform",
        am = om + "Origin",
        sm = function (t, e) {
            var n = Of.createElementNS ? Of.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Of.createElement(t);
            return n.style ? n : Of.createElement(t)
        },
        lm = function t(e, n, i) {
            var r = getComputedStyle(e);
            return r[n] || r.getPropertyValue(n.replace(Vf, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, hm(n) || n, 1) || ""
        },
        cm = "O,Moz,ms,Ms,Webkit".split(","),
        hm = function (t, e, n) {
            var i = (e || Nf).style,
                r = 5;
            if (t in i && !n) return t;
            for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(cm[r] + t in i););
            return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? cm[r] : "") + t
        },
        um = function () {
            "undefined" != typeof window && window.document && (Rf = window, Of = Rf.document, Df = Of.documentElement, Nf = sm("div") || {
                style: {}
            }, kf = sm("div"), om = hm(om), am = om + "Origin", Nf.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Bf = !!hm("perspective"), If = 1)
        },
        dm = function t(e) {
            var n, i = sm("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                r = this.parentNode,
                o = this.nextSibling,
                a = this.style.cssText;
            if (Df.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
            } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
            return r && (o ? r.insertBefore(this, o) : r.appendChild(this)), Df.removeChild(i), this.style.cssText = a, n
        },
        pm = function (t, e) {
            for (var n = e.length; n--;)
                if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
        },
        fm = function (t) {
            var e;
            try {
                e = t.getBBox()
            } catch (n) {
                e = dm.call(t, !0)
            }
            return e && (e.width || e.height) || t.getBBox === dm || (e = dm.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                x: +pm(t, ["x", "cx", "x1"]) || 0,
                y: +pm(t, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        },
        mm = function (t) {
            return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !fm(t))
        },
        vm = function (t, e) {
            if (e) {
                var n = t.style;
                e in Ff && e !== am && (e = om), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(Vf, "-$1").toLowerCase())) : n.removeAttribute(e)
            }
        },
        gm = function (t, e, n, i, r, o) {
            var a = new Ef(t._pt, e, n, 0, 1, o ? Kf : Qf);
            return t._pt = a, a.b = i, a.e = r, t._props.push(n), a
        },
        ym = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        _m = function t(e, n, i, r) {
            var o, a, s, l, c = parseFloat(i) || 0,
                h = (i + "").trim().substr((c + "").length) || "px",
                u = Nf.style,
                d = jf.test(n),
                p = "svg" === e.tagName.toLowerCase(),
                f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
                m = "px" === r,
                v = "%" === r;
            return r === h || !c || ym[r] || ym[h] ? c : ("px" !== h && !m && (c = t(e, n, i, "px")), l = e.getCTM && mm(e), v && (Ff[n] || ~n.indexOf("adius")) ? Bd(c / (l ? e.getBBox()[d ? "width" : "height"] : e[f]) * 100) : (u[d ? "width" : "height"] = 100 + (m ? h : r), a = ~n.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode, l && (a = (e.ownerSVGElement || {}).parentNode), a && a !== Of && a.appendChild || (a = Of.body), (s = a._gsap) && v && s.width && d && s.time === Hp.time ? Bd(c / s.width * 100) : ((v || "%" === h) && (u.position = lm(e, "position")), a === e && (u.position = "static"), a.appendChild(Nf), o = Nf[f], a.removeChild(Nf), u.position = "absolute", d && v && ((s = Nd(a)).time = Hp.time, s.width = a[f]), Bd(m ? o * c / 100 : o && c ? 100 / o * c : 0))))
        },
        xm = function (t, e, n, i) {
            var r;
            return If || um(), e in qf && "transform" !== e && ~(e = qf[e]).indexOf(",") && (e = e.split(",")[0]), Ff[e] && "transform" !== e ? (r = Rm(t, i), r = "transformOrigin" !== e ? r[e] : Om(lm(t, am)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Sm[e] && Sm[e](t, e, n) || lm(t, e) || kd(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").indexOf(" ") ? _m(t, e, r, n) + n : r
        },
        bm = function (t, e, n, i) {
            if (!n || "none" === n) {
                var r = hm(e, t, 1),
                    o = r && lm(t, r, 1);
                o && o !== n ? (e = r, n = o) : "borderColor" === e && (n = lm(t, "borderTopColor"))
            }
            var a, s, l, c, h, u, d, p, f, m, v, g, y = new Ef(this._pt, t.style, e, 0, 1, xf),
                _ = 0,
                x = 0;
            if (y.b = n, y.e = i, n += "", "auto" === (i += "") && (t.style[e] = i, i = lm(t, e) || i, t.style[e] = n), Up(a = [n, i]), i = a[1], l = (n = a[0]).match(md) || [], (i.match(md) || []).length) {
                for (; s = md.exec(i);) d = s[0], f = i.substring(_, s.index), h ? h = (h + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (h = 1), d !== (u = l[x++] || "") && (c = parseFloat(u) || 0, v = u.substr((c + "").length), (g = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)), p = parseFloat(d), m = d.substr((p + "").length), _ = md.lastIndex - m.length, m || (m = m || Yu.units[e] || v, _ === i.length && (i += m, y.e += m)), v !== m && (c = _m(t, e, u, m) || 0), y._pt = {
                    _next: y._pt,
                    p: f || 1 === x ? f : ",",
                    s: c,
                    c: g ? g * p : p - c,
                    m: h && h < 4 ? Math.round : 0
                });
                y.c = _ < i.length ? i.substring(_, i.length) : ""
            } else y.r = "display" === e && "none" === i ? Kf : Qf;
            return gd.test(i) && (y.e = 0), this._pt = y, y
        },
        wm = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        Mm = function (t, e) {
            if (e.tween && e.tween._time === e.tween._dur) {
                var n, i, r, o = e.t,
                    a = o.style,
                    s = e.u,
                    l = o._gsap;
                if ("all" === s || !0 === s) a.cssText = "", i = 1;
                else
                    for (r = (s = s.split(",")).length; --r > -1;) n = s[r], Ff[n] && (i = 1, n = "transformOrigin" === n ? am : om), vm(o, n);
                i && (vm(o, om), l && (l.svg && o.removeAttribute("transform"), Rm(o, 1), l.uncache = 1))
            }
        },
        Sm = {
            clearProps: function (t, e, n, i, r) {
                if ("isFromStart" !== r.data) {
                    var o = t._pt = new Ef(t._pt, e, n, 0, 0, Mm);
                    return o.u = i, o.pr = -10, o.tween = r, t._props.push(n), 1
                }
            }
        },
        Tm = [1, 0, 0, 1, 0, 0],
        Em = {},
        Am = function (t) {
            return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
        },
        Cm = function (t) {
            var e = lm(t, om);
            return Am(e) ? Tm : e.substr(7).match(fd).map(Bd)
        },
        Lm = function (t, e) {
            var n, i, r, o, a = t._gsap || Nd(t),
                s = t.style,
                l = Cm(t);
            return a.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Tm : l : (l !== Tm || t.offsetParent || t === Df || a.svg || (r = s.display, s.display = "block", (n = t.parentNode) && t.offsetParent || (o = 1, i = t.nextSibling, Df.appendChild(t)), l = Cm(t), r ? s.display = r : vm(t, "display"), o && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : Df.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        },
        Pm = function (t, e, n, i, r, o) {
            var a, s, l, c = t._gsap,
                h = r || Lm(t, !0),
                u = c.xOrigin || 0,
                d = c.yOrigin || 0,
                p = c.xOffset || 0,
                f = c.yOffset || 0,
                m = h[0],
                v = h[1],
                g = h[2],
                y = h[3],
                _ = h[4],
                x = h[5],
                b = e.split(" "),
                w = parseFloat(b[0]) || 0,
                M = parseFloat(b[1]) || 0;
            n ? h !== Tm && (s = m * y - v * g) && (l = w * (-v / s) + M * (m / s) - (m * x - v * _) / s, w = w * (y / s) + M * (-g / s) + (g * x - y * _) / s, M = l) : (w = (a = fm(t)).x + (~b[0].indexOf("%") ? w / 100 * a.width : w), M = a.y + (~(b[1] || b[0]).indexOf("%") ? M / 100 * a.height : M)), i || !1 !== i && c.smooth ? (_ = w - u, x = M - d, c.xOffset = p + (_ * m + x * g) - _, c.yOffset = f + (_ * v + x * y) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = w, c.yOrigin = M, c.smooth = !!i, c.origin = e, c.originIsAbsolute = !!n, t.style[am] = "0px 0px", o && (gm(o, c, "xOrigin", u, w), gm(o, c, "yOrigin", d, M), gm(o, c, "xOffset", p, c.xOffset), gm(o, c, "yOffset", f, c.yOffset)), t.setAttribute("data-svg-origin", w + " " + M)
        },
        Rm = function (t, e) {
            var n = t._gsap || new tf(t);
            if ("x" in n && !e && !n.uncache) return n;
            var i, r, o, a, s, l, c, h, u, d, p, f, m, v, g, y, _, x, b, w, M, S, T, E, A, C, L, P, R, O, D, I, N = t.style,
                k = n.scaleX < 0,
                z = lm(t, am) || "0";
            return i = r = o = l = c = h = u = d = p = 0, a = s = 1, n.svg = !(!t.getCTM || !mm(t)), v = Lm(t, n.svg), n.svg && (E = !n.uncache && t.getAttribute("data-svg-origin"), Pm(t, E || z, !!E || n.originIsAbsolute, !1 !== n.smooth, v)), f = n.xOrigin || 0, m = n.yOrigin || 0, v !== Tm && (x = v[0], b = v[1], w = v[2], M = v[3], i = S = v[4], r = T = v[5], 6 === v.length ? (a = Math.sqrt(x * x + b * b), s = Math.sqrt(M * M + w * w), l = x || b ? Gf(b, x) * Uf : 0, (u = w || M ? Gf(w, M) * Uf + l : 0) && (s *= Math.cos(u * Hf)), n.svg && (i -= f - (f * x + m * w), r -= m - (f * b + m * M))) : (I = v[6], O = v[7], L = v[8], P = v[9], R = v[10], D = v[11], i = v[12], r = v[13], o = v[14], c = (g = Gf(I, R)) * Uf, g && (E = S * (y = Math.cos(-g)) + L * (_ = Math.sin(-g)), A = T * y + P * _, C = I * y + R * _, L = S * -_ + L * y, P = T * -_ + P * y, R = I * -_ + R * y, D = O * -_ + D * y, S = E, T = A, I = C), h = (g = Gf(-w, R)) * Uf, g && (y = Math.cos(-g), D = M * (_ = Math.sin(-g)) + D * y, x = E = x * y - L * _, b = A = b * y - P * _, w = C = w * y - R * _), l = (g = Gf(b, x)) * Uf, g && (E = x * (y = Math.cos(g)) + b * (_ = Math.sin(g)), A = S * y + T * _, b = b * y - x * _, T = T * y - S * _, x = E, S = A), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, h = 180 - h), a = Bd(Math.sqrt(x * x + b * b + w * w)), s = Bd(Math.sqrt(T * T + I * I)), g = Gf(S, T), u = Math.abs(g) > 2e-4 ? g * Uf : 0, p = D ? 1 / (D < 0 ? -D : D) : 0), n.svg && (E = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !Am(lm(t, om)), E && t.setAttribute("transform", E))), Math.abs(u) > 90 && Math.abs(u) < 270 && (k ? (a *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (s *= -1, u += u <= 0 ? 180 : -180)), n.x = ((n.xPercent = i && Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + "px", n.y = ((n.yPercent = r && Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + "px", n.z = o + "px", n.scaleX = Bd(a), n.scaleY = Bd(s), n.rotation = Bd(l) + "deg", n.rotationX = Bd(c) + "deg", n.rotationY = Bd(h) + "deg", n.skewX = u + "deg", n.skewY = d + "deg", n.transformPerspective = p + "px", (n.zOrigin = parseFloat(z.split(" ")[2]) || 0) && (N[am] = Om(z)), n.xOffset = n.yOffset = 0, n.force3D = Yu.force3D, n.renderTransform = n.svg ? km : Bf ? Nm : Im, n.uncache = 0, n
        },
        Om = function (t) {
            return (t = t.split(" "))[0] + " " + t[1]
        },
        Dm = function (t, e, n) {
            var i = vp(e);
            return Bd(parseFloat(e) + parseFloat(_m(t, "x", n + "px", i))) + i
        },
        Im = function (t, e) {
            e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Nm(t, e)
        },
        Nm = function (t, e) {
            var n = e || this,
                i = n.xPercent,
                r = n.yPercent,
                o = n.x,
                a = n.y,
                s = n.z,
                l = n.rotation,
                c = n.rotationY,
                h = n.rotationX,
                u = n.skewX,
                d = n.skewY,
                p = n.scaleX,
                f = n.scaleY,
                m = n.transformPerspective,
                v = n.force3D,
                g = n.target,
                y = n.zOrigin,
                _ = "",
                x = "auto" === v && t && 1 !== t || !0 === v;
            if (y && ("0deg" !== h || "0deg" !== c)) {
                var b, w = parseFloat(c) * Hf,
                    M = Math.sin(w),
                    S = Math.cos(w);
                w = parseFloat(h) * Hf, b = Math.cos(w), o = Dm(g, o, M * b * -y), a = Dm(g, a, -Math.sin(w) * -y), s = Dm(g, s, S * b * -y + y)
            }
            "0px" !== m && (_ += "perspective(" + m + ") "), (i || r) && (_ += "translate(" + i + "%, " + r + "%) "), (x || "0px" !== o || "0px" !== a || "0px" !== s) && (_ += "0px" !== s || x ? "translate3d(" + o + ", " + a + ", " + s + ") " : "translate(" + o + ", " + a + ") "), "0deg" !== l && (_ += "rotate(" + l + ") "), "0deg" !== c && (_ += "rotateY(" + c + ") "), "0deg" !== h && (_ += "rotateX(" + h + ") "), "0deg" === u && "0deg" === d || (_ += "skew(" + u + ", " + d + ") "), 1 === p && 1 === f || (_ += "scale(" + p + ", " + f + ") "), g.style[om] = _ || "translate(0, 0)"
        },
        km = function (t, e) {
            var n, i, r, o, a, s = e || this,
                l = s.xPercent,
                c = s.yPercent,
                h = s.x,
                u = s.y,
                d = s.rotation,
                p = s.skewX,
                f = s.skewY,
                m = s.scaleX,
                v = s.scaleY,
                g = s.target,
                y = s.xOrigin,
                _ = s.yOrigin,
                x = s.xOffset,
                b = s.yOffset,
                w = s.forceCSS,
                M = parseFloat(h),
                S = parseFloat(u);
            d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= Hf, p *= Hf, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -v, o = Math.cos(d - p) * v, p && (f *= Hf, a = Math.tan(p - f), r *= a = Math.sqrt(1 + a * a), o *= a, f && (a = Math.tan(f), n *= a = Math.sqrt(1 + a * a), i *= a)), n = Bd(n), i = Bd(i), r = Bd(r), o = Bd(o)) : (n = m, o = v, i = r = 0), (M && !~(h + "").indexOf("px") || S && !~(u + "").indexOf("px")) && (M = _m(g, "x", h, "px"), S = _m(g, "y", u, "px")), (y || _ || x || b) && (M = Bd(M + y - (y * n + _ * r) + x), S = Bd(S + _ - (y * i + _ * o) + b)), (l || c) && (a = g.getBBox(), M = Bd(M + l / 100 * a.width), S = Bd(S + c / 100 * a.height)), a = "matrix(" + n + "," + i + "," + r + "," + o + "," + M + "," + S + ")", g.setAttribute("transform", a), w && (g.style[om] = a)
        },
        zm = function (t, e, n, i, r, o) {
            var a, s, l = id(r),
                c = parseFloat(r) * (l && ~r.indexOf("rad") ? Uf : 1),
                h = o ? c * o : c - i,
                u = i + h + "deg";
            return l && ("short" === (a = r.split("_")[1]) && (h %= 360) !== h % 180 && (h += h < 0 ? 360 : -360), "cw" === a && h < 0 ? h = (h + 36e9) % 360 - 360 * ~~(h / 360) : "ccw" === a && h > 0 && (h = (h - 36e9) % 360 - 360 * ~~(h / 360))), t._pt = s = new Ef(t._pt, e, n, i, h, Yf), s.e = u, s.u = "deg", t._props.push(n), s
        },
        Bm = function (t, e, n) {
            var i, r, o, a, s, l, c, h = kf.style,
                u = n._gsap;
            for (r in h.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", h[om] = e, Of.body.appendChild(kf), i = Rm(kf, 1), Ff)(o = u[r]) !== (a = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (s = vp(o) !== (c = vp(a)) ? _m(n, r, o, c) : parseFloat(o), l = parseFloat(a), t._pt = new Ef(t._pt, u, r, s, l - s, Xf), t._pt.u = c || 0, t._props.push(r));
            Of.body.removeChild(kf)
        };
    zd("padding,margin,Width,Radius", (function (t, e) {
        var n = "Top",
            i = "Right",
            r = "Bottom",
            o = "Left",
            a = (e < 3 ? [n, i, r, o] : [n + o, n + i, r + i, r + o]).map((function (n) {
                return e < 2 ? t + n : "border" + n + t
            }));
        Sm[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
            var o, s;
            if (arguments.length < 4) return o = a.map((function (e) {
                return xm(t, e, n)
            })), 5 === (s = o.join(" ")).split(o[0]).length ? o[0] : s;
            o = (i + "").split(" "), s = {}, a.forEach((function (t, e) {
                return s[t] = o[e] = o[e] || o[(e - 1) / 2 | 0]
            })), t.init(e, s, r)
        }
    }));
    var Fm, Um, Hm = {
        name: "css",
        register: um,
        targetTest: function (t) {
            return t.style && t.nodeType
        },
        init: function (t, e, n, i, r) {
            var o, a, s, l, c, h, u, d, p, f, m, v, g, y, _, x, b, w, M, S = this._props,
                T = t.style;
            for (u in If || um(), e)
                if ("autoRound" !== u && (a = e[u], !Ld[u] || !sf(u, e, n, i, t, r)))
                    if (c = typeof a, h = Sm[u], "function" === c && (c = typeof (a = a.call(n, i, t, r))), "string" === c && ~a.indexOf("random(") && (a = Ap(a)), h) h(this, t, u, a, n) && (_ = 1);
                    else if ("--" === u.substr(0, 2)) this.add(T, "setProperty", getComputedStyle(t).getPropertyValue(u) + "", a + "", i, r, 0, 0, u);
            else if ("undefined" !== c) {
                if (o = xm(t, u), l = parseFloat(o), (f = "string" === c && "=" === a.charAt(1) ? +(a.charAt(0) + "1") : 0) && (a = a.substr(2)), s = parseFloat(a), u in qf && ("autoAlpha" === u && (1 === l && "hidden" === xm(t, "visibility") && s && (l = 0), gm(this, T, "visibility", l ? "inherit" : "hidden", s ? "inherit" : "hidden", !s)), "scale" !== u && "transform" !== u && ~(u = qf[u]).indexOf(",") && (u = u.split(",")[0])), m = u in Ff)
                    if (v || ((g = t._gsap).renderTransform || Rm(t), y = !1 !== e.smoothOrigin && g.smooth, (v = this._pt = new Ef(this._pt, T, om, 0, 1, g.renderTransform, g, 0, -1)).dep = 1), "scale" === u) this._pt = new Ef(this._pt, g, "scaleY", g.scaleY, f ? f * s : s - g.scaleY), S.push("scaleY", u), u += "X";
                    else {
                        if ("transformOrigin" === u) {
                            b = void 0, w = void 0, M = void 0, b = (x = a).split(" "), w = b[0], M = b[1] || "50%", "top" !== w && "bottom" !== w && "left" !== M && "right" !== M || (x = w, w = M, M = x), b[0] = wm[w] || w, b[1] = wm[M] || M, a = b.join(" "), g.svg ? Pm(t, a, 0, y, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== g.zOrigin && gm(this, g, "zOrigin", g.zOrigin, p), gm(this, T, u, Om(o), Om(a)));
                            continue
                        }
                        if ("svgOrigin" === u) {
                            Pm(t, a, 1, y, 0, this);
                            continue
                        }
                        if (u in Em) {
                            zm(this, g, u, l, a, f);
                            continue
                        }
                        if ("smoothOrigin" === u) {
                            gm(this, g, "smooth", g.smooth, a);
                            continue
                        }
                        if ("force3D" === u) {
                            g[u] = a;
                            continue
                        }
                        if ("transform" === u) {
                            Bm(this, a, t);
                            continue
                        }
                    }
                else u in T || (u = hm(u) || u);
                if (m || (s || 0 === s) && (l || 0 === l) && !Wf.test(a) && u in T) s || (s = 0), (d = (o + "").substr((l + "").length)) !== (p = vp(a) || (u in Yu.units ? Yu.units[u] : d)) && (l = _m(t, u, o, p)), this._pt = new Ef(this._pt, m ? g : T, u, l, f ? f * s : s - l, "px" !== p || !1 === e.autoRound || m ? Xf : Zf), this._pt.u = p || 0, d !== p && (this._pt.b = o, this._pt.r = Jf);
                else if (u in T) bm.call(this, t, u, o, a);
                else {
                    if (!(u in t)) {
                        wd(u, a);
                        continue
                    }
                    this.add(t, u, t[u], a, i, r)
                }
                S.push(u)
            }
            _ && Tf(this)
        },
        get: xm,
        aliases: qf,
        getSetter: function (t, e, n) {
            var i = qf[e];
            return i && i.indexOf(",") < 0 && (e = i), e in Ff && e !== am && (t._gsap.x || xm(t, "x")) ? n && zf === n ? "scale" === e ? nm : em : (zf = n || {}) && ("scale" === e ? im : rm) : t.style && !ad(t.style[e]) ? $f : ~e.indexOf("-") ? tm : gf(t, e)
        },
        core: {
            _removeProperty: vm,
            _getMatrix: Lm
        }
    };
    Pf.utils.checkPrefix = hm, Um = zd("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (Fm = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
        Ff[t] = 1
    })), zd(Fm, (function (t) {
        Yu.units[t] = "deg", Em[t] = 1
    })), qf[Um[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Fm, zd("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
        var e = t.split(":");
        qf[e[1]] = Um[e[0]]
    })), zd("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
        Yu.units[t] = "px"
    })), Pf.registerPlugin(Hm);
    var Gm = Pf.registerPlugin(Hm) || Pf;
    Gm.core.Tween;
    const Vm = new class {
        constructor(t) {
            this.scene = new it, this.renderer = new hr({
                antialias: !0,
                alpha: !0
            }), this.width = window.innerWidth, this.height = window.innerHeight, this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.width, this.height), this.renderer.sortObjects = !1, this.renderer.outputEncoding = 3001, this.container = document.getElementById("c"), this.container.appendChild(this.renderer.domElement), this.camera = new $e(70, window.innerWidth / window.innerHeight, 300, 1e3), this.raycaster = new Kl, this.cameraDistance = 400, this.camera.position.set(0, 0, this.cameraDistance), this.camera.lookAt(0, 0, 0), this.time = 0, this.timeMulti = 0, this.paused = !1, this.clock = new Sl, this.speed = 2, this.setupResize(), this.addObjects(), this.resize(), this.render()
        }
        setupResize() {
            window.addEventListener("resize", this.resize.bind(this))
        }
        resize() {
            this.width = window.innerWidth, this.height = window.innerHeight, this.renderer.setSize(this.width, this.height), this.camera.aspect = this.width / this.height, this.camera.fov = 2 * Math.atan(this.width / this.camera.aspect / (2 * this.cameraDistance)) * (180 / Math.PI), this.camera.updateProjectionMatrix()
        }
        addObjects() {
            this.geometry = new un(1, 1, 1, 1), this.material = new Qe({
                extensions: {
                    derivatives: "#extensions GL_OES_standard_derivatives : enable"
                },
                uniforms: {
                    time: {
                        value: 0
                    },
                    resolution: {
                        value: new S
                    }
                },
                vertexShader: uh.a,
                fragmentShader: oh.a
            })
        }
        createBlock(t) {
            let e = this.material.clone(),
                n = new Fe(this.geometry, e);
            return n.scale.set(t.width, t.height, t.width / 2), n
        }
        createTexture(t) {
            let e = (new ys).load(t);
            return e.minFilter = 1006, e
        }
        createImg(t) {
            t.name ? (this.cA = new P(wu[t.name].clrA[0], wu[t.name].clrA[1], wu[t.name].clrA[2]), this.cB = new P(wu[t.name].clrB[0], wu[t.name].clrB[1], wu[t.name].clrB[2]), this.cC = new P(wu[t.name].clrC[0], wu[t.name].clrC[1], wu[t.name].clrC[2]), this.cD = new P(wu[t.name].clrD[0], wu[t.name].clrD[1], wu[t.name].clrD[2])) : (this.cA = new P(0, 0, 0), this.cB = new P(0, 0, 0), this.cC = new P(0, 0, 0), this.cD = new P(0, 0, 0)), this.materialImg = new Qe({
                extensions: {
                    derivatives: "#extensions GL_OES_standard_derivatives : enable"
                },
                uniforms: {
                    time: {
                        value: 0
                    },
                    fading: {
                        value: 0
                    },
                    waterChange: {
                        value: t.needW ? 1 : 0
                    },
                    imgChange: {
                        value: 0
                    },
                    txHome: {
                        value: null
                    },
                    txMain: {
                        value: null
                    },
                    clrShA: {
                        value: this.cA
                    },
                    clrShB: {
                        value: this.cB
                    },
                    clrShC: {
                        value: this.cC
                    },
                    clrShD: {
                        value: this.cD
                    },
                    veerClr: {
                        value: 0
                    },
                    resolution: {
                        value: new _
                    }
                },
                vertexShader: ph.a,
                fragmentShader: sh.a
            });
            let e = new M(t.image);
            e.needsUpdate = !0;
            let n, i, r = t.iHeight / t.iWidth;
            t.height / t.width > r ? (n = t.width / t.height * r, i = 1) : (n = 1, i = t.height / t.width / r), e.minFilter = 1006, this.materialImg.uniforms.resolution.value.x = t.width, this.materialImg.uniforms.resolution.value.y = t.height, this.materialImg.uniforms.resolution.value.z = n, this.materialImg.uniforms.resolution.value.w = i, this.materialImg.uniforms.txHome.value = e;
            let o = new Fe(this.geometry, this.materialImg);
            return o.scale.set(t.width, t.height, t.width / 2), o.frustumCulled = !1, o
        }
        createClip(t) {
            t.name ? (this.cA = new P(wu[t.name].clrA[0], wu[t.name].clrA[1], wu[t.name].clrA[2]), this.cB = new P(wu[t.name].clrB[0], wu[t.name].clrB[1], wu[t.name].clrB[2]), this.cC = new P(wu[t.name].clrC[0], wu[t.name].clrC[1], wu[t.name].clrC[2]), this.cD = new P(wu[t.name].clrD[0], wu[t.name].clrD[1], wu[t.name].clrD[2])) : (this.cA = new P(0, 0, 0), this.cB = new P(0, 0, 0), this.cC = new P(0, 0, 0), this.cD = new P(0, 0, 0)), this.materialClip = new Qe({
                extensions: {
                    derivatives: "#extensions GL_OES_standard_derivatives : enable"
                },
                uniforms: {
                    time: {
                        value: 0
                    },
                    fading: {
                        value: 0
                    },
                    imgChange: {
                        value: 0
                    },
                    txMain: {
                        value: null
                    },
                    clrShA: {
                        value: this.cA
                    },
                    clrShB: {
                        value: this.cB
                    },
                    clrShC: {
                        value: this.cC
                    },
                    clrShD: {
                        value: this.cD
                    },
                    veerClr: {
                        value: 0
                    },
                    resolution: {
                        value: new _
                    }
                },
                vertexShader: mh.a,
                fragmentShader: ch.a
            });
            let e = new Fe(this.geometry, this.materialClip);
            return e.scale.set(t.width, t.height, t.width / 2), e
        }
        stop() {
            this.paused = !1
        }
        play() {
            this.paused = !1, this.render()
        }
        render() {
            const t = this.clock.getDelta();
            this.time += t * this.speed, this.timeMulti += t * this.speed, this.scene.children.forEach(t => {
                t.material.uniforms && (t.material.uniforms.resolution.value.x = this.width, t.material.uniforms.resolution.value.y = this.height, t.material.uniforms.time.value = this.time)
            }), this.renderer.render(this.scene, this.camera)
        }
    }("canvas");
    let jm = {
        "divergence-studio": {
            url: "img/DS/main-divergence.jpg",
            img: ""
        },
        "norman-gabriel": {
            url: "img/NG/main-norman.jpg",
            img: ""
        },
        "riso-scotti": {
            url: "img/RS/main-scotti.jpg",
            img: ""
        },
        "tessileria-cavallini": {
            url: "img/TC/main-cavallini.jpg",
            img: ""
        }
    };
    const Wm = (t, e, n) => {
        var i = Math.max(0, Math.min(1, (n - t) / (e - t)));
        return i * i * (3 - 2 * i)
    };
    let qm = window.innerWidth > 1024;
    document.body;
    let Xm, Ym, Jm, Zm, Qm, Km, $m, tv, ev, nv, iv, rv = document.querySelectorAll(".gl");
    class ov extends d.Transition {
        out({
            from: t,
            trigger: e,
            done: n
        }) {
            Ym = Gm.timeline({
                paused: !0
            });
            let i = [];
            Qm = e.dataset.name, Zm = Rv.items[Qm], Zm.animated = !0, Zm.isBeingAnimatedNow = !0;
            for (let t in Rv.items) {
                let e = Rv.items[t];
                e.isBeingAnimatedNow || i.push(e.mesh.scale)
            }
            _v.stop(), xv.clean(), Ym.to(i, {
                y: 0,
                duration: .5,
                ease: "expo.inOut"
            }, "same").to(t, {
                opacity: 0,
                duration: .5
            }, "same").to(Zm.mesh.material.uniforms.veerClr, {
                value: 1,
                duration: 1.5,
                ease: "power3.inOut"
            }, "same").to(Zm.mesh.scale, {
                x: window.innerWidth,
                y: window.innerHeight,
                duration: .75,
                delay: .15,
                ease: "expo.inOut"
            }, "same+=.15").to(Zm.mesh.position, {
                x: 0,
                y: 0,
                duration: .75,
                delay: .15,
                ease: "expo.inOut",
                onComplete: n
            }, "same+=.15").set(Zm.mesh.material.uniforms.waterChange, {
                value: 0
            }, "same+=.15").set(Zm.mesh.material.uniforms.imgChange, {
                value: 1
            }, "same+=.15"), Ym.play(), rv = []
        } in ({
            from: t,
            to: e,
            done: n
        }) {
            t.remove(), Jm = Gm.timeline({
                paused: !0
            });
            let i = Zm.mesh,
                r = document.querySelector(".intro-p-img"),
                o = r.offsetWidth,
                a = r.offsetHeight,
                s = r.getBoundingClientRect().left - window.innerWidth / 2 + o / 2,
                l = -(r.getBoundingClientRect().top - window.innerHeight / 2 + a / 2),
                c = Vm.createTexture(jm[Qm].img.currentSrc);
            Jm.to(i.scale, {
                x: o,
                y: a,
                duration: .75,
                delay: .15,
                ease: "expo.inOut"
            }, "same").to(i.position, {
                x: s,
                y: l,
                duration: .75,
                delay: .15,
                ease: "expo.inOut",
                onComplete: () => {
                    i.material.uniforms.txMain.value = c, wv.startManually()
                }
            }, "same").fromTo(e, {
                opacity: 0
            }, {
                opacity: 1,
                duration: .5
            }, "same2").to(Zm.mesh.material.uniforms.veerClr, {
                value: 0,
                duration: .5,
                ease: "power3.inOut"
            }, "same2").to(i.material.uniforms.fading, {
                value: 0,
                duration: .7,
                onComplete: function () {
                    n(), Rv.destroyItems(), rv = document.querySelectorAll(".gl"), Rv.createItems(), Rv.initEvents(), xv.init(), xv.initEvs(), _v.start()
                }
            }, "same2"), Jm.play(), wv.resetFind(), wv.runFind(), _v.scrollTo(0, {
                duration: 1,
                disableLerp: !0
            }), _v.update()
        }
    }
    class av extends d.Transition {
        out({
            from: t,
            trigger: e,
            done: n
        }) {
            Km = Gm.timeline({
                paused: !0
            });
            let i = [];
            ev = e.dataset.name, tv = Rv.items[ev], tv.animated = !0, tv.isBeingAnimatedNow = !0;
            for (let t in Rv.items) {
                let e = Rv.items[t];
                e.isBeingAnimatedNow || i.push(e.mesh.scale)
            }
            e.classList.add("anim"), _v.stop(), xv.clean(), Km.to("#next-mask", {
                opacity: 0,
                duration: .6
            }, "same").to(t, {
                opacity: 0,
                duration: .5
            }, "same+=.15").to(tv.mesh.material.uniforms.veerClr, {
                value: 1,
                duration: 1.5,
                ease: "power3.inOut"
            }, "same").to(i, {
                y: 0,
                duration: .75,
                ease: "expo.inOut"
            }, "same+=.35").to(tv.mesh.scale, {
                x: window.innerWidth,
                y: window.innerHeight,
                duration: .75,
                delay: .15,
                ease: "expo.inOut"
            }, "same+=.3").to(tv.mesh.position, {
                x: 0,
                y: 0,
                duration: .75,
                delay: .15,
                ease: "expo.inOut",
                onComplete: n
            }, "same+=.3").set(tv.mesh.material.uniforms.imgChange, {
                value: 1
            }, "same+=.3"), Km.play(), rv = []
        } in ({
            from: t,
            to: e,
            done: n
        }) {
            t.remove(), $m = Gm.timeline({
                paused: !0
            });
            let i = tv.mesh,
                r = document.querySelector(".intro-p-img"),
                o = r.offsetWidth,
                a = r.offsetHeight,
                s = r.getBoundingClientRect().left - window.innerWidth / 2 + o / 2,
                l = -(r.getBoundingClientRect().top - window.innerHeight / 2 + a / 2),
                c = Vm.createTexture(jm[ev].img.currentSrc);
            $m.to(i.scale, {
                x: o,
                y: a,
                duration: .75,
                delay: .15,
                ease: "expo.inOut"
            }, "same").to(i.position, {
                x: s,
                y: l,
                duration: .75,
                delay: .15,
                ease: "expo.inOut",
                onComplete: () => {
                    i.material.uniforms.txMain.value = c, wv.startManually()
                }
            }, "same").fromTo(e, {
                opacity: 0
            }, {
                opacity: 1,
                duration: .5
            }, "same2").to(tv.mesh.material.uniforms.veerClr, {
                value: 0,
                duration: .5,
                ease: "power3.inOut"
            }, "same2").to(i.material.uniforms.fading, {
                value: 0,
                duration: .7,
                onComplete: function () {
                    n(), Rv.destroyItems(), rv = document.querySelectorAll(".gl"), Rv.createItems(), Rv.initEvents(), xv.init(), xv.initEvs(), _v.start()
                }
            }, "same2"), $m.play(), wv.resetFind(), wv.runFind(), _v.scrollTo(0, {
                duration: 1,
                disableLerp: !0
            }), _v.update()
        }
    }
    let sv, lv, cv = document.querySelector(".t"),
        hv = document.querySelector(".t-int");
    Gm.set(hv, {
        xPercent: -101,
        opacity: 1
    });
    class uv extends d.Transition {
        out({
            from: t,
            done: e
        }) {
            _v.stop(), xv.init(), nv = Gm.timeline({
                paused: !0
            }), Gm.set(cv, {
                pointerEvents: "all"
            }), nv.fromTo(hv, {
                xPercent: -101
            }, {
                xPercent: 0,
                duration: .55,
                ease: "power2.out",
                onComplete: () => {
                    e(), rv = [], Rv.destroyItems()
                }
            }, "fade"), nv.play()
        } in ({
            from: t,
            to: e,
            done: n
        }) {
            t.remove(), wv.resetFind(), wv.runFind(), _v.scrollTo(0, {
                duration: 1,
                disableLerp: !0
            }), setTimeout(() => {
                rv = document.querySelectorAll(".gl"), Rv.createItems(), Rv.initEvents()
            }, 100), iv = Gm.timeline({
                paused: !0,
                onStart: () => {
                    "home" != e.dataset.routerView && setTimeout(() => {
                        wv.startManually()
                    }, 400)
                }
            }), iv.fromTo(hv, {
                xPercent: 0
            }, {
                xPercent: 101,
                duration: .7,
                ease: "power3.inOut",
                onComplete: () => {
                    n(), Gm.set(hv, {
                        xPercent: -101
                    }), Gm.set(cv, {
                        xPercent: 0,
                        pointerEvents: "none"
                    }), xv.init(), xv.initEvs(), _v.update(), _v.start()
                }
            }, "fade"), iv.play()
        }
    }
    let dv, pv = document.querySelector(".t"),
        fv = document.querySelector(".t-int");
    Gm.set(fv, {
        xPercent: -101,
        opacity: 1
    });
    class mv extends d.Transition {
        out({
            from: t,
            done: e
        }) {
            _v.stop(), xv.init(), sv = Gm.timeline({
                paused: !0
            }), Gm.set(pv, {
                pointerEvents: "all"
            }), sv.fromTo(fv, {
                xPercent: -101
            }, {
                xPercent: 0,
                duration: .35,
                ease: "power2.out",
                onComplete: () => {
                    window.scrollTo(0, 0), e()
                }
            }, "fade"), sv.play()
        } in ({
            from: t,
            to: e,
            done: n
        }) {
            t.remove(), wv.resetFind(), wv.runFind(), lv = Gm.timeline({
                paused: !0,
                onStart: () => {
                    "home" != e.dataset.routerView && setTimeout(() => {
                        wv.startManually()
                    }, 400)
                }
            }), lv.fromTo(fv, {
                xPercent: 0
            }, {
                xPercent: 101,
                duration: .5,
                ease: "power3.inOut",
                onComplete: () => {
                    n(), Gm.set(fv, {
                        xPercent: -101
                    }), Gm.set(pv, {
                        xPercent: 0,
                        pointerEvents: "none"
                    }), xv.init(), xv.initEvs(), _v.update(), _v.start()
                }
            }, "fade"), lv.play()
        }
    }
    dv = qm ? new d.Core({
        transitions: {
            default: uv,
            contextual: {
                zoomglsl: ov,
                nextglsl: av
            }
        }
    }) : new d.Core({
        transitions: {
            default: mv,
            contextual: {
                zoomglsl: mv,
                nextglsl: mv
            }
        }
    });
    let vv = dv.properties.slug;
    dv.on("NAVIGATE_IN", ({
        location: t
    }) => {
        vv = dv.properties.slug
    }), dv.on("NAVIGATE_END", ({
        location: t
    }) => {
        if (t.anchor) {
            const e = document.querySelector(t.anchor);
            let n = 0;
            e && (n = "works" == e.id ? -150 : -220, _v.scrollTo(e, {
                offset: n
            }))
        }
    });
    let gv = 0,
        yv = 0;
    const _v = new p.a({
        el: document.querySelector("#page-loc"),
        smooth: !0,
        repeat: !0,
        lerp: .1,
        getSpeed: !0,
        getDirection: !0,
        reloadOnContextChange: !0
    });
    let xv = new class {
        constructor() {
            this.nav = "", this.setHide = !1, this.navBar = "", this.copyEm = "", this.bToTop = "", this.goToWorks = "", this.works = "", this.goToCont = "", this.contacts = "", this.wImg = "", this.wEnter = "", this.billbArr = {}, this.init(), this.initEvs()
        }
        init() {
            if (this.nav = document.getElementById("nav"), this.setHide = !1, this.navBar = document.getElementById("nav-state-on"), this.copyEm = document.getElementById("copy-email"), this.bToTop = document.getElementById("b-to-top"), this.goToWorks = document.querySelector(".go-to-works"), this.works = document.querySelector('[data-to="works"]'), this.goToCont = document.querySelector(".go-to-cont"), this.contacts = document.querySelector('[data-to="contacts"]'), this.wImg = document.querySelectorAll(".w-img"), this.wEnter = document.querySelectorAll(".enter-top, .enter-bot"), this.billboArr = {}, this.wImg.length >= 1)
                for (let t = 1; t <= this.wImg.length; t++) {
                    let e = Gm.timeline({
                            paused: !0,
                            reversed: !1
                        }),
                        n = document.querySelector('.w-enter-out[data-billbo="' + t + '"] .enter-top'),
                        i = document.querySelector('.w-enter-out[data-billbo="' + t + '"] .enter-bot');
                    e.fromTo(n, {
                        xPercent: -108,
                        rotate: 15,
                        scale: .5
                    }, {
                        xPercent: 0,
                        rotate: 1,
                        scale: 1,
                        duration: .6,
                        ease: "expo.inOut"
                    }, "eIn").fromTo(i, {
                        xPercent: -108,
                        rotate: -10,
                        scale: .5
                    }, {
                        xPercent: 0,
                        rotate: -.7,
                        scale: 1,
                        duration: .6,
                        ease: "expo.inOut"
                    }, "eIn+=.07"), this.billboArr["billbo" + t] = e
                }
            this.wEnter.length >= 1 && Gm.set(this.wEnter, {
                xPercent: -108
            })
        }
        initEvs() {
            this.wImg.forEach(t => {
                t.addEventListener("mouseenter", e => {
                    let n = t.dataset.billbo;
                    this.billboArr["billbo" + n].play()
                }), t.addEventListener("mouseout", e => {
                    let n = t.dataset.billbo;
                    this.billboArr["billbo" + n].reverse()
                })
            }), this.bToTop.addEventListener("click", t => {
                t.preventDefault(), _v.scrollTo(0)
            }), this.goToWorks.addEventListener("click", () => {
                _v.scrollTo(this.works, {
                    offset: -100
                })
            }), this.goToCont.addEventListener("click", () => {
                _v.scrollTo(this.contacts, {
                    offset: -100
                })
            }), this.copyEm && this.copyEm.addEventListener("click", () => {
                let t = this.copyEm.querySelector("input");
                this.copyEm.classList.add("copied"), t.value = "hello@gnrm.se", t.select(), document.execCommand("copy"), setTimeout(() => {
                    this.copyEm.classList.remove("copied")
                }, 2e3)
            })
        }
        clean() {
            this.copyEm = "", this.bToTop = "", this.goToWorks = "", this.works = "", this.goToCont = "", this.contacts = "", this.wImg = "", this.wEnter = "", this.billbArr = {}
        }
    };
    if (qm) _v.on("scroll", t => {
        let e = t.scroll.y / t.limit.y,
            n = t.delta.y;
        gv = t.scroll.y, yv = t.speed, "down" == t.direction && 0 == xv.setHide && n >= 10 ? (xv.nav.classList.add("setHide"), xv.setHide = !0) : "up" == t.direction && n < 200 && (xv.nav.classList.remove("setHide"), xv.setHide = !1), Gm.to(xv.navBar, {
            scaleX: e,
            duration: .3,
            ease: "power1.out"
        }), document.documentElement.setAttribute("data-direction", t.direction)
    });
    else {
        let t = 0;
        window.addEventListener("scroll", () => {
            let e = window.scrollY,
                n = "down",
                i = e / (document.body.offsetHeight - window.innerHeight);
            n = e > t ? "down" : "up", "down" == n && 0 == xv.setHide && e >= 30 ? (xv.nav.classList.add("setHide"), xv.setHide = !0) : "up" == n && (xv.nav.classList.remove("setHide"), xv.setHide = !1), Gm.to(xv.navBar, {
                scaleX: i,
                duration: .3,
                ease: "power1.out"
            }), t = e
        })
    }
    let bv, wv = new class {
        constructor() {
            this.isHome = document.getElementById("main-home"), this.circleP = document.querySelectorAll(".round-num"), this.arrCircles = new Object, this.arrowP = document.querySelectorAll(".arr-b"), this.arrArrows = new Object, this.runFind(), this.checkListeners()
        }
        runFind() {
            this.circleP.forEach((t, e) => {
                let n = t.dataset.bindto,
                    i = e,
                    r = t,
                    o = t.querySelector("circle"),
                    a = t.querySelector("span"),
                    s = Math.ceil(o.getTotalLength());
                Gm.set(o, {
                    strokeDasharray: s
                }), Gm.set(o, {
                    strokeDashoffset: s
                }), Gm.set(t, {
                    opacity: 1
                }), this.arrCircles[n] = {
                    i: i,
                    el: r,
                    elNum: a,
                    elCirc: o,
                    length: s,
                    played: !1
                }
            }), this.arrowP.forEach((t, e) => {
                let n = t.dataset.bindto,
                    i = e,
                    r = t,
                    o = [],
                    a = t.querySelectorAll("line");
                Gm.set(t, {
                    opacity: 1
                }), a.forEach(t => {
                    let e = Math.ceil(t.getTotalLength());
                    t.classList.contains("l-mid") ? o.push({
                        lineMid: t,
                        length: e,
                        played: !1
                    }) : o.push({
                        lineSide: t,
                        length: e,
                        played: !1
                    }), Gm.set(t, {
                        strokeDasharray: e
                    }), Gm.set(t, {
                        strokeDashoffset: e
                    })
                }), this.arrArrows[n] = {
                    i: i,
                    el: r,
                    lines: o
                }
            })
        }
        resetFind() {
            this.circleP = document.querySelectorAll(".round-num"), this.arrCircles = new Object, this.arrowP = document.querySelectorAll(".arr-b"), this.arrArrows = new Object
        }
        checkListeners() {
            _v.on("call", (t, e, n) => {
                document.dispatchEvent(new CustomEvent(t, {
                    detail: {
                        elem: n
                    }
                }))
            }), document.addEventListener("drawSvg", this.events.bind(this))
        }
        removeListeners() {
            document.removeEventListener("drawSvg", this.events.bind(this))
        }
        startManually() {
            const t = this.arrCircles,
                e = this.arrArrows;
            this.txtBot = document.querySelectorAll(".txt-bot span"), Gm.fromTo(this.txtBot, {
                opacity: 0,
                yPercent: 101
            }, {
                opacity: 1,
                yPercent: 0,
                stagger: {
                    each: .1
                },
                duration: 1.2,
                ease: "power3.out"
            }), t["work-s"].played || (Gm.to(t["work-s"].elCirc, {
                strokeDashoffset: 0,
                duration: 1,
                ease: "power3.inOut"
            }), Gm.to(t["work-s"].elNum, {
                opacity: 1,
                duration: 1,
                ease: "power3.inOut"
            }), t["work-s"].played = !0), e["work-s"].lines.forEach(t => {
                t.played || (t.lineMid ? Gm.to(t.lineMid, {
                    strokeDashoffset: 0,
                    duration: 1.2,
                    ease: "expo.out"
                }) : Gm.to(t.lineSide, {
                    strokeDashoffset: 0,
                    duration: .8,
                    delay: .175,
                    ease: "expo.out"
                }), t.played = !0)
            })
        }
        events(t) {
            let e = t.detail.elem.el.dataset.bind,
                n = this.arrCircles[e];
            Object.keys(n).forEach(t => {
                t && (n.played || (Gm.to(n.elCirc, {
                    strokeDashoffset: 0,
                    duration: 1,
                    ease: "power3.inOut"
                }), Gm.to(n.elNum, {
                    opacity: 1,
                    duration: 1,
                    ease: "power3.inOut"
                }), n.played = !0))
            }), this.arrArrows[e].lines.forEach(t => {
                t.played || (t.lineMid ? Gm.to(t.lineMid, {
                    strokeDashoffset: 0,
                    duration: 1.2,
                    ease: "expo.out"
                }) : Gm.to(t.lineSide, {
                    strokeDashoffset: 0,
                    duration: .8,
                    delay: .175,
                    ease: "expo.out"
                }), t.played = !0)
            })
        }
    };
    class Mv {
        constructor(t, e, n) {
            switch (this.scroll = e, this.DOM = {
                el: t,
                img: t.querySelector(".js-image")
            }, this.currentScroll = gv, this.animated = !1, this.isBeingAnimatedNow = !1, this.getSize(), this.dataT = t.dataset.type, this.dataName = t.dataset.name, this.waterEff = !1, this.dataName && (this.waterEff = !0), this.dataT) {
                case "img":
                    this.mesh = Vm.createImg({
                        width: this.width,
                        height: this.height,
                        src: this.src,
                        image: this.DOM.img,
                        needW: this.waterEff,
                        name: this.dataName,
                        iWidth: this.DOM.img.width,
                        iHeight: this.DOM.img.height
                    }), this.mesh.name = "img";
                    break;
                case "multiblock":
                    this.theCount = n, this.countBlocks = 13, this.fractSize = this.width / this.countBlocks, this.halfFract = this.fractSize /2, this.mesh = Vm.createBlock({
                        width: this.fractSize,
                        height: this.height
                    }), this.mesh.name = "multi";
                    break;
                case "next":
                    this.mesh = Vm.createClip({
                        width: this.width,
                        height: this.height,
                        name: this.dataName,
                        iWidth: this.width,
                        iHeight: this.height
                    }), this.mesh.name = "next";
                    break;
                case "block":
                    this.mesh = Vm.createBlock({
                        width: this.width,
                        height: this.height
                    })
            }
            Vm.scene.add(this.mesh), _v.on("scroll", t => {
                for (var e in this.scrollEls = t.currentElements, this.scrollEls) {
                    let t = this.scrollEls[e];
                    t.el == this.DOM.el && (1 == t.inView ? this.isVisible = !0 : this.isVisible = !1, this.mesh.visible = this.isVisible)
                }
            }), window.addEventListener("resize", () => this.resize()), this.render(0)
        }
        getSize() {
            const t = this.DOM.el.getBoundingClientRect(),
                e = t.top,
                n = e - window.innerHeight,
                i = e + t.height;
            this.insideTop = n - gv, this.insideRealTop = e + gv, this.insideBottom = i - gv + 50, this.width = t.width, this.height = t.height, this.left = t.left
        }
        resize() {
            this.getSize(), this.mesh.scale.set(this.width, this.height, 200), this.render(this.scroll.renderedStyles.translationY.current), this.scroll.shouldRender = !0, this.fractSize && (this.fractSize = this.width / this.countBlocks)
        }
        render(t) {
            var e;
            this.animated || (this.currentScroll = t, this.mesh.position.y = t + window.innerHeight / 2 - this.insideRealTop - this.height / 2, "multiblock" == this.dataT ? (this.movement = Wm(-5, this.fractSize + 40, Math.abs(Math.sin(1.08571 * Vm.timeMulti + Math.cos((e = .414, 2 * Math.PI * e * this.theCount / this.countBlocks))) * this.halfFract - this.halfFract)), this.wave = --this.movement * this.movement * this.movement + 1, this.mesh.position.x = 0 - window.innerWidth / 2 + this.left + this.fractSize / 2 + this.fractSize * (this.theCount - 1), this.mesh.scale.x = this.wave * this.fractSize) : this.mesh.position.x = 0 - window.innerWidth / 2 + this.left + this.width / 2)
        }
    }
    class Sv {
        constructor() {
            this.shouldRender = !1, this.items = new Object, this.createItems(), this.renderedStyles = {
                translationY: {
                    current: 0,
                    setValue: () => gv
                }
            }, this.update(), this.initEvents(), requestAnimationFrame(() => this.render())
        }
        update() {
            for (const t in this.renderedStyles) this.renderedStyles[t].current = this.renderedStyles[t].previous = this.renderedStyles[t].setValue();
            this.setPosition(), this.shouldRender = !0
        }
        setPosition() {
            if (Math.round(this.renderedStyles.translationY.previous) !== Math.round(this.renderedStyles.translationY.current) || this.renderedStyles.translationY.previous < 10) {
                this.shouldRender = !0;
                for (const t of Object.keys(this.items)) {
                    let e = this.items[t];
                    e.isVisible && e.render(this.renderedStyles.translationY.current)
                }
            }
            this.shouldRender && (this.shouldRender = !1, Vm.render())
        }
        createItems() {
            let t = 0;
            rv.forEach((e, n) => {
                let i = e.dataset.type,
                    r = e.dataset.name,
                    o = "";
                if (o = r || "Item" + (n + t), "multiblock" == i)
                    for (let i = 1; i <= 13; i++) t++, o = "Item" + (n + t), this.items[o] = new Mv(e, this, i);
                else this.items[o] = new Mv(e, this)
            })
        }
        destroyItems() {
            this.items = new Object;
            for (var t = Vm.scene.children.length - 1; t >= 0; t--) {
                let e = Vm.scene.children[t];
                Vm.scene.remove(e)
            }
        }
        initEvents() {
            _v.update();
            for (let t in this.items) {
                let e = this.items[t];
                "img" == e.dataT && "home" == vv && (e.DOM.el.addEventListener("mouseenter", t => {
                    this.mouseEnter(e)
                }), e.DOM.el.addEventListener("mouseleave", t => {
                    this.mouseLeave(e)
                })), "next" == e.dataT && (e.DOM.el.addEventListener("mouseenter", t => {
                    this.nextEnter(e)
                }), e.DOM.el.addEventListener("mouseleave", t => {
                    this.nextLeave(e)
                }))
            }
        }
        mouseEnter(t) {
            Gm.to(t.mesh.material.uniforms.fading, {
                duration: 1.2,
                value: 1
            })
        }
        mouseLeave(t) {
            t.animated || Gm.to(t.mesh.material.uniforms.fading, {
                duration: 1.2,
                value: 0
            })
        }
        nextEnter(t) {
            Gm.to(t.mesh.material.uniforms.fading, {
                duration: .3,
                value: 1,
                ease: "power3.inOut"
            })
        }
        nextLeave(t) {
            t.animated || Gm.to(t.mesh.material.uniforms.fading, {
                duration: .3,
                value: 0,
                ease: "power3.inOut"
            })
        }
        render() {
            for (const t in this.renderedStyles) this.renderedStyles[t].current = this.renderedStyles[t].setValue();
            this.setPosition(), Vm.time += Math.abs(yv) / 50, requestAnimationFrame(() => this.render())
        }
    }
    let Tv = [...document.querySelectorAll("img")];
    ! function (t) {
        for (let e in t) {
            const n = new Image;
            n.src = t[e].url, Tv.push(n), t[e].img = n
        }
    }(jm);
    const Ev = new Promise((t, e) => {
        bv = r()(Tv, {
            background: !0
        }, t)
    });
    let Av = 0,
        Cv = document.getElementById("l"),
        Lv = document.getElementById("l-n");
    bv.on("progress", (function (t, e) {
        Av = Math.ceil(t.progressedCount / Tv.length * 99), Lv.innerHTML = Av
    })), Ev.then(t => {
        Xm = t.images
    });
    const Pv = [Ev];
    let Rv;
    const Ov = document.getElementById("intro-txt-1");
    let Dv = Gm.timeline({
        paused: !0
    });
    if (Ov && qm) {
        const t = document.querySelectorAll(".g-un path"),
            e = document.querySelectorAll(".g-sual path"),
            n = document.querySelectorAll(".g-guy path"),
            i = Ov.querySelector(".elong-g"),
            r = Ov.querySelector(".elongate");
        let o = 1e3,
            a = "M244.51,27.07v73.72h-13.68l-1.72-9.36c-5.3,6.49-12.43,9.89-21.39,10.2c-0.33,0.02-0.66,0.03-1,0.03h-0.37 c-8.64,0-15.64-2.69-21.02-8.07c-5.38-5.37-8.06-14.01-8.06-25.92v-40.6h15.55v39.02c0,7.2,1.44,12.67,4.32,16.42 c2.3,2.99,5.5,4.79,9.58,5.38c0.33,0.05,0.66,0.09,1,0.12c0.72,0.08,1.46,0.11,2.23,0.11c5.96,0,10.61-2.18,13.97-6.55 s5.04-10.34,5.04-17.93V27.07H244.51z",
            s = "M395.89,27.07v73.72h-13.68l-1.72-9.36c-5.3,6.49-12.43,9.89-21.39,10.2 c-0.33,0.02-" + o + ".04,0.03-" + o + ".38,0.03h-0.37c-8.64,0-15.64-2.69-21.02-8.07c-5.38-5.37-8.06-14.01-8.06-25.92v-40.6h15.55v39.02 c0,7.2,1.44,12.67,4.32,16.42c2.3,2.99,5.5,4.79,9.58,5.38c0.33,0.05," + o + ".04,0.09," + o + ".38,0.12c0.72,0.08,1.46,0.11,2.23,0.11 c5.96,0,10.61-2.18,13.97-6.55s5.04-10.34,5.04-17.93V27.07H395.89z";
        const l = document.querySelector(".intro-s-1"),
            c = (document.getElementById("intro-txt-2"), document.querySelectorAll(".g-in-a path")),
            h = document.querySelectorAll(".g-in-a-side .txt-bot span"),
            u = document.getElementById("intro-txt-3"),
            d = document.querySelector(".g-quote-1 path"),
            p = u.querySelector(".elong-g"),
            f = u.querySelector(".elongate");
        let m = 700,
            v = 534.2,
            g = "M" + (659 - v) + " 46.7c-3.1-5.7-7.5-10.2-13.3-13.3-5.6-3.1-12-4.7-19.2-4.7H91.2c-7.2.1-13.6 1.6-19.2 4.7-5.5 3.2-9.9 7.6-13 13.3S54.3 59 54.3 66.4c0 7.5 1.6 14.1 4.7 19.8 3.1 5.7 7.5 10.1 13.3 13.3 5.6 3.1 12 4.6 19.2 4.7h" + (535.3 - v) + "c7.2-.1 13.6-1.6 19.2-4.7 5.7-3.1 10.1-7.5 13.3-13.3s4.7-12.3 4.7-19.8c-.3-7.4-1.8-14-5-19.7zM" + (641.9 - v) + " 84c-3.9 4.4-9 6.7-15.3 6.8H91.3c-6.2-.1-11.3-2.3-15.1-6.8-3.9-4.6-5.9-10.4-5.9-17.6s2-13.1 5.9-17.6c3.8-4.4 8.9-6.7 15.2-6.8h" + (535.3 - v) + "c6.3.1 11.4 2.4 15.3 6.8 4 4.6 6 10.4 6 17.6s-2.1 13.1-6.1 17.6z",
            y = "M" + (659 + m) + " 46.7c-3.1-5.7-7.5-10.2-13.3-13.3-5.6-3.1-12-4.7-19.2-4.7H91.2c-7.2.1-13.6 1.6-19.2 4.7-5.5 3.2-9.9 7.6-13 13.3S54.3 59 54.3 66.4c0 7.5 1.6 14.1 4.7 19.8 3.1 5.7 7.5 10.1 13.3 13.3 5.6 3.1 12 4.6 19.2 4.7h" + (535.3 + m) + "c7.2-.1 13.6-1.6 19.2-4.7 5.7-3.1 10.1-7.5 13.3-13.3s4.7-12.3 4.7-19.8c-.3-7.4-1.8-14-5-19.7zM" + (641.9 + m) + " 84c-3.9 4.4-9 6.7-15.3 6.8H91.3c-6.2-.1-11.3-2.3-15.1-6.8-3.9-4.6-5.9-10.4-5.9-17.6s2-13.1 5.9-17.6c3.8-4.4 8.9-6.7 15.2-6.8h" + (535.3 + m) + "c6.3.1 11.4 2.4 15.3 6.8 4 4.6 6 10.4 6 17.6s-2.1 13.1-6.1 17.6z";
        const _ = document.querySelectorAll(".g-rdinary path"),
            x = document.querySelector(".g-quote-2 path"),
            b = document.querySelectorAll(".g-world path"),
            w = document.querySelector(".intro-s-3");
        Gm.set([l, w], {
            opacity: 1
        }), Dv.fromTo(l, {
            xPercent: 0
        }, {
            xPercent: 101,
            duration: 1,
            ease: "expo.out"
        }, "intro").fromTo(w, {
            xPercent: 0
        }, {
            xPercent: -101,
            duration: 1,
            ease: "expo.out"
        }, "intro").fromTo(t, {
            x: Ov.getBBox().width + 10
        }, {
            x: 0,
            duration: 1,
            stagger: {
                each: .06
            },
            ease: "expo.out"
        }, "intro").fromTo(i, {
            x: Ov.getBBox().width
        }, {
            x: 0,
            duration: .8,
            ease: "expo.out"
        }, "intro+=.17").fromTo(r, {
            x: o - 150,
            attr: {
                d: s
            }
        }, {
            x: 0,
            attr: {
                d: a
            },
            duration: 1.3,
            ease: "power3.out"
        }, "intro+=.42").fromTo(e, {
            x: Ov.getBBox().width
        }, {
            x: 0,
            duration: 1.1,
            stagger: {
                each: .02
            },
            ease: "expo.out"
        }, "intro+=.71").fromTo(n, {
            x: Ov.getBBox().width
        }, {
            x: 0,
            duration: 1,
            stagger: {
                each: .02
            },
            ease: "expo.out"
        }, "intro+=1").fromTo(c, {
            yPercent: 102,
            opacity: 0
        }, {
            yPercent: 0,
            opacity: 1,
            duration: 1,
            stagger: {
                each: .1
            },
            ease: "expo.out"
        }, "intro+=.78").fromTo(h, {
            opacity: 0,
            yPercent: 101
        }, {
            opacity: 1,
            yPercent: 0,
            stagger: {
                each: .1
            },
            duration: 1.2,
            ease: "power3.out"
        }, "intro+=.9").fromTo(p, {
            x: u.getBBox().width
        }, {
            x: 0,
            duration: .7,
            ease: "expo.out"
        }, "intro+=.37").fromTo(f, {
            x: m,
            attr: {
                d: y
            }
        }, {
            x: 0,
            attr: {
                d: g
            },
            duration: 1.3,
            ease: "power3.out"
        }, "intro+=.52").fromTo(_, {
            x: u.getBBox().width
        }, {
            x: 0,
            duration: 1.1,
            stagger: {
                each: .02
            },
            ease: "expo.out"
        }, "intro+=.86").fromTo(d, {
            x: u.getBBox().width
        }, {
            x: 0,
            duration: 1.1,
            ease: "expo.out"
        }, "intro+=.37").fromTo(x, {
            x: u.getBBox().width
        }, {
            x: 0,
            duration: 1.1,
            ease: "expo.out"
        }, "intro+=.9").fromTo(b, {
            x: u.getBBox().width
        }, {
            x: 0,
            duration: 1,
            stagger: {
                each: .02
            },
            ease: "expo.out"
        }, "intro+=1.2").fromTo(d, {
            rotate: -10,
            transformOrigin: "right 50%",
            opacity: 0
        }, {
            rotate: 0,
            opacity: 1,
            duration: 1,
            ease: "power3.out"
        }, "intro+=1.5").fromTo(x, {
            rotate: 10,
            opacity: 0
        }, {
            rotate: 0,
            opacity: 1,
            duration: 1,
            ease: "power3.out"
        }, "intro+=1.65")
    }
    window.addEventListener("load", () => {
        document.body.classList.remove("loading"), document.body.classList.add("loaded"), Promise.all(Pv).then(() => {
            Lv.innerHTML = 100, gv = 0, _v.update(), Gm.to(Cv, {
                opacity: 0,
                duration: .5,
                delay: .25,
                pointerEvents: "none",
                onComplete: () => {
                    Ov && Dv.play(), wv.isHome || wv.startManually()
                }
            })
        }), qm && (Rv = new Sv)
    })
}, function (t, e) {}]);